<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021-09025</title>
      <link href="/2021/09/25/21-09-25/"/>
      <url>/2021/09/25/21-09-25/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac系统下React Native环境搭建</title>
      <link href="/2017/11/24/17-11-24/"/>
      <url>/2017/11/24/17-11-24/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里记录一下在Mac系统下搭建React Native开发环境的过程：</p></blockquote><h2 id="安装HomeBrew"><a href="#安装HomeBrew" class="headerlink" title="安装HomeBrew"></a>安装HomeBrew</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>安装完后可使用命令：<code>brew -v</code>查看其版本</p><h2 id="安装Node-JS"><a href="#安装Node-JS" class="headerlink" title="安装Node.JS"></a>安装Node.JS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>也可以在node.js官网下载pkg安装包进行安装。</p><h2 id="安装React-Native的命令行工具"><a href="#安装React-Native的命令行工具" class="headerlink" title="安装React Native的命令行工具"></a>安装React Native的命令行工具</h2><blockquote><p>需要sudo来安装，有些目录需要高级权限</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g react-native-cli</span><br></pre></td></tr></table></figure><h2 id="工具推荐安装"><a href="#工具推荐安装" class="headerlink" title="工具推荐安装"></a>工具推荐安装</h2><ol><li>Watchman，它是由Facebook提供的监视文件系统变更的工具<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install watchman</span><br></pre></td></tr></table></figure></li><li>Flow，它是一个静态的JS类型检查工具，可方便找出代码中可能存在的类型错误。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install flow</span><br></pre></td></tr></table></figure></li></ol><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><blockquote><p>安装就可以创建目录了，cd到你想要的目录下，执行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init YourProjectName</span><br></pre></td></tr></table></figure><p>在新建项目成功后，react也告诉我们该怎么运行：<code>react-native run-***</code>。</p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> RN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你的 Typeface 优化了吗？</title>
      <link href="/2017/08/11/17-08-11/"/>
      <url>/2017/08/11/17-08-11/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在分析 TraceView 记录时，我发现了下面的问题：</p><p><img src="http://dinson-blog.hdinson.cn/FmdSlNusIPsHUSJmga34V9unuX_H.png" alt=""></p><blockquote><p>在 TraceView 视图中，左侧显示的方法的调用关系，右边显示的是分析数据，你可以根据自己的需求对分析的数据进行筛选。</p></blockquote><p>在上面的截图中，第二列是 Incl CPU Time （某函数占用 CPU 的时间）。很明显能够看出 onCreateViewHolder 占用 CPU时间为 42.71，而 Typeface.createFromAsset() 方法神奇的霸占了其 97 % 时间，那么多的 findViewById() 也仅仅是 3%。</p><p>带着我的疑问去 Google 了一下，发现了下面的讨论： <a href="https://issuetracker.google.com/issues/36919609">Typeface.createFromAsset leaks asset stream</a></p><p>提问者通过分析底层 Typeface.c 源码，发现每次调用 Typeface.createFormAsset 都会在内存中加载一个新的实例，关键是分配的这些内存都不会被回收掉，这就造成了内存泄露问题。<br><span id="more"></span><br><!-- 这是　　缩进--></p><h2 id="布局分析"><a href="#布局分析" class="headerlink" title="布局分析"></a>布局分析</h2><p><img src="http://dinson-blog.hdinson.cn/FhM4pP9sdKGdqK4GJ7AW5xKwV3Wv.png" alt=""><br>如图顶部两个按钮用iconfont做的，在自定义iconfont控件的初始化中如下，使用的都是<strong>同一个字体资源</strong>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void init() &#123;</span><br><span class="line">    Typeface iconfont = Typeface.createFromAsset(getContext().getAssets(), &quot;iconfont/iconfont.ttf&quot;);</span><br><span class="line">    setTypeface(iconfont);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我用代码查看内存分配情况：</p><blockquote><p>adb shell dumpsys meminfo com.xxx.xxx</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/FgZG0qqLbY99MOTS8jFexeN1U1hB.png" alt=""></p><p>从上图可以看出，在 Asset Allocations 那个指标项，内存中共分配了 2 个 Roboto 字体实例(另外一个是自定义的字体文件)，也就是说每次调用 Typeface.createFromAsset 都会加载一个新的实例到内存中。显然这个是没有必要的，更何况每个分配的字体资源都不会回收掉。</p><p>针对这个问题，网上也有优化方案，那就是将首次解析的字体资源缓存起来，以后再用到相同的字体资源时，直接取缓存的即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TypefaceHelper &#123;</span><br><span class="line">    private static final String TAG = &quot;TypefaceHelper&quot;;</span><br><span class="line">    private static final SimpleArrayMap&lt;String, Typeface&gt; TYPEFACE_CACHE = new SimpleArrayMap&lt;String, Typeface&gt;();</span><br><span class="line"></span><br><span class="line">    public static Typeface get(Context context, String name) &#123;</span><br><span class="line">        synchronized (TYPEFACE_CACHE) &#123;</span><br><span class="line">            if (!TYPEFACE_CACHE.containsKey(name)) &#123;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    Typeface t = Typeface.createFromAsset(context.getAssets(), name);</span><br><span class="line">                    TYPEFACE_CACHE.put(name, t);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    Log.e(TAG, &quot;Could not get typeface &#x27;&quot; + name  + &quot;&#x27; because &quot; + e.getMessage());</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return TYPEFACE_CACHE.get(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我进行优化：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void init() &#123;</span><br><span class="line">    Typeface typeface = TypefaceUtils.get(getContext(), &quot;iconfont/iconfont.ttf&quot;);</span><br><span class="line">    setTypeface(typeface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>经过优化后，运行效果和之前一样，然后通过代码查看内存分配情况：</p><blockquote><p>adb shell dumpsys meminfo com.xxx.xxx</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/FiydGqW8bkwlOB4j7w45irF5GMNG.png" alt=""><br>可以清晰的看到内存中字体资源只分配了一个实例。</p><p>如果你的 APP 也在使用自定义字体，那就可以使用 <code>adb shell dumpsys meminfo &lt;package_name|pid&gt;</code>  查看内存分配情况，如果也有上述的问题，就可以使用缓存机制进行优化。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote><p>如果是在Recycleview的item中使用了自定义的字体，那么这个优化的效果会更加明显</p></blockquote><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿《最美有物》点赞效果</title>
      <link href="/2017/08/09/17-08-09/"/>
      <url>/2017/08/09/17-08-09/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="http://dinson-blog.hdinson.cn/FjwnD58IyZ6FuyyY42-B_8RVMpjh.gif" alt=""></p><span id="more"></span><!-- 这是　　缩进--><p>这样可爱的点赞特效，不得不给个好评啊， 有没有！</p><p>当然光点赞好评是不行的，今天得自己动手撸一个这样的笑脸点赞控件。</p><h2 id="主要流程和实现分析"><a href="#主要流程和实现分析" class="headerlink" title="主要流程和实现分析"></a>主要流程和实现分析</h2><p>点击触发 ：</p><ol><li>颜色切换（选中黄，未选中白）</li><li>按比例拉伸（两个笑脸同时升高，显示点赞比例的高度）</li><li>展示数据文本（百分比数据显示）</li><li>显示选中部分的笑脸动画（这一步与3文本数据同时进行，在拉伸至最高处停留后）</li><li>缩回至原始大小，保持选中状态</li></ol><p>通过这个流程的分析，我们可以把主要的功能点划分为以下两类：</p><ol><li>动画类 ： 脸部动画，拉伸动画</li><li>控制类： 颜色切换，数据显示，拉伸比例</li></ol><p>在自定义View的过程中，动画特效是最吸引人，也是最复杂的部分,虽然现在有高效炫酷的矢量动画库供我们选择, 但是基础动画的组合也是相当有用的,重点是发挥想象力。</p><p>其中，脸部动画在解压apk后找到相关图片，不出所料是个<strong>帧动画</strong>。</p><p>而主要的难点就在于如何进行拉伸操作。对于将一个圆形从中间拉伸成长条…</p><p>最开始想到的方案是拼接图形，即通过圆形 + 矩形 + 圆形的方式叠加这个控件。通过调节中间矩形的高度，来控制拉伸操作。但是这种方式结构略复杂，需要在一小块地方摆上三个图形，还要带上最外层的笑脸动画，还没写代码就感觉应该是性能低下的方案，另外一个致命的问题就是，不能有描边！大家可以参考饿了么的实现效果，在有描边的情况下，形状拼接的方案明显不可行。遂放弃。</p><p><strong>而最终采用的则是使用圆角矩形作为外层Layout背景，通过控制内部笑脸的marginBottom，来动态的调节Layout的高度。这样，即可以保持笑脸始终处于控件的上部，同时也能控制相对简单的结构。</strong></p><h2 id="拉伸操作的实现"><a href="#拉伸操作的实现" class="headerlink" title="拉伸操作的实现"></a>拉伸操作的实现</h2><p>首先我们先简单的模拟下通过marginBottom控制拉伸的效果。</p><p>在布局里设置一个LinearLayout ，里面只有一个ImageView。用一个seekBar来模拟效果。</p><p>Layout：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">    android:id=&quot;@+id/backGround&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:padding=&quot;10dp&quot;</span><br><span class="line">    android:background=&quot;@drawable/yellow_background&quot;</span><br><span class="line">    android:layout_above=&quot;@+id/seekBar&quot;</span><br><span class="line">    android:layout_centerHorizontal=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/smileFace&quot;</span><br><span class="line">        android:layout_width=&quot;40dp&quot;</span><br><span class="line">        android:layout_height=&quot;40dp&quot;</span><br><span class="line">        android:src=&quot;@drawable/like_1&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><br>这里Linearlayout中设置了一个背景，是自定义的圆角矩形shape，通过调大圆角，使其显示为一个正圆。</p><p>Activity：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onProgressChanged(SeekBar seekBar, int i, boolean b) &#123;</span><br><span class="line">    LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams)smileFace.getLayoutParams();</span><br><span class="line">    layoutParams.bottomMargin = i*3;</span><br><span class="line">    smileFace.setLayoutParams(layoutParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过获取SmileFace的LayoutParams，通过Seekbar设置其下边距bottomMargin，来控制高度。</p><p>效果如下所示：<br><img src="http://dinson-blog.hdinson.cn/FgZ6fl5pzwBX_qwwEYM01AlZHMHE.gif" alt=""><br>这样拉伸的原理就很清楚了。</p><p>我们需要在自定义控件中完成上述操作，并用属性动画替换掉seekBar。</p><h2 id="自定义控件的封装"><a href="#自定义控件的封装" class="headerlink" title="自定义控件的封装"></a>自定义控件的封装</h2><p>考虑到实现目标里有两个并排的笑脸控件，这里采用继承LinearLayout的方式，可以把两个控件及中间的分割线直接摆放进去。</p><p>首先初始化两个脸部动画的ImageView及动画资源，以及两个显示点赞比例的数字及文本的TextView。<br>在初始化的时候设置好相关参数，提取出默认值并提供方法设置相关参数。然后把百分比，文字，包含笑脸的Layout，都添加到另外一个Linearlayout中，然后再将喜欢不喜欢添加到当前自定义控件中。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//初始化图片</span><br><span class="line">imageLike = new ImageView(getContext());</span><br><span class="line">//添加动画资源  获得帧动画</span><br><span class="line">imageLike.setBackgroundResource(R.drawable.animation_like);</span><br><span class="line">animLike = (AnimationDrawable) imageLike.getBackground();</span><br><span class="line">//初始化文字</span><br><span class="line">likeNum = new TextView(getContext());</span><br><span class="line">likeNum.setText(like + &quot;%&quot;);</span><br><span class="line">likeNum.setTextColor(defalutTextColor);</span><br><span class="line">TextPaint likeNumPaint = likeNum.getPaint();</span><br><span class="line">likeNumPaint.setFakeBoldText(true);</span><br><span class="line">likeNum.setTextSize(20f);</span><br><span class="line">likeText = new TextView(getContext());</span><br><span class="line">likeText.setText(defaultLike);</span><br><span class="line">likeText.setTextColor(defalutTextColor);</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">disAll.addView(disNum, params);</span><br><span class="line">disAll.addView(disText, params);</span><br><span class="line">disAll.addView(disBack, params);</span><br><span class="line">likeAll.addView(likeNum, params);</span><br><span class="line">likeAll.addView(likeText, params);</span><br><span class="line">likeAll.addView(likeBack, params);</span><br></pre></td></tr></table></figure><br>这里同时还要注意隐藏文字，以及默认设置为未选中状态。这一段代码虽然挺多，其实也只是在View中做了xml里的事情，了解了整体结构后其实非常简单，实际上直接写好XML再加载也是没问题的。</p><h2 id="整体流程和动画分析"><a href="#整体流程和动画分析" class="headerlink" title="整体流程和动画分析"></a>整体流程和动画分析</h2><p>控件的事件其实只有两个点击事件，需要注意的是动画流程的控制。<br>1.拉伸属性动画 》 2.表情帧动画 》3.与2同时进行的平移动画</p><p>直接在控件设置onClickListener。点击开始执行拉伸动画。并在动画开始后限制点击事件，流程结束后释放。避免重复点击动画错乱。同时给属性动画设置监听，在拉伸执行完毕后，继续执行面部的动画。</p><p>通过属性动画，将喜欢不喜欢的数字比例设置为两个笑脸的bottomMargin，这里由于Max是使用两个数字和，显示的高度会依据数字的大小有差别，也可以设置为一个固定值，完全暗战比例来显示高度，这个可以依据自己的数据源和需求修改。由于在属性动画中同时设置两个高度，所以需要通过判断限制高度，当前magrin与达到数据要求时停止，从而有比例低的一方会停止拉伸。</p><p>拉伸的属性动画，与之对应还有一个缩回的动画，如果有需要还可以加上插值器，优化弹起的效果。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//背景伸展动画</span><br><span class="line">public void animBack() &#123;</span><br><span class="line">    //动画执行中不能点击</span><br><span class="line">    imageDis.setClickable(false);</span><br><span class="line">    imageLike.setClickable(false);</span><br><span class="line"></span><br><span class="line">    final int max = Math.max(like * 4, disLike * 4);</span><br><span class="line">    animatorBack = ValueAnimator.ofInt(5, max);</span><br><span class="line">    animatorBack.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">            int magrin = (int) animation.getAnimatedValue();</span><br><span class="line">            LayoutParams paramsLike</span><br><span class="line">                    = (LayoutParams) imageLike.getLayoutParams();</span><br><span class="line">            paramsLike.bottomMargin = magrin;</span><br><span class="line"></span><br><span class="line">            if (magrin &lt;= like * 4) &#123;</span><br><span class="line">                imageLike.setLayoutParams(paramsLike);</span><br><span class="line">            &#125;</span><br><span class="line">            if (magrin &lt;= disLike * 4) &#123;</span><br><span class="line">                imageDis.setLayoutParams(paramsLike);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    isClose = false;</span><br><span class="line">    animatorBack.addListener(this);</span><br><span class="line">    animatorBack.setDuration(500);</span><br><span class="line">    animatorBack.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>拉伸动画结束后，帧动画与平移动画共同构成了面部的表情动画，通过补间动画的配合使面部表情更加生动。同时也是用补间动画的结束监听来继续执行动画恢复原始状态。下图的animLike为帧动画，objectX，Y为对应轴的平移动画。</p><p>拉伸和恢复动画的结束监听，通过isClose区分.以及平移动画。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">    //重置帧动画</span><br><span class="line">    animDis.stop();</span><br><span class="line">    animLike.stop();</span><br><span class="line"></span><br><span class="line">    //关闭时不执行帧动画</span><br><span class="line">    if (isClose) &#123;</span><br><span class="line">        //收回后可点击</span><br><span class="line">        imageDis.setClickable(true);</span><br><span class="line">        imageLike.setClickable(true);</span><br><span class="line">        //隐藏文字</span><br><span class="line">        setVisibities(GONE);</span><br><span class="line">        //恢复透明</span><br><span class="line">        setBackgroundColor(Color.TRANSPARENT);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    isClose = true;</span><br><span class="line"></span><br><span class="line">    if (type == 0) &#123;</span><br><span class="line">        animLike.start();</span><br><span class="line">        objectY(imageLike);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        animDis.start();</span><br><span class="line">        objectX(imageDis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void objectY(View view) &#123;</span><br><span class="line">    ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;translationY&quot;, -10.0f, 0.0f, 10.0f, 0.0f, -10.0f, 0.0f, 10.0f, 0);</span><br><span class="line">    animator.setRepeatMode(ObjectAnimator.RESTART);</span><br><span class="line">    //animator.setRepeatCount(1);</span><br><span class="line">    animator.setDuration(1500);</span><br><span class="line">    animator.start();</span><br><span class="line">    animator.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">            setBackUp(); //执行回弹动画</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>完整的动画流程实现后，我们的控件就基本完成了。在XML中直接使用，并使用setNum设置数字，基本实现了最美有物的点赞控件效果，简单的撸了一遍。看下最终效果图吧。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smileView = (SmileView) findViewById(R.id.smileView);</span><br><span class="line">smileView.setNum(60,40);</span><br></pre></td></tr></table></figure></p><p><img src="http://dinson-blog.hdinson.cn/FkoIHu-7BrlVaJ3cmG8gvr4gVVjw.gif" alt=""></p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义VIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 项目最新架构</title>
      <link href="/2017/08/08/17-08-08/"/>
      <url>/2017/08/08/17-08-08/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>为了帮助开发着打造一款优秀的APP，Google可谓费尽心力，推出了各种诸如MVP,MVVM等等项目架构的思路，帮助开发者更加高效的开发，尽管这样，Google还是接着推出了一个新的项目架构，以便给予开发者更多的选择，至于这种架构思路和MVP等框架的优劣，各位看完文章或许自有定论。</p></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>在移动操作系统上开发软件其实是十分复杂的一件事情，因为我们随时需要面对系统和用户的各种不可预料的操作，很多时候，事情并不向着我们预设的方向方向进展。因此系统向我们提供了核心组件的生命周期这种东西，告知我们的APP正处在什么样的状况中，以便于我们做出相应的处理。<br><img src="http://dinson-blog.hdinson.cn/FqeWQSGrrbA9qQkCA1nVp87I1aDt.png" alt=""></p><p>如上图。虽然Google给出了Activity非常详尽的生命周期结构，因此我们对根据生命周期做出相应的合理的安排，比如添加和移除实时GPS位置监听：<br><img src="http://dinson-blog.hdinson.cn/FrU-2FFWClcGYo-6zNCfLvReTJql.png" alt=""></p><p>可是随着业务的逐渐复杂，我们可能在添加监听之间需要向服务器验证某些用户信息，等返回信息正确才去监听定位。那么在网络异步回调的时候，我们就很难知道当前的activity的生命周期状态。<br><img src="http://dinson-blog.hdinson.cn/FugnX85uIlVzZ1hUVTcrJFkGZX6p.png" alt=""></p><p>如果发生上图的情况，那么我们的占用的相关资源就可能永远无法移除了。这还只是冰山一角，大家尽可以想想，当我们的异步调用面对无法预知的用户操作和系统处理的时候，什么问题都可能发生。</p><p>总而言之，由于我们对于UI实时的状态做不到了如指掌，以至于对数据和逻辑的处理就无法尽善尽美。这是类似隐患得不到很好的解决根本原因。</p><h2 id="Google大礼包"><a href="#Google大礼包" class="headerlink" title="Google大礼包"></a>Google大礼包</h2><p>这次Google推出了一套新的项目架构组件和架构思路，从UI到Data,帮助我们更加精准的开发自己的APP。</p><h3 id="核心：Lifecycle-Components"><a href="#核心：Lifecycle-Components" class="headerlink" title="核心：Lifecycle Components"></a>核心：Lifecycle Components</h3><p>这套架构最核心的就是生命周期组件，：Lifecycle Components用于管理UI控制器（Activity/Freagment）的生命周期，方便查询当前组件生命周期的状态。</p><p>可查询的状态如下：<br><img src="http://dinson-blog.hdinson.cn/FjG8S412Z4YSwaLDb0DyteFqC2di.png" alt=""></p><p>具体的使用方式有两种：</p><ul><li>继承LifecycleActivity/LifecycleFragment即可</li><li>自己实现LifecycleRegistryOwner接口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过继承，就已经将自己的生命周期的交给了Lifecycle Components管理了。</span><br><span class="line">public class MainActivity extends LifecycleActivity &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们如何使用呢？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 通过继承LifecycleObserver，保证我们可以通过注解或者接口查询UI的生命周期</span><br><span class="line">public class MyTest implements LifecycleObserver &#123;</span><br><span class="line">    private Lifecycle lifecycle;</span><br><span class="line">    // Lifecycle包含了当前组件的生命周期</span><br><span class="line">    public MyTest(Lifecycle lifecycle)&#123;</span><br><span class="line">        lifecycle.addObserver(this);</span><br><span class="line">        this.lifecycle=lifecycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当onResume发生的时候，该方法被调用</span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    public void resume()&#123;</span><br><span class="line">        Log.i(&quot;TAG&quot;,&quot;it called when resume &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doTest(String s)&#123;</span><br><span class="line">        // 随时可以查询当前的UI状态</span><br><span class="line">        if(lifecycle.getCurrentState().equals(Lifecycle.State.RESUMED))&#123;</span><br><span class="line">            Log.i(&quot;TAG&quot;,&quot;resume&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Log.i(&quot;TAG&quot;,&quot;is not resume !! &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MainActivity extends LifecycleActivity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        //将当前Activity的生命周期传递到MyTest中即可</span><br><span class="line">        MyTest myTest=new MyTest(this.getLifecycle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>看到这里，你一定心头一喜，如果有这个组件，那么我们就完全有能力将Activity作为一个UI的控制器，仅仅用来显示UI和相应用户操作，把Activity的大小缩小至最小。不用着急，大礼包远不止这些。</p><h2 id="ViewModel和LiveData"><a href="#ViewModel和LiveData" class="headerlink" title="ViewModel和LiveData"></a>ViewModel和LiveData</h2><ul><li>ViewModel 是一个UI相关数据的暂存器，当所有相关的UI都finish掉的时候，它才会清除自己的数据。</li><li>LiveData则是一个持有具体数据并且可被观察，能感知生命周期的组件（它就像RxJava中一个能遵循组件生命周期的Observable）</li></ul><p>他俩的关系，就是，ViewModel负责管理着不同的LiveData,并把它提供给UI。</p><h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p>我们可以先来说说LiveData。由于它已经能够感知生命周期，也就意味着我们并不需要在去查询当前UI的生命周期，由于可被观察，也就意味着当它持有的数据发生改变，观察者可以立即受到信息。livedata最重要的方法是一下几个：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onActive() // 当前LiveData有超过一个的活跃的观察者时，被调用</span><br><span class="line"></span><br><span class="line">onInactive() // 当前没有任何活跃的观察时，着被调用</span><br><span class="line"></span><br><span class="line">setValue()  // 勇于改变当前数据，这样观察者可以受到改变后的数据。</span><br><span class="line"></span><br><span class="line">// 观察数据变化，并感知当前UI的生命周期</span><br><span class="line">observe(LifecycleOwner owner, Observer&lt;T&gt; observer) </span><br></pre></td></tr></table></figure></p><p>这里有一个活跃的观察者的概念，我们不妨把它放在后面来看。LiveData的用法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class LocationLiveData extends LiveData&lt;Location&gt; &#123;</span><br><span class="line">    private LocationManager locationManager;</span><br><span class="line"></span><br><span class="line">    private SimpleLocationListener listener = new SimpleLocationListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onLocationChanged(Location location) &#123;</span><br><span class="line">            setValue(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public LocationLiveData(Context context) &#123;</span><br><span class="line">        locationManager = (LocationManager) context.getSystemService(</span><br><span class="line">                Context.LOCATION_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onActive() &#123;</span><br><span class="line">        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onInactive() &#123;</span><br><span class="line">        locationManager.removeUpdates(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends LifecycleActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        LiveData&lt;Location&gt; myLocationListener = new LocationLiveData();</span><br><span class="line">        /*</span><br><span class="line">        * observe(LifecycleOwner owner, Observer&lt;T&gt; observer)</span><br><span class="line">        * 这个方法就是向LiveData中添加观察者，</span><br><span class="line">        * LiveData则可以通过LifecycleOwner来判断</span><br><span class="line">        * 当前传入的观察者是否是活跃的（也就是UI是否可见了）</span><br><span class="line">        */</span><br><span class="line">        myLocationListener.observe(this, new Observer&lt;Location&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onChanged(@Nullable Location location) &#123;</span><br><span class="line">                // update</span><br><span class="line">                //当LiveData中通过setValue()修改了数据时，</span><br><span class="line">                //这里将会受到修改后的数据</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，LiveData基本的用法讲完了，由于有了LiveData，我们的data更加“智能”了。当UI不可见的时候，改变的数据将不会被更新到UI上。</p><p>而且如果数据在不同的UI界面都会被用到的时候，我们还可以一个单例的LiveData，为不同的UI提供统一的数据。这些操作就不去细讲了。</p><p>现在回头看LiveData，我们发现它至少有以下几个优点：</p><ul><li>可以避免内存泄露：由于 Observer 和 Lifecycle 绑定，当 Lifecycle 被销毁后，Observer 自动被清理。</li><li>避免在 Activity 被销毁后更新数据导致的崩溃情况</li><li>数据可共享</li><li>数据更新更智能：当数据在UI不可见的时候更新了，在恢复可见的时候，最新的数据会及时更新到UI上。</li><li>不需要在Activity中额外处理生命周期事件</li></ul><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>ViewModel则相对简单些，因为他的作用是暂存UI相关的数据，保证即使Activity配置更改，重新创建时，数据依然能够被保存好。</p><p>基本用法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyViewModel extends ViewModel &#123;</span><br><span class="line">    // MyViewModel用于管理不同的LiveData</span><br><span class="line">    private MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class="line">    public LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class="line">        if (users == null) &#123;</span><br><span class="line">            users = new MutableLiveData&lt;List&lt;Users&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        return users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void loadUsers() &#123;</span><br><span class="line">        // do async operation to fetch users</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyActivity extends AppCompatActivity &#123;</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    // 通过了ViewModelProviders来获取ViewModel</span><br><span class="line">    // 用户获取和Activity绑定的ViewModel</span><br><span class="line">        MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class);</span><br><span class="line">        model.getUsers().observe(this, users -&gt; &#123;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是ViewModel的最基本的用法，它负责从各个地方获取数据，然后把数据装到LiveData中，提供给UI；当然ViewModel也可以在不同的Fragment中共享，在这里就不多讲了。</p><p>由于ViewModel的本身和activity/fragment的生命周期绑定，当与之绑定的最后一个UI 销毁时，ViewModel才会clean自身的数据。</p><p>如图所示<br><img src="http://dinson-blog.hdinson.cn/FmGWdwH3zZ03s7ByTD7hsuuh70nx.png" alt=""></p><h2 id="数据持久化：Room"><a href="#数据持久化：Room" class="headerlink" title="数据持久化：Room"></a>数据持久化：Room</h2><p>Room是Google提供的SQLite的ORM的解决方案，其实本质上和其他的ORM框架没什么特别大的差别，没有太多新意，因此只给出大体的架构图，有兴趣的同学可以自行去学习<br><img src="http://dinson-blog.hdinson.cn/Fnrxp2t0fTM7bcv8_ckSUh5J9PE7.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们现在回头看整个架构<br><img src="http://dinson-blog.hdinson.cn/FrwU3cR0ETMEZFQmQxHeHZsGRojb.png" alt=""></p><p>其实最有有趣的就是UI-ViewModel这个部分，这套架构至少可以帮助我们做到一下几点：</p><ul><li>UI与Data真正分离</li><li>异步调用和逻辑控制可以更加精细（因为对生命周期感知更多）</li><li>实现Model驱动UI</li></ul><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android庶系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android安全防护</title>
      <link href="/2017/08/07/17-08-07/"/>
      <url>/2017/08/07/17-08-07/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Android开发者常常面临的一个问题就是防破解、 防二次打包。现如今,安全问题越来越重要,越来越多 的Android开发者也开始寻求安全的保护方案。首先说一下，我做的是保险行业的应用。所以有很多安全监测的东西要过。其实一般的公司，外包什么的很少管APP的安全的。即使你的应用中集成了微信支付宝的支付。也不需要你自身做什么太多的安全性的东西</p><p>今天我根据绿盟和360监测出来的报告说一下（由于国企，所以是花钱请绿盟和360进行监测的。有大佬要笑了，当然这个检测不是码云上面的检测，后面我也会给新手说一下码云的检测）</p></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="这里先说一下APK加固"><a href="#这里先说一下APK加固" class="headerlink" title="这里先说一下APK加固"></a>这里先说一下APK加固</h2><ul><li>防止二次打包（盗版） </li><li>防止逆向分析 </li><li>防止调试及注入 </li><li>防止应用数据窃取 </li><li>防止木马病毒 </li><li>防篡改（APK篡改工具：APK改之理，AndroidKiller） </li></ul><p>以上的防护都可以用APP加固来实现，这里先说一下最简单的反编译，相信很多人都用过反编译工具。其实我们正常打包出来的apk就是一个压缩包，你解压缩或者反编译基本就拿到了你这个应用的源代码。反编译工具:dex2jar(ApkToolkit) jd-gui 等。我使用的是<br><img src="http://dinson-blog.hdinson.cn/FuwnOg1V9-YOBAfM4PnxT7XUnCbU.png" alt=""></p><p>当你对你的应用进行加固以后，你再尝试着去反编译，我这里以360加固为例，你反编译之后的得到东西如下<br>未加固APK(未混淆):<br><img src="http://dinson-blog.hdinson.cn/FoorAsDylsfjdQ5lIbt9qmd3f_2A.jpg" alt=""></p><p>加固APK:<br><img src="http://dinson-blog.hdinson.cn/FsTQ1q2K-R4b5Ydu8AcvR1vaAz41.jpg" alt=""></p><p>这里大家百度肯定能看到一些什么360脱壳圣战啊什么的文章介绍，基本上是不可能实现的。不相信的朋友可以按照那些文章去试试。这里介绍一下国内的几个加固商。<br><img src="http://dinson-blog.hdinson.cn/Fid1lDGmdJh7IsSpS1zNihJSSpW3.png" alt=""></p><p>当然还有其他的加固厂商，比如百度、腾讯、阿里、通付盾、网易易盾。这里大家喜欢用哪个就用哪个。腾讯和阿里虽然是IT巨头，但是毕竟有些厂商是专业做这个的。这里我就不做推荐了，有些加固自带崩溃日志，数据分析等等。使用加固后可对以上进行有效的防护。</p><p><code>加固APK之后：篡改后无法正常运行、无法正常动态调试、反动态注入无法注入、反编译无法获取到原dex代码或完整的dex代码、So文件的整体加密，使用自定义链接器的技术,对SO文件进行整体的加密,完全阻止 IDA等逆向工具的静态分析。</code></p><h2 id="安全检测的项目"><a href="#安全检测的项目" class="headerlink" title="安全检测的项目"></a>安全检测的项目</h2><h3 id="客户端安全测试包含"><a href="#客户端安全测试包含" class="headerlink" title="客户端安全测试包含"></a>客户端安全测试包含</h3><ul><li><p>客户端程序保护<br>– 描述：判断是否能反编译为源代码，是否存在代码保护措施<br>– 测试：是否能通过用反编译工具查看源代码<br>– 建议：建议客户端进行加壳处理防止攻击者反编译客户端，同时混淆客户端代码，并且一定要对核心代码进行代码混淆。</p></li><li><p>安装包签名<br>– 描述：客户端安装包是否正确签名。通过签名，可以检测出安装包在签名后是否被修改过。<br>– 检测：利用二次打包工具能否成功打包运行<br>– 建议：客户端使用从属方证书进行签名后进行发布而不是使用第三方开发商的证书进行签名，以防开发商内部监管异常，证书滥用的情况出现。</p></li><li><p>应用完整性校验<br>– 描述：测试客户端程序安装后，在每次启动时是否对自身文件进行完整性校验。<br>– 检测：修改资源文件，二次打包能否运行<br>– 建议：建议客户端在每次开机启动时进行客户端自身的应用完整性校验，在验证逻辑中不使用MANIFEST.MF中的数据作为验证凭证，同时需验证是否有不属于该客户端版本的新文件添加，验证过程于服务器端完成。</p></li><li><p>组件安全<br>– 描述：测试客户端是否包含后台服务、Content Provider、第三方调用和广播等组件，Intent权限的设置是否安全。应用不同组成部分之间的机密数据传递是否安全。程序是否窃取手机用户的隐私信息。<br>– 建议：建议在开发客户端时不要暴露内部组件，如果有特殊需求也需进行权限控制，令使用这些组件时需要申请相应权限。</p></li><li><p>整体解决：以上客户端程序保护可通过代码混淆配合apk加固全部解决</p></li></ul><h3 id="敏感信息安全包含"><a href="#敏感信息安全包含" class="headerlink" title="敏感信息安全包含"></a>敏感信息安全包含</h3><ul><li><p>私有目录下的文件权限<br>– 描述：测试客户端私有目录下的文件权限是否设置正确，非root账户是否可以读，写，执行私有目录下的文件。<br>– 检测：<br><img src="http://dinson-blog.hdinson.cn/Fv_jpLqsxJP9o3IcOV4q07lPBGN6.png" alt=""><br>– 建议：私有目录下文件不可读写</p></li><li><p>SQLite数据库文件的安全性<br>– 描述：敏感信息是否明文存储<br>– 检测：检测数据库里面的重要信息，比如账号密码之类的是否明文存储<br>– 建议：重要信息进行加密存储</p></li><li><p>Logcat日志<br>– 描述：检测客户端对应的Logcat日志是否会打印一些用户或服务器的敏感信息。<br>– 检测：用ddms工具寻找敏感信息输出<br>– 建议：具有敏感信息的调试信息开关一定要关闭。</p></li><li><p>整体解决：对于安卓开发来讲，我们解决敏感信息问题就是对重要数据进行加密存储，log日志不打印敏感信息。我是真的见过账号密码保存在本地明文存储的，所以切记加密存储重要信息</p></li></ul><h3 id="密码软键盘"><a href="#密码软键盘" class="headerlink" title="密码软键盘"></a>密码软键盘</h3><ul><li><p>键盘劫持测试<br>– 描述：测试客户端程序在密码等输入框是否使用自定义软键盘。安卓应用中的输入框默认使用系统软键盘，手机安装木马后，木马可以通过替换系统软键盘，记录应用的密码。<br>– 检测：这个应该通过看就能看出来<br>– 建议：建议客户端开发自定义软键盘而不是使用系统软件盘以防止键盘劫持攻击。</p></li><li><p>软键盘安全性测试<br>– 描述：测试客户端是否使用随机布局的密码软键盘。<br>– 检测：还是眼睛看<br>– 建议：建议客户端对自定义软键盘进行随机化处理，同时在每次点击输入框时都进行随机初始化。</p></li><li><p>屏幕录像测试<br>– 描述：测试通过连续截图，是否可以捕捉到用户密码输入框的密码。<br>– 检测：通过连续截图，是否可以捕捉到用户密码输入框的密码。<br>– 建议：建议客户端针对第三方或系统截屏编写抵抗逻辑，例如屏蔽和截屏相关的函数或是当客户端处于进程栈顶层时将截屏图片用纯黑色图片对象进行覆盖。</p></li><li><p>整体解决：键盘劫持一般都是要自定义键盘的，而且自定义的键盘不要长的和系统键盘一样就行，每次点击输入框时都进行随机初始化倒是没必要。因为很多银行的也没有这样做，而且做起来我认为困难还是有的。以手机银行例,大多数银行采用自绘键盘代替系统键盘,防止了系统键盘监听行为,但有些开发者忽略了截屏保护，这样连续快速截屏，或者视频录制就可以获取用户的密码。下面代码是防截屏、视频录制的代码 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE);// 防止屏幕截屏</span><br></pre></td></tr></table></figure></li></ul><h3 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h3><ul><li><p>密码复杂度<br>– 描述：测试客户端程序是否检查用户输入的密码，禁止用户设置弱口令<br>– 测试：修改设置用户名密码时，可以设置111111类似弱口令<br>– 建议：建议在服务器编写检测密码复杂度的安全策略，并将其运用到账号注册，密码修改等需要进行密码变更的场景，以防止攻击者通过弱密钥遍历账户的方式进行暴力猜解。</p></li><li><p>账户锁定策略<br>– 描述：测试客户端是否限制登录尝试次数。防止木马使用穷举法暴力破解用户密码<br>– 测试：错误密码登录请求多次（10次以上还没有就有问题了，一般都是3次）<br>– 建议：建议在服务端编写账户锁定策略的逻辑，当一天内多次输入密码错误时进行账号锁定以防止攻击者通过暴力猜解密码。</p></li><li><p>会话安全设置<br>– 描述：测试客户端在一定时间内无操作后，是否会使会话超时并要求重新登录。超时时间设置是否合理。<br>– 检测：客户端在一定时间内无操作（20分钟足够），是否会话超时登录<br>– 建议： 建议在客户端编写会话安全设置的逻辑，当10分钟或20分钟无操作时自动退出登录状态或是关闭客户端。</p></li><li><p>界面切换保护<br>– 描述：检查客户端程序在切换到后台或其他应用时，是否能恰当响应（如清除表单或退出会话），防止用户敏感信息泄露<br>– 检测：应用切换到后台但程序没有结束运行，再返回应用的时候是否有身份验证 ，手势密码或者登陆密码。<br>– 建议：建议客户端添加响应的逻辑，在进行进程切换操作时提示用户确认是否为本人操作。</p></li><li><p>界面劫持保护<br>– 描述：检查客户端是否对非正常的界面切换进行检测，并对用户进行提示。<br>– 检测：界面被劫持时是否有提示<br>– 建议： 由于Activity界面劫持攻击通常是将自己的页面附着在客户端之上，因此需要进行界面切换操作，因此使用界面切换保护的安全建议可以达到一定的效果。除此之外，因为Android进程栈的工作原理，建议开发客户端时针对进程栈进行相应的保护，可禁止其他进程放置于客户端之上。</p></li><li><p>UI信息泄露<br>– 描述：检查客户端的各种功能，看是否存在敏感信息泄露问题。<br>– 检测：比如登录时，密码输入错误，APP是否会提示密码输入错误<br>– 建议：建议用户名或密码输入错误均提示“用户名或密码错误”，若客户端同时还希望保证客户使用的友好性，可以在登陆界面通过温馨提示的方式提示输入错误次数，密码安全策略等信息，以防用户多次输入密码错误导致账号锁定。</p></li><li><p>账号登录限制<br>– 描述：测试能否在两个设备上同时登录同一个帐号。<br>– 检测：测试能否在两个设备上同时登录同一个帐号。<br>– 建议：建议在服务器进行账号登陆限制相应逻辑代码的编写，通过Session或数据库标志位的方式控制同一时间只有一个设备可以登陆某一账号。</p></li><li><p>安全退出<br>– 描述：验证客户端在用户退出登录状态时是否会和服务器进行通信以保证退出的及时性<br>– 检测：客户端在用户退出登录时，查看session是否可用<br>建议：保证客户端和服务器同步退出，APP退出时服务器端的清除会话</p></li><li><p>密码修改验证<br>– 描述：验证客户端在进行密码修改时的安全性<br>– 检测：是否存在原密码验证<br>– 建议：建议在修改密码时，客户端及服务器系统增添原密码输入验证身份的逻辑，以防Cookie登陆修改密码的攻击。</p></li><li><p>私密问题验证<br>– 描述：验证客户端是否存在忘记密码时的私密问题验证<br>– 检测：类似于QQ的私密问题验证<br>– 建议：我觉得这个根据需求走，也不一定说这个就好。一个普通的APP这样搞，用户体验会很差。除非你做到了QQ那种地步</p></li><li><p>整体解决：无，一个一个搞吧，需要和后台配合着。这里只说一下界面劫持 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onPause() &#123;</span><br><span class="line">    // 若程序进入后台不是用户自身造成的，则需要弹出警示 </span><br><span class="line">    if (needAlarm) &#123;</span><br><span class="line">    // 弹出警示信息 </span><br><span class="line">        Toast.makeText(getApplicationContext(),</span><br><span class="line">            &quot;XX的登陆界面被覆盖，请确认登陆环境是否安全&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">    super.onPause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是在登录界面重写onPause方法。这个界面劫持只需要在登录界面做防护。needAlarm是定义的变量，初始化为true，然后监听home键和返回键以及你自身登录界面的其他activity的跳转。如果用户执行了监听的操作needAlarm赋值为false，说明是用户自身的操作，不是界面劫持。</p></li></ul><h3 id="手势密码"><a href="#手势密码" class="headerlink" title="手势密码"></a>手势密码</h3><ul><li><p>手势密码复杂度<br>– 描述：测试客户端手势密码复杂度，观察是否有点位数量判断逻辑<br>– 检测：这个应该没有明确的，就是自身感受吧<br>– 建议：自己定标准吧</p></li><li><p>手势密码修改和取消<br>– 描述：检测客户端在取消手势密码时是否会验证之前设置的手势密码，检测是否存在其他导致手势密码取消的逻辑问题<br>– 检测：检测客户端在取消手势密码时是否会验证之前设置的手势密码，检测是否存在其他导致手势密码取消的逻辑问题<br>– 建议：不应该存在其他导致手势密码取消的逻辑，客户端在取消手势密码时应验证之前设置的手势密码</p></li><li><p>手势密码本地信息保存<br>– 描述：检测在输入手势密码以后客户端是否会在本地记录一些相关信息，例如明文或加密过的手势密码。<br>– 检测：找到存储文件，看其是否加密<br>– 建议：应该进行加密</p></li><li><p>手势密码锁定策略<br>– 描述：测试客户端是否存在手势密码多次输入错误被锁定的安全策略。防止木马使用穷举法暴力破解用户密码。因为手势密码的存储容量非常小，一共只有9！=362880种不同手势，若手势密码不存在锁定策略，木马可以轻易跑出手势密码结果。手势密码在输入时通常以a[2][2]这种3*3的二维数组方式保存，在进行客户端同服务器的数据交互时通常将此二维数组中数字转化为类似手机数字键盘的b[8]这种一维形式，之后进行一系列的处理进行发送。</p></li><li><p>手势密码抗攻击测试<br>– 描述：验证是否可以通过插件绕过手势密码的验证页面</p></li><li><p>整体解决：手势密码的后面两个检测我也没有遇到过。而且现在手势密码怎么说，可能我接触的不是很多吧。有兴趣的朋友可以找相关资料研究下</p></li></ul><h3 id="通信安全"><a href="#通信安全" class="headerlink" title="通信安全"></a>通信安全</h3><ul><li><p>通信加密<br>– 描述：验证客户端和服务器之前的通信是否使用加密信道。<br>– 检测：可以利用抓包软件进行查看<br>– 建议：使用https或者是http+403端口进行通信。</p></li><li><p>关键数据加密和校验<br>– 描述：测试客户端程序提交数据给服务端时，密码等关键字段是否进行了加密和校验，防止恶意用户嗅探和修改用户数据包中的密码等敏感信息。<br>– 检测：抓包<br>– 建议：建议账号，密码，卡号，金额等进行加密处理，同时整个数据包进行二次加密，返回的敏感信息进行加密，同时返回数据包进行二次加密，并且使用增加随机因子的校验字段，并且确定服务器逻辑标志位正确，在删除校验字段时服务器不响应提交的数据包。</p></li><li><p>证书有效性验证<br>– 描述：验证客户端和服务器之间是否存在双向验证的机制，同时确认此机制是否完善，服务器是否以白名单的方式对发包者的身份进行验证<br>– 检测：抓包<br>– 建议：建议客户端和服务器进行双向认证，并且服务器通过白名单的方式验证客户端证书以保证证书的有效性。</p></li><li><p>访问控制<br>– 描述：测试客户端访问的URL是否仅能由手机客户端访问。是否可以绕过登录限制直接访问登录后才能访问的页面，对需要二次验证的页面（如私密问题验证），能否绕过验证。<br>– 检测：利用截包工具获取url，能用浏览器打开该url。<br>– 建议：建议服务器进行相应的访问控制，控制对应页面仅能通过手机客户端访问。同时进行页面访问控制，防止绕过登陆直接访问页面的非法访问。</p></li><li><p>短信重放攻击<br>– 描述：检测应用中是否存在数据包重放攻击的安全问题。是否会对客户端用户造成短信轰炸的困扰。<br>– 建议：抓包<br>– 建议：token和手机号一起，重放无法造成短信轰炸</p></li></ul><h3 id="业务安全"><a href="#业务安全" class="headerlink" title="业务安全"></a>业务安全</h3><p>这个需要根据业务进行检测</p><h3 id="模拟器安全"><a href="#模拟器安全" class="headerlink" title="模拟器安全"></a>模拟器安全</h3><p>这里我多介绍一个，一般黑客进行攻击肯定不会是用手机进行，多用模拟器进行攻击。现在的模拟器基本和手机一样。我们无法过滤所有的模拟器，但是可以过滤免费的模拟器，也就是一定程度上进行防护</p><ul><li>实践大多数免费的模拟器，都没有蓝牙的功能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BluetoothAdapter blueadapter = BluetoothAdapter.getDefaultAdapter();</span><br><span class="line">if ((blueadapter == null)</span><br><span class="line">    || (blueadapter.getAddress() == null &amp;&amp; blueadapter.getName() == null)) &#123;</span><br><span class="line">    MessageBox.promptDialog(&quot;请使用真实手机登陆&quot;, LoginActivity.this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然else之后我是登录操作，但是登录前做了一些东西。这个就像消息推送一样，手机的唯一标识cid之类的绑定。这里只是给出个思路</p><h3 id="短信验证"><a href="#短信验证" class="headerlink" title="短信验证"></a>短信验证</h3><p>最好是做60秒倒计时。</p><h3 id="App测试安全等级划分"><a href="#App测试安全等级划分" class="headerlink" title="App测试安全等级划分"></a>App测试安全等级划分</h3><p><img src="http://dinson-blog.hdinson.cn/FsYFepMvGGPtLJ-Wee0LoeLvxR5k.png" alt=""></p><h3 id="工具及相关资源"><a href="#工具及相关资源" class="headerlink" title="工具及相关资源"></a>工具及相关资源</h3><ul><li><p>Apktool:  GOOGLE提供的APK编译工具，能够反编译及回编译apk。<br><a href="https://code.google.com/p/android-apktool/">https://code.google.com/p/android-apktool/</a></p></li><li><p>Dex2jar:  将Android的dex文件反编译为java源码。<br><a href="https://code.google.com/p/dex2jar/w/list">https://code.google.com/p/dex2jar/w/list</a></p></li><li><p>Jd-gui:  反编译代码阅读工具。<br><a href="http://jd.benow.ca/">http://jd.benow.ca/</a></p></li><li><p>Portecle:  证书管理工具，可以进行证书维护。<br><a href="http://www.oschina.net/p/portecle">http://www.oschina.net/p/portecle</a></p></li><li><p>SuperOneClick:  Android手机root工具<br><a href="http://www.superoneclick.cc/">http://www.superoneclick.cc/</a></p></li><li><p>Proxydroid:  Android手机用代理软件。<br><a href="https://github.com/madeye/proxydroid">https://github.com/madeye/proxydroid</a></p></li><li><p>MemSpector:  Android手机内存修改工具<br><a href="http://www.nosec.org">http://www.nosec.org</a></p></li><li><p>BurpSuite:  HTTP数据包修改、转发工具<br><a href="http://portswigger.net/burp/">http://portswigger.net/burp/</a></p></li><li><p>Fiddler:  HTTP数据包修改、转发工具<br><a href="http://www.fiddler2.com/fiddler2/">http://www.fiddler2.com/fiddler2/</a></p></li><li><p>Xposed框架:  系统级框架，用于开发底层插件进行测试<br><a href="http://repo.xposed.info/module/de.robv.android.xposed.installer">http://repo.xposed.info/module/de.robv.android.xposed.installer</a></p></li><li><p>SwipeBack:  Xposed插件，用于绕过登陆界面<br><a href="http://repo.xposed.info/module/us.shandian.mod.swipeback">http://repo.xposed.info/module/us.shandian.mod.swipeback</a></p></li><li><p>Android Development Tools:  支持Android开发的工具<br><a href="http://developer.android.com/tools/help/adt.html">http://developer.android.com/tools/help/adt.html</a></p></li></ul><h2 id="代码检测"><a href="#代码检测" class="headerlink" title="代码检测"></a>代码检测</h2><ul><li>eclipse 使用插件findbugs</li><li>studio 使用lint</li><li>至于码云，是你把代码上传上去，码云会为你检测你的代码。</li></ul><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><ul><li><p>加密分为对称加密和非对称加密</p></li><li><p>区分对称加密和非对称加密。对称加密的加密密钥和解密密钥是相同的。非对称加密的加密密钥和解密密钥不同<br>对称加密<br>– 特点：高效，存在密钥交换问题，安全度不如RSA，但是能胜任大部分加密<br>– 明文P 加密方法E 密文E(P) 解密方法D 加密密钥K 解密密钥K’<br>DK’(EK(P)) = P K = K’<br>EK(P)：这是加密</p></li><li><p>对称加密是基于乘积加密的（乘积加密是结合了置换算法和转置算法，有兴趣可以了解一下）。而AES和DES都是基于乘积加密。AES加密比DES要高。但是现在也有3DES加密。</p></li><li><p>非对称加密<br>– 特点：安全性高，没有密钥交换问题，效率低<br>– 明文P 加密方法E 密文E(P) 解密方法D 加密密钥K 解密密钥K’<br>DK’(EK(P)) = P K ！= K’（公钥和私钥不一样，但是同时产生）</p></li></ul><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android庶系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android进程保活</title>
      <link href="/2017/07/11/17-07-11/"/>
      <url>/2017/07/11/17-07-11/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>所谓保活即进程在后台一直运行不被杀死。统计一下目前的保活手段：</p><ul><li>监听系统广播，如开机、充电状态、网络变化、安装卸载app、锁屏解锁、集成的推送消息等等，亲测无效，在进程被杀了之后也无法再监听到系统广播，也就不存在拉起，只能作为辅助手段，稍后会提起。</li><li>实现一个隐藏的前台服务，这个网上很多实现方法，也是我最开始使用的手段。实际上是把进程的优先级给提高了一级，锁屏时间长了还是会被杀死。</li><li>使用Linux命令启动一个新进程进行相互保护。才疏学浅，并不太理解原理，不敢多说，详情看这篇博客。亲测无效，不敢说是大神写的不对，可能是我姿势不对。</li><li>使用子进程进行相互保护，简而言之就是建两个service,一个是子进程： <strong>android:process=”:remote”</strong><br>亲测无效，这个一点点用都没有，因为进程被杀了之后子进程也同时被杀。</li><li>谣传QQ曾经让自己不被杀死，曾使用过后台显示一个全透明的、只有1x1像素大小的窗口，这个很匪夷所思，像IOS5之后的后台无限播放无声音乐一样狗血。 </li></ul><p>以上所有出现的”被杀死”字样全部指的是进程后台状态自动被杀死，而不是指用户手用杀死，类似iphone连按两次HOME键上划杀死后台进程，这个只有一种办法保证不被杀死，就是把你应用加入到系统杀死进程的白名单。所谓跟手机厂商合作加入白名单就是指这个。这里不得不说一个很有意思的app：<code>日程管理时间管理</code>。</p><p>简单说上它就是引导用户手动设置了“厂商把你的app加入白名单”这个操作，这个也被我学了过去，连带着页面一起。这只是第一步。<br>接下来如我上面所说，除了4被遗弃之外，把所有的手段都用上了，一开始并没有用5，因为我感觉已经够了。但是依然无法阻止在锁屏+后台的情况下被杀。于是我用上了最后一种手段。</p><p>最后一步，我参考了360，在双击返回键后并没有<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process.killProcess(Process.myPid());</span><br></pre></td></tr></table></figure><br>和<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.exit(0);</span><br></pre></td></tr></table></figure><br>而是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(Intent.ACTION_MAIN);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">getAppContext().startActivity(intent);</span><br></pre></td></tr></table></figure><br>并且在清单文件中加入了<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:excludeFromRecents=&quot;true&quot;</span><br></pre></td></tr></table></figure><br>作用是不在最近使用的列表中出现，也就是连按两次HOME键就不会出现我的app了。</p><h2 id="1像素页面保活"><a href="#1像素页面保活" class="headerlink" title="1像素页面保活"></a>1像素页面保活</h2><ol><li>新建一个Activity，作为1像素页面的主体，我姑且叫它HooliganActivity:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class HooliganActivity extends Activity &#123;</span><br><span class="line">    private static HooliganActivity instance;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        instance = this;</span><br><span class="line">        Window window = getWindow();</span><br><span class="line">        window.setGravity(Gravity.LEFT | Gravity.TOP);</span><br><span class="line">        WindowManager.LayoutParams params = window.getAttributes();</span><br><span class="line">        params.x = 0;</span><br><span class="line">        params.y = 0;</span><br><span class="line">        params.height = 1;</span><br><span class="line">        params.width = 1;</span><br><span class="line">        window.setAttributes(params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开启保活页面</span><br><span class="line">     */</span><br><span class="line">    public static void startHooligan() &#123;</span><br><span class="line">        Intent intent = new Intent(DWApplication.getAppContext(), HooliganActivity.class);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        DWApplication.getAppContext().startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        instance = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关闭保活页面</span><br><span class="line">     */</span><br><span class="line">    public static void killHooligan() &#123;</span><br><span class="line">        if(instance != null) &#123;</span><br><span class="line">            instance.finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>注册清单文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.activity.HooliganActivity&quot;</span><br><span class="line">        android:configChanges=&quot;keyboardHidden|orientation|screenSize|navigation|keyboard&quot;</span><br><span class="line">        android:excludeFromRecents=&quot;true&quot;</span><br><span class="line">        android:exported=&quot;false&quot;</span><br><span class="line">        android:finishOnTaskLaunch=&quot;false&quot;</span><br><span class="line">        android:launchMode=&quot;singleInstance&quot;</span><br><span class="line">        android:theme=&quot;@style/HooliganActivityStyle&quot;/&gt; </span><br><span class="line"></span><br><span class="line">&lt;style name=&quot;HooliganActivityStyle&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/transparent&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowNoDisplay&quot;&gt;false&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowDisablePreview&quot;&gt;true&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li>监听锁屏和解锁通知，不能静态注册广播，只能动态注册<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = new IntentFilter();</span><br><span class="line">filter.addAction(Intent.ACTION_SCREEN_ON);</span><br><span class="line">filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">registerReceiver(new BootCompleteReceiver(),filter);</span><br></pre></td></tr></table></figure></li><li>分别在解锁和锁屏时唤醒我的HooliganActivity<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class BootCompleteReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        if(intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) &#123;</span><br><span class="line">            HooliganActivity. startHooligan();</span><br><span class="line">        &#125; else if(intent.getAction().equals(Intent.ACTION_SCREEN_ON))&#123;</span><br><span class="line">            HooliganActivity. killHooligan();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这样你在后台每次锁屏，实际上都会吊起一个一像素的页面，假装app在前台，拥有最高进程优先级。</p><p><code>不推荐使用，太流氓了- -！。</code></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote><p>技术无罪。——王欣</p></blockquote><p>但人有罪。</p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在百度地图上绘制运动轨迹图及相关事件处理</title>
      <link href="/2017/07/10/17-07-03/"/>
      <url>/2017/07/10/17-07-03/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>上篇文章讲述了如何在地图显示位置点，这篇文章主要讲述如何在地图上画运动轨迹，以及地图图层点击事件的处理。</p></blockquote><p>本篇将要实现的效果</p><ol><li>跑步结束后，静态的画出整个运动轨迹</li><li>跑步过程中，时时动态的画运动轨迹<br>很多运动类的app都有画出跑步者运动轨迹的需求，拿咕咚来说，我们看一下它的效果图： </li></ol><span id="more"></span><!-- 这是　　缩进--><p>如何实现：</p><ol><li>将点与点连成线，在百度地图MapView上画出线条图层；</li><li>获取定位点List<LatLng>：通过百度定位sdk：LocationClient类获取，户外运动画运动轨迹，要求位置点的精度高，所以我们必须使用gps定位类型的位置结果。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//允许使用gps定位</span><br><span class="line">mOption.setOpenGps(true);</span><br></pre></td></tr></table></figure><h2 id="静态画整个运动轨迹"><a href="#静态画整个运动轨迹" class="headerlink" title="静态画整个运动轨迹"></a>静态画整个运动轨迹</h2><h3 id="画轨迹"><a href="#画轨迹" class="headerlink" title="画轨迹"></a>画轨迹</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//伪代码</span><br><span class="line">public void onCreate()&#123;</span><br><span class="line">  // 地图初始化</span><br><span class="line">  MapView mMapView = (MapView) findViewById(R.id.bmapView);</span><br><span class="line">  BaiduMap mBaiduMap = mMapView.getMap();</span><br><span class="line">  // 开启定位图层</span><br><span class="line">  mBaiduMap.setMyLocationEnabled(true);</span><br><span class="line"></span><br><span class="line">  //获取运动后的定位点</span><br><span class="line">  coordinateConvert();</span><br><span class="line"></span><br><span class="line">  //设置缩放中点LatLng target，和缩放比例          </span><br><span class="line">  MapStatus.Builder builder = new MapStatus.Builder();</span><br><span class="line">  builder.target(target).zoom(18f);</span><br><span class="line"></span><br><span class="line">  //地图设置缩放状态</span><br><span class="line">  mBaiduMap.animateMapStatus(MapStatusUpdateFactory.newMapStatus(builder.build()));</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * 配置线段图层参数类： PolylineOptions</span><br><span class="line">  * ooPolyline.width(13)：线宽</span><br><span class="line">  * ooPolyline.color(0xAAFF0000)：线条颜色红色</span><br><span class="line">  * ooPolyline.points(latLngs)：List&lt;LatLng&gt; latLngs位置点，将相邻点与点连成线就成了轨迹了</span><br><span class="line">  */</span><br><span class="line">  OverlayOptions ooPolyline = new PolylineOptions().width(13).color(0xAAFF0000).points(latLngs);</span><br><span class="line"></span><br><span class="line">  //在地图上画出线条图层，mPolyline：线条图层</span><br><span class="line">  mPolyline = (Polyline) mBaiduMap.addOverlay(ooPolyline);</span><br><span class="line">  mPolyline.setZIndex(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 我这里是在google地图取下来的wgs84坐标集合Const.googleWGS84，模拟的运动后获取的坐标集合，</span><br><span class="line">   所以需要转化成百度坐标；实际应该是将定位sdk返回的位置点加入到位置集合中，</span><br><span class="line">   定位sdk需要设置返回坐标为百度坐标：mOption.setCoorType(&quot;bd09ll&quot;)，这样就直接用，不用转换了。</span><br><span class="line"> */</span><br><span class="line">private void  coordinateConvert()&#123;</span><br><span class="line">  //百度坐标转化工具类CoordinateConverter </span><br><span class="line">  CoordinateConverter converter  = new CoordinateConverter(); </span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * 设置需要转化的坐标类型</span><br><span class="line">    CoordType.COMMON：google地图、腾讯地图、高德地图所用坐标</span><br><span class="line">    CoordType.GPS：设备采集的原始GPS坐标</span><br><span class="line">  */</span><br><span class="line">  converter.from(CoordType.COMMON);</span><br><span class="line"></span><br><span class="line">  double lanSum = 0;</span><br><span class="line">  double lonSum = 0;</span><br><span class="line">  for (int i = 0; i &lt; Const.googleWGS84.length; i++) &#123;</span><br><span class="line">    //&quot;39.881970,116.456218&quot;</span><br><span class="line">    String[] ll = Const.googleWGS84[i].split(&quot;,&quot;);</span><br><span class="line">    LatLng sourceLatLng = new LatLng(Double.valueOf(ll[0]), Double.valueOf(ll[1]));</span><br><span class="line">    converter.coord(sourceLatLng);  //需要转化的坐标点</span><br><span class="line">    LatLng desLatLng = converter.convert();  //转化成百度坐标点</span><br><span class="line">    latLngs.add(desLatLng);//加入定位点集合</span><br><span class="line">    lanSum += desLatLng.latitude;</span><br><span class="line">    lonSum += desLatLng.longitude;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //我这里设置地图的缩放中心点为所有点的几何中心点</span><br><span class="line">  target = new LatLng(lanSum/latLngs.size(), lonSum/latLngs.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加起始图标图层、点击图层响应事件"><a href="#添加起始图标图层、点击图层响应事件" class="headerlink" title="添加起始图标图层、点击图层响应事件"></a>添加起始图标图层、点击图层响应事件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//始点图层图标</span><br><span class="line">BitmapDescriptor startBD= BitmapDescriptorFactory</span><br><span class="line">            .fromResource(R.drawable.ic_me_history_startpoint);</span><br><span class="line">//终点图层图标</span><br><span class="line">BitmapDescriptor finishBD= BitmapDescriptorFactory</span><br><span class="line">            .fromResource(R.drawable.ic_me_history_finishpoint);</span><br><span class="line"></span><br><span class="line">//地图中显示信息窗口</span><br><span class="line">InfoWindow mInfoWindow;</span><br><span class="line"></span><br><span class="line">MarkerOptions oStart = new MarkerOptions();//地图标记类型的图层参数配置类 </span><br><span class="line">oStart.position(latLngs.get(0));//图层位置点，第一个点为起点</span><br><span class="line">oStart.icon(startBD);//设置图层图片</span><br><span class="line">oStart.zIndex(1);//设置图层Index</span><br><span class="line">//添加起点图层</span><br><span class="line">Marker mMarkerA = (Marker) (mBaiduMap.addOverlay(oStart)); </span><br><span class="line"></span><br><span class="line">//添加终点图层</span><br><span class="line">MarkerOptions oFinish = new MarkerOptions().position(latLngs.get(latLngs.size()-1)).icon(finishBD).zIndex(2);</span><br><span class="line">Marker mMarkerB = (Marker) (mBaiduMap.addOverlay(oFinish));</span><br><span class="line"></span><br><span class="line">//设置图层点击监听回调</span><br><span class="line">mBaiduMap.setOnMarkerClickListener(new OnMarkerClickListener() &#123;</span><br><span class="line">  public boolean onMarkerClick(final Marker marker) &#123;</span><br><span class="line">    if (marker.getZIndex() == mMarkerA.getZIndex() ) &#123;//如果是起始点图层</span><br><span class="line">      TextView textView = new TextView(getApplicationContext());</span><br><span class="line">      textView.setText(&quot;起点&quot;);</span><br><span class="line">      textView.setTextColor(Color.BLACK);</span><br><span class="line">      textView.setGravity(Gravity.CENTER);</span><br><span class="line">      textView.setBackgroundResource(R.drawable.popup);</span><br><span class="line"></span><br><span class="line">      //设置信息窗口点击回调</span><br><span class="line">      OnInfoWindowClickListener listener = new OnInfoWindowClickListener() &#123;</span><br><span class="line">        public void onInfoWindowClick() &#123;</span><br><span class="line">          //这里是主线线程，可以实现自己的一些功能</span><br><span class="line">          Toast.makeText(getApplicationContext(),&quot;这里是起点&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">          mBaiduMap.hideInfoWindow();//隐藏信息窗口</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      LatLng latLng = marker.getPosition();//信息窗口显示的位置点</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">      * 通过传入的 bitmap descriptor 构造一个 InfoWindow</span><br><span class="line">      * bd - 展示的bitmap</span><br><span class="line">        position - InfoWindow显示的位置点</span><br><span class="line">        yOffset - 信息窗口会与图层图标重叠，设置Y轴偏移量可以解决</span><br><span class="line">        listener - 点击监听者</span><br><span class="line">      */</span><br><span class="line">      mInfoWindow = new InfoWindow(BitmapDescriptorFactory.fromView(textView), latLng, -47, listener);</span><br><span class="line">      mBaiduMap.showInfoWindow(mInfoWindow);//显示信息窗口</span><br><span class="line">    &#125; else if (marker.getZIndex() == mMarkerB.getZIndex()) &#123;//如果是终点图层</span><br><span class="line">      Button button = new Button(getApplicationContext());</span><br><span class="line">      button.setText(&quot;终点&quot;);</span><br><span class="line">      button.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">        public void onClick(View v) &#123;</span><br><span class="line">          Toast.makeText(getApplicationContext(),&quot;这里是终点&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">          mBaiduMap.hideInfoWindow();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      LatLng latLng = marker.getPosition();</span><br><span class="line">      /**</span><br><span class="line">      * 通过传入的 view 构造一个 InfoWindow, 此时只是利用该view生成一个Bitmap绘制在地图中，监听事件由自己实现。</span><br><span class="line">        view - 展示的 view</span><br><span class="line">        position - 显示的地理位置</span><br><span class="line">        yOffset - Y轴偏移量</span><br><span class="line">      */</span><br><span class="line">      mInfoWindow = new InfoWindow(button, latLng, -47);</span><br><span class="line">      mBaiduMap.showInfoWindow(mInfoWindow);</span><br><span class="line">    &#125; </span><br><span class="line">    return true;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//也可以给运动轨迹添加点击事件</span><br><span class="line">mBaiduMap.setOnPolylineClickListener(new BaiduMap.OnPolylineClickListener() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean onPolylineClick(Polyline polyline) &#123;</span><br><span class="line">    if (polyline.getZIndex() == mPolyline.getZIndex()) &#123;</span><br><span class="line">      Toast.makeText(getApplicationContext(),&quot;点数：&quot; + polyline.getPoints().size() + &quot;,width:&quot; + polyline.getWidth(), Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>到这里，运动结束后画出整个轨迹图和图层添加点击事件就介绍完了。</p><h2 id="时时动态的画运动轨迹"><a href="#时时动态的画运动轨迹" class="headerlink" title="时时动态的画运动轨迹"></a>时时动态的画运动轨迹</h2><blockquote><p>关键在于取点：gps刚接收到信号时返回的一些点精度不高，容易造成位置偏移，如何取点很重要。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">//伪代码</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">  mMapView = (MapView) findViewById(R.id.bmapView);</span><br><span class="line">  mBaiduMap = mMapView.getMap();</span><br><span class="line">  // 开启定位图层</span><br><span class="line">  mBaiduMap.setMyLocationEnabled(true);</span><br><span class="line"></span><br><span class="line">  /**添加地图缩放状态变化监听，当手动放大或缩小地图时，拿到缩放后的比例，然后获取到下次定位，</span><br><span class="line">  *  给地图重新设置缩放比例，否则地图会重新回到默认的mCurrentZoom缩放比例</span><br><span class="line">  */</span><br><span class="line">  mCurrentZoom = 18;</span><br><span class="line">  mBaiduMap.setOnMapStatusChangeListener(new OnMapStatusChangeListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onMapStatusChangeStart(MapStatus arg0) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMapStatusChangeFinish(MapStatus arg0) &#123;</span><br><span class="line">      mCurrentZoom = arg0.zoom;//获取手指缩放地图后的值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMapStatusChange(MapStatus arg0) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  //设置定位图标类型为跟随模式</span><br><span class="line">  mBaiduMap.setMyLocationConfiguration(new MyLocationConfiguration(</span><br><span class="line">                com.baidu.mapapi.map.MyLocationConfiguration.LocationMode.FOLLOWING, true, null));</span><br><span class="line"></span><br><span class="line">  // 定位初始化</span><br><span class="line">  mLocClient = new LocationClient(this);</span><br><span class="line">  mLocClient.registerLocationListener(myListener);</span><br><span class="line">  LocationClientOption option = new LocationClientOption();</span><br><span class="line">  option.setLocationMode(LocationMode.Device_Sensors);//只接受gps位置</span><br><span class="line">  option.setOpenGps(true); // 允许gps定位</span><br><span class="line">  option.setCoorType(&quot;bd09ll&quot;); // 设置坐标类型</span><br><span class="line">  option.setScanSpan(1000);//一秒一个gps</span><br><span class="line">  mLocClient.setLocOption(option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//开始获取位置点</span><br><span class="line">public void onStart() &#123;</span><br><span class="line">  start.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        if (mLocClient != null &amp;&amp; !mLocClient.isStarted()) &#123;</span><br><span class="line">            mLocClient.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//位置回调，取点很重要</span><br><span class="line">public class MyLocationListenner implements BDLocationListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceiveLocation(final BDLocation location) &#123;</span><br><span class="line"></span><br><span class="line">        if (location == null || mMapView == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (location.getLocType() == BDLocation.TypeGpsLocation) &#123;//只要gps点</span><br><span class="line"></span><br><span class="line">            if (isFirstLoc) &#123;//首次定位</span><br><span class="line">                /**第一个点很重要，决定了轨迹的效果，gps刚接收到信号时返回的一些点精度不高，</span><br><span class="line">                * 尽量选一个精度相对较高的起始点，这个过程大概从gps刚接收到信号后5-10秒就可以完成，不影响效果。</span><br><span class="line">                * 注：gps接收卫星信号少则十几秒钟，多则几分钟，</span><br><span class="line">                * 如果长时间手机收不到gps，退出，重启手机再试，这是硬件的原因</span><br><span class="line">                */</span><br><span class="line">                LatLng ll = null;</span><br><span class="line"></span><br><span class="line">                //选一个精度相对较高的起始点</span><br><span class="line">                ll = getMostAccuracyLocation(location);</span><br><span class="line">                if(ll == null)&#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                isFirstLoc = false;</span><br><span class="line">                points.add(ll);//加入集合</span><br><span class="line">                last = ll;</span><br><span class="line"></span><br><span class="line">                //显示当前定位点，缩放地图</span><br><span class="line">                locateAndZoom(location, ll);</span><br><span class="line"></span><br><span class="line">                //标记起点图层位置</span><br><span class="line">                MarkerOptions oStart = new MarkerOptions();// 地图标记覆盖物参数配置类</span><br><span class="line">                oStart.position(points.get(0));// 覆盖物位置点，第一个点为起点</span><br><span class="line">                oStart.icon(startBD);// 设置覆盖物图片</span><br><span class="line">                mBaiduMap.addOverlay(oStart); // 在地图上添加此图层</span><br><span class="line">                return;//画轨迹最少得2个点，首地定位到这里就可以返回了</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //从第二个点开始</span><br><span class="line">            LatLng ll = new LatLng(location.getLatitude(), location.getLongitude());</span><br><span class="line">            //sdk回调gps位置的频率是1秒1个，位置点太近动态画在图上不是很明显，可以设置点之间距离大于为5米才添加到集合中</span><br><span class="line">            if (DistanceUtil.getDistance(last, ll) &lt; 5) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            points.add(ll);//如果要运动完成后画整个轨迹，位置点都在这个集合中</span><br><span class="line"></span><br><span class="line">            last = ll;</span><br><span class="line"></span><br><span class="line">            //显示当前定位点，缩放地图</span><br><span class="line">            locateAndZoom(location, ll);</span><br><span class="line"></span><br><span class="line">            //清除上一次轨迹，避免重叠绘画</span><br><span class="line">            mMapView.getMap().clear();</span><br><span class="line"></span><br><span class="line">            //起始点图层也会被清除，重新绘画</span><br><span class="line">            MarkerOptions oStart = new MarkerOptions();</span><br><span class="line">            oStart.position(points.get(0));</span><br><span class="line">            oStart.icon(startBD);</span><br><span class="line">            mBaiduMap.addOverlay(oStart);</span><br><span class="line"></span><br><span class="line">            //将points集合中的点绘制轨迹线条图层，显示在地图上</span><br><span class="line">            OverlayOptions ooPolyline = new PolylineOptions().width(13).color(0xAAFF0000).points(points);</span><br><span class="line">            mPolyline = (Polyline) mBaiduMap.addOverlay(ooPolyline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//首次定位很重要，选一个精度相对较高的起始点</span><br><span class="line">private LatLng getMostAccuracyLocation(final BDLocation location)&#123;</span><br><span class="line"></span><br><span class="line">    if (location.getRadius()&gt;25) &#123;//gps位置精度大于25米的点直接弃用</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LatLng ll = new LatLng(location.getLatitude(), location.getLongitude());</span><br><span class="line"></span><br><span class="line">    if (DistanceUtil.getDistance(last, ll ) &gt; 5) &#123;</span><br><span class="line">        last = ll;</span><br><span class="line">        points.clear();//有两点位置大于5，重新来过</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    points.add(ll);</span><br><span class="line">    last = ll;</span><br><span class="line">    //有5个连续的点之间的距离小于5，认为gps已稳定，以最新的点为起始点</span><br><span class="line">    if(points.size() &gt;= 5)&#123;</span><br><span class="line">        points.clear();</span><br><span class="line">        return ll;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//显示当前定位点，缩放地图</span><br><span class="line">private void locateAndZoom(BDLocation location, LatLng ll) &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 记录当前经纬度，当位置不变，手机转动，取得方向传感器的方向，</span><br><span class="line">      给地图重新设置位置参数，在跟随模式下可使地图箭头随手机转动而转动</span><br><span class="line">    */</span><br><span class="line">    mCurrentLat = location.getLatitude();</span><br><span class="line">    mCurrentLon = location.getLongitude();</span><br><span class="line">    locData = new MyLocationData.Builder().accuracy(0)//去掉精度圈</span><br><span class="line">            //此mCurrentDirection为自己获取到的手机传感器方向信息，顺时针0-360</span><br><span class="line">            .direction(mCurrentDirection).latitude(location.getLatitude())</span><br><span class="line">            .longitude(location.getLongitude()).build();</span><br><span class="line">    mBaiduMap.setMyLocationData(locData);//显示当前定位位置点</span><br><span class="line"></span><br><span class="line">    //给地图设置缩放中心点，和缩放比例值</span><br><span class="line">    builder = new MapStatus.Builder();</span><br><span class="line">    builder.target(ll).zoom(mCurrentZoom);</span><br><span class="line">    mBaiduMap.animateMapStatus(MapStatusUpdateFactory.newMapStatus(builder.build()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运动结束增加终点图标</span><br><span class="line">finish.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">        if (mLocClient != null &amp;&amp; mLocClient.isStarted()) &#123;</span><br><span class="line">            mLocClient.stop();//停止定位</span><br><span class="line"></span><br><span class="line">            if(points.size() &lt;= 0)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //运动结束记得标记终点图标</span><br><span class="line">            MarkerOptions oFinish = new MarkerOptions();</span><br><span class="line">            oFinish.position(points.get(points.size() - 1));</span><br><span class="line">            oFinish.icon(finishBD);</span><br><span class="line">            mBaiduMap.addOverlay(oFinish); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>退出记得释放资源<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//伪代码</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">  // 退出时销毁定位</span><br><span class="line">  mLocClient.unRegisterLocationListener(myListener);</span><br><span class="line">  mLocClient.stop();</span><br><span class="line">  // 关闭定位图层</span><br><span class="line">  mBaiduMap.setMyLocationEnabled(false);</span><br><span class="line">  mMapView.getMap().clear();</span><br><span class="line">  mMapView.onDestroy();</span><br><span class="line">  mMapView = null;</span><br><span class="line">  startBD.recycle();</span><br><span class="line">  finishBD.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>我们画运动轨迹要求定位sdk返回的位置精度很高，轨迹的效果才会好，因而必须接受gps位置点。但是gps位置的在刚开始收到信号时精度不高，会出现位置漂移的情况，所以要选取一个精度较好的点。在建筑物、桥梁、大树、隧道里面，gps信号不好，精度不高，所以在开阔地带，运动轨迹效果更好。</p></blockquote><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Lambda 表达式在 Android 开发中的使用</title>
      <link href="/2017/07/01/17-07-01/"/>
      <url>/2017/07/01/17-07-01/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Lambda ,希腊字母 “λ” 的英文名称。没错，就是你高中数学老师口中的那个“兰布达”。在编程世界中，它是匿名函数的别名， Java 从 Java 8 开始引入 lambda 表达式。而 Android 开发者的世界里，直到 Android Studio 2.4 Preview 4 及其之后的版本里，lambda 表达式才得到完全的支持（在此之前需要使用 Jack 编译器或 retrolambda 等插件，详见链接）。新版本 Android Studio 使用向导详见 <a href="https://developer.android.google.cn/studio/write/java8-support.html">《在 Android Studio 上使用 Java 8 新特性》</a>。</p><p>Oracle 官方推出的 lambda 教程开篇第一句就表扬了其对匿名内部类笨拙繁琐的代码的简化，然而，在各大 RxJava 教程下的评论中，最受吐槽的就是作者提供的示例代码用了 lambda 表达式，给阅读造成了很大的障碍。</p><p>所以，在这篇文章中，我会先讲解 lambda 表达式的作用和三种形式，之后提供一个在 Android Studio 便捷使用 lambda 的小技巧，然后说一说 lambda 表达式中比较重要的变量捕获概念，最后再讲一些使用 lambda 表达式前后的差异。</p></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>前面提到，lambda 是匿名函数的别名。简单来说，lambda 表达式是对匿名内部类的进一步简化。使用 lambda 表达式的前提是编译器可以准确的判断出你需要哪一个匿名内部类的哪一个方法。</p><p>我们最经常接触使用匿名内部类的行为是为 view 设置 OnClickListener ，这时你的代码是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(new View.OnClickListener()&#123;</span><br><span class="line">@Override public void onClick(View v)&#123;</span><br><span class="line">doSomeWork();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>使用匿名内部类，实现了对象名的隐匿；而匿名函数，则是对方法名的隐匿。所以当使用 lambda 表达式实现上述代码时，是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener( </span><br><span class="line">(View v) -&gt; &#123;</span><br><span class="line">doSomeWork();</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>看不懂？没关系,在这两个示例中，你只要理解，lambda 表达式不仅对对象名进行隐匿，更完成了方法名的隐匿，展示了一个接口抽象方法最有价值的两点：<strong>参数列表</strong>和<strong>具体实现</strong>。下面我会对 lambda 的各种形式进行列举。</p><h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h2><blockquote><p>在 Java 中，lambda 表达式共有三种形式：<strong>函数式接口</strong>、<strong>方法引用</strong>和<strong>构造器引用</strong>。其中，函数式接口形式是最基本的 lambda 形式，其余两种形式都是基于此形式进行拓展。</p></blockquote><p>PS：为了更好的展示使用 lambda 表达式前后的代码区别，本文将使用 lambda 表达式给引用赋值的形式作为实例展示，而不是常用的直接将 lambda 表达式传入方法之中。同时，举例也不一定具有实际意义。</p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口是指<strong>有且只有一个</strong>抽象方法的接口，比如各种 Listener 接口和 Runnable 接口。lambda 表达式就是对这类接口的匿名内部类进行简化。基本形式如下：<br><strong>( 参数列表… ) -&gt; { 语句块… }</strong></p><p>下面以 Java 提供的 Comparator 接口来展示一个实例，该接口常用于排序比较：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Comparator&lt;T&gt; &#123;int compare(T var1, T var2);&#125;</span><br><span class="line">Comparator&lt;String&gt; comparator = new Comparator&lt;String&gt; ()&#123;</span><br><span class="line">@Override public int compare(String s1, String s2) &#123;</span><br><span class="line">doSomeWork();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Comparator&lt;String&gt; comparator = (String s1, String s2) -&gt; &#123;</span><br><span class="line">doSomeWork();</span><br><span class="line">return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当编译器可以推导出具体的参数类型时，我们可以从参数列表中忽略参数类型，那么上面的代码就变成了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comparator = ( s1 , s2 ) -&gt; &#123;</span><br><span class="line">doSomeWork();</span><br><span class="line">return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当参数只有一个时，参数列表两侧的圆括号也可省略，比如 OnClickListener 接口可写成 ：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface OnClickListener &#123; void onClick(View v); &#125;</span><br><span class="line">OnClickListener listener = v -&gt; &#123; 语句块... &#125; ;</span><br></pre></td></tr></table></figure><br>然而，当方法没有传入参数的时候，则记得提供一对空括号假装自己是参数列表（雾），比如 Runnable 接口：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface Runnable &#123; void run(); &#125;</span><br><span class="line">Runnable runnable = () -&gt; &#123; 语句块... &#125; ;</span><br></pre></td></tr></table></figure><br>当语句块内的处理逻辑只有一句表达式时，其两侧的花括号也可省略，特别注意这句处理逻辑表达式后面也不带分号。比如这个关闭 activity 的点击方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener( v -&gt; activity.finish() );</span><br></pre></td></tr></table></figure><br>同时，当只有一句去除花括号的表达式且接口方法需要返回值时，这个表达式不用（也不能）在表达式前加 return ，就可以当作返回语句。下面用 Java 的 Function 接口作为示例，这是一个用于转换类型的接口，在这里我们获取一个 User 对象的姓名字符串并返回：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Function &lt;T, R&gt; &#123; R apply(T t); &#125;</span><br><span class="line">Function &lt;User, String&gt; function = new Function &lt;User, String&gt;()&#123;</span><br><span class="line">@Override public String apply(User user) &#123;</span><br><span class="line">return user.getName();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Function &lt;User, String&gt; function = user -&gt; user.getName() ;</span><br></pre></td></tr></table></figure></p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>在介绍第一种形式的之前，我曾写道：函数式接口形式是最基本的 lambda 表达式形式，其余形式都是由其拓展而来。那么，现在来介绍第二种形式：方法引用形式。</p><p>当我们使用第一种 lambda 表达式的时候，进行逻辑实现的时候我们既可以自己实现一系列处理，也可以直接调用已经存在的方法，下面以 Java 的 Predicate 接口作为示例，此接口用来实现判断功能，我们来对字符串进行全面的判空操作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Predicate&lt;T&gt; &#123; boolean test(T t); &#125;</span><br><span class="line">Predicate&lt;String&gt; predicate=</span><br><span class="line">s -&gt; &#123;</span><br><span class="line">//用基本代码组合进行判断</span><br><span class="line">return s==null || s.length()==0 ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们知道，TextUtils 的 isEmpty() 方法实现了上述功能，所以我们可以写作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = s -&gt; TextUtils.isEmpty(s) ;</span><br></pre></td></tr></table></figure><br>这时我们调用了已存在的方法来进行逻辑判断，我们就可以使用方法引用的形式继续简化这一段 lambda 表达式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = TextUtils::isEmpty ;</span><br></pre></td></tr></table></figure><br>惊不惊喜？意不意外？</p><p>方法引用形式就是<strong>当逻辑实现只有一句且调用了已存在的方法进行处理( this 和 super 的方法也可包括在内)时，对函数式接口形式的 lambda 表达式进行进一步的简化。</strong>传入引用方法的参数就是原接口方法的参数。</p><p>接下来总结一下方法引用形式的三种格式：</p><ol><li><p>object :: instanceMethod<br>直接调用任意对象的实例方法，如 obj::equals 代表调用 obj 的 equals 方法与接口方法参数比较是否相等，效果等同 obj.equals(t);。<br>当前类的方法可用this::method进行调用，父类方法同理。</p></li><li><p>ClassName :: staticMethod<br>直接调用某类的静态方法，并将接口方法参数传入，如上述 TextUtils::isEmpty ，效果等同 TextUtils.isEmpty(s);</p></li><li><p>ClassName :: instanceMethod<br>较为特殊,将接口方法参数列表的第一个参数作为方法调用者，其余参数作为方法参数。由于此类接口较少，故选择 Java 提供的 BiFunction 接口作为示例，该接口方法接收一个 T1 类对象和一个 T2 类对象，通过处理后返回 R 类对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface BiFunction&lt;T1, T2, R&gt; &#123;</span><br><span class="line">R apply(T1 t1, T2 t2);</span><br><span class="line">&#125;</span><br><span class="line">BiFunction&lt;String,String,Boolean&gt; biFunction=</span><br><span class="line">new BiFunction&lt;String, String, Boolean&gt;() &#123;</span><br><span class="line">@Override public Boolean apply(String s1, String s2)&#123;</span><br><span class="line">        return s1.equals(s2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">// ClassName 为接口方法的第一个参数的类名，同时利用接口方法的第一个参数作为方法调用者，其余参数作为方法参数，实现 s1.equals(s2);</span><br><span class="line">BiFunction&lt;String,String,Boolean&gt; biFunction= String::equals;</span><br></pre></td></tr></table></figure></li></ol><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>Lambda 表达式的第三种形式，其实和方法引用十分相似，只不过方法名替换为 new 。其格式为<strong>ClassName :: new</strong>。这时编译器会通过上下文判断传入的参数的类型、顺序、数量等，来调用适合的构造器，返回对象。</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p>Android Studio 会在可以转化为 lambda 表达式的代码上进行如图的灰色标识，这时将光标移至灰色区域，按下 Alt + Enter ，选择第一项（方法引用和构造器引用在第二项），IDE 就会自动进行转换。<br><img src="http://dinson-blog.hdinson.cn/FjLLt5fswLsU3L2bFJNN_kYKGrVH.png" alt=""></p><h2 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h2><p>在使用匿名内部类时，若要在内部类中使用外部变量，则需要将此变量定义为 final 变量。因为我们并不知道所实现的接口方法何时会被调用，所以通过设立 final 来确保安全。在 lambda 表达式中，仍然需要遵守这个标准。</p><p>不过在 Java 8 中，新增了一个 effective final 功能，只要一个变量没有被修改过引用（基本变量则不能更改变量值），即为实质上的 final 变量，那么不用再在声明变量时加上 final 修饰符。接下来还是通过一个示例解释，示例中共有三句被注释掉的赋值语句，去除任意一句的注释，都会报错：Variable used in lambda expression should be final or effectively final。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int effectiveFinalInt=666;//外部变量</span><br><span class="line">//①effectiveFinalInt=233；</span><br><span class="line">button.setOnClickListener(v -&gt; &#123;</span><br><span class="line">  Toast.makeText( effectiveFinalInt + &quot;&quot;).show();</span><br><span class="line">      //②effectiveFinalInt=233;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">//③effectiveFinalInt=233;</span><br></pre></td></tr></table></figure><br>可以看到，我们可以不做任何声明上的改变即可在 lambda 中使用外部变量，前提是我们以 final 的规则对待这个变量。</p><h2 id="一点玄学"><a href="#一点玄学" class="headerlink" title="一点玄学"></a>一点玄学</h2><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>在匿名内部类中，this 关键字指向的是匿名类本身的对象，而在 lambda 中，this 指向的是 lambda 表达式的外部类。</p><h3 id="方法数差异"><a href="#方法数差异" class="headerlink" title="方法数差异"></a>方法数差异</h3><p>当前 Android Studio 对 Java 8 新特性编译时采用脱糖（desugar）处理，lambda 表达式经过编译器编译后，每一个 lambda 表达式都会增加 1~2 个方法数。而 Android 应用的方法数不能超过 65536 个。虽然一般应用较难触发，但仍需注意。</p><p>参考资料</p><p>书籍：《 Java 核心技术 》</p><p>网络文章：<br><a href="https://developer.android.google.cn/studio/write/java8-support.html">在 Android Studio 上使用 Java 8 新特性(官方)</a><br><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Oracle 官方 lambda 教程</a><br><a href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数–维基百科（需科学上网）</a><br><a href="http://blog.oneapm.com/apm-tech/226.html">深入浅出 Java 8 Lambda 表达式</a></p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017年Android百大框架排行榜</title>
      <link href="/2017/06/28/17-06-28/"/>
      <url>/2017/06/28/17-06-28/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>排行榜包括四大类：</p><ul><li>单一框架：仅提供路由、网络层、UI层、通信层或其他单一功能的框架</li><li>混合开发框架：提供开发hybrid app、h5与webview结合能力、web app能力的框架。</li><li>企业级开源项目：可以独立运行的app，有极高的学习价值、思路借鉴意义</li><li>书籍类开源项目：类似Open-sourc-project这样的导航类项目，大型公司的Android课程的学习目录</li></ul></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="百大框架排行榜"><a href="#百大框架排行榜" class="headerlink" title="百大框架排行榜"></a>百大框架排行榜</h2><div class="table-container"><table><thead><tr><th>框架名称　　</th><th>上榜关键字</th></tr></thead><tbody><tr><td>1.Retrofit　　</td><td>网络</td></tr><tr><td>2.okhttp</td><td>网络</td></tr><tr><td>3.Butter Knife</td><td>代码模板</td></tr><tr><td>4.MPAndroidChart</td><td>图表</td></tr><tr><td>5.glide</td><td>图片</td></tr><tr><td>6.leakcanary</td><td>内存</td></tr><tr><td>7.Android-Universal-Image-Loader</td><td>图片</td></tr><tr><td>8.EventBus</td><td>事件消息</td></tr><tr><td>9.zxing</td><td>条码扫描</td></tr><tr><td>10.picasso</td><td>图片</td></tr><tr><td>11.lottie-android</td><td>动画</td></tr><tr><td>12.fresco</td><td>图片</td></tr><tr><td>13.RxAndroid</td><td>异步</td></tr><tr><td>14.SlidingMenu</td><td>菜单</td></tr><tr><td>15.PhotoView</td><td>图片</td></tr><tr><td>16.material-dialogs</td><td>UI</td></tr><tr><td>17.droid-async-http</td><td>网络</td></tr><tr><td>18.androidannotations</td><td>注解</td></tr><tr><td>19.fastjson</td><td>json</td></tr><tr><td>20.Material-Animations</td><td>动画</td></tr><tr><td>21.tinker</td><td>热修复</td></tr><tr><td>22.ViewPagerIndicator</td><td>UI</td></tr><tr><td>23.Android-CleanArchitecture</td><td>架构</td></tr><tr><td>24.Android-PullToRefresh</td><td>刷新</td></tr><tr><td>25.flexbox-layout</td><td>UI</td></tr><tr><td>26.AndroidSwipeLayout</td><td>UI</td></tr><tr><td>27.realm-java</td><td>数据库</td></tr><tr><td>28.greenDAO</td><td>数据</td></tr><tr><td>29.stetho</td><td>调试</td></tr><tr><td>30.BaseRecyclerViewAdapterHelper</td><td>UI</td></tr><tr><td>31.AndroidViewAnimations</td><td>动画</td></tr><tr><td>32.MaterialDrawer</td><td>菜单</td></tr><tr><td>33.Android-ObservableScrollView</td><td>UI</td></tr><tr><td>34.CircleImageView</td><td>图片</td></tr><tr><td>35.logger</td><td>调试</td></tr><tr><td>36.agera</td><td>异步</td></tr><tr><td>37.BottmBar</td><td>菜单</td></tr><tr><td>38.Calligraphy</td><td>字体</td></tr><tr><td>39.AndroidSlidingUpPanel</td><td>UI</td></tr><tr><td>40.AppIntro</td><td>UI</td></tr><tr><td>41.recyclerview-animators</td><td>动画</td></tr><tr><td>42.dagger</td><td>依赖注入</td></tr><tr><td>43.Android-Bootstarp</td><td>UI</td></tr><tr><td>44.RxBinding</td><td>响应式</td></tr><tr><td>45.ListViewAnimations</td><td>动画</td></tr><tr><td>46.UItimateRecyclerView</td><td>UI</td></tr><tr><td>47.uCrop</td><td>图片</td></tr><tr><td>48.RxJava-Android-Samples</td><td>用例</td></tr><tr><td>49.AndroidAutoLayout</td><td>适配</td></tr><tr><td>50.EffectiveAndroidUI</td><td>性能</td></tr><tr><td>51.Luban</td><td>图片</td></tr><tr><td>52.DroidPlugin</td><td>插件化</td></tr><tr><td>53.otto</td><td>响应式</td></tr><tr><td>54.u2020</td><td>用例</td></tr><tr><td>55.buck</td><td>构建</td></tr><tr><td>56.PermissionsDispatcher</td><td>权限</td></tr><tr><td>57.android-gif-drawable</td><td>GIF</td></tr><tr><td>58.Apktool</td><td>反编译</td></tr><tr><td>59.dynamic-load-apk</td><td>插件化</td></tr><tr><td>60.atlas</td><td>插件化</td></tr><tr><td>61.volley</td><td>网络</td></tr><tr><td>62.androidmvp</td><td>用例</td></tr><tr><td>63.SwipeBackLayout</td><td>手势</td></tr><tr><td>64.FlycoTabLayout</td><td>UI</td></tr><tr><td>65.android-testing</td><td>测试</td></tr><tr><td>66.FileDownloader</td><td>下载</td></tr><tr><td>67.JieCaoVideoPlayer</td><td>多媒体</td></tr><tr><td>68.glide-transformations</td><td>图片</td></tr><tr><td>69.android-gpuimage</td><td>图片</td></tr><tr><td>70.RxPermissions</td><td>权限</td></tr><tr><td>71.freeline</td><td>编译</td></tr><tr><td>72.RxLifecycle</td><td>生命周期</td></tr><tr><td>73.classyshark</td><td>反编译</td></tr><tr><td>74.acra</td><td>崩溃日志</td></tr><tr><td>75.DiskLruCache</td><td>文件</td></tr><tr><td>76.dexposed</td><td>热修复</td></tr><tr><td>77.Litho</td><td>性能</td></tr><tr><td>78.mosby</td><td>MVP</td></tr><tr><td>79.AndResGuard　　　　</td><td>混淆</td></tr><tr><td>80.StatusBarUtil</td><td>状态栏</td></tr><tr><td>81.robolectric</td><td>测试</td></tr><tr><td>82.Fragmentation</td><td>嵌套</td></tr><tr><td>83.Small</td><td>插件化</td></tr><tr><td>84.JsBridge</td><td>hybrid</td></tr><tr><td>85.richeditor-android</td><td>UI</td></tr><tr><td>86.Transitions-Everywhere</td><td>动画</td></tr><tr><td>87.android-viewbadger</td><td>勋章</td></tr><tr><td>88.AndroidWiFiADB</td><td>调试</td></tr><tr><td>89.emojicon</td><td>表情包</td></tr><tr><td>90.packer-ng-plugin</td><td>多渠道</td></tr><tr><td>91.android-priority-jobqueue</td><td>多线程</td></tr><tr><td>92.Android-Debug-Database</td><td>调试</td></tr><tr><td>93.conceal</td><td>加密</td></tr><tr><td>94.ARouter</td><td>页面路由</td></tr><tr><td>95.MagicaSakura</td><td>多主题</td></tr><tr><td>96.CustomActivityOnCrash</td><td>崩溃</td></tr><tr><td>97.XhsEmoticonsKeyboard</td><td>键盘</td></tr></tbody></table></div><h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit　　"></a>Retrofit　　</h3><blockquote><p>一句话介绍：Retrofit是一款类型安全的网络框架，基于HTTP协议，服务于Android和java语言</p><p>上榜理由：Retrofit以21.8k的stars量雄踞github中android子标题榜首，第一当之无愧。</p></blockquote><p>官网地址：<a href="http://square.github.io/retrofit/">http://square.github.io/retrofit/</a></p><p>github：<a href="https://github.com/square/retrofit">https://github.com/square/retrofit</a></p><p>作者：square团队</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.squareup.retrofit2:retrofit:2.3.0&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="okhttp"><a href="#okhttp" class="headerlink" title="okhttp"></a>okhttp</h3><blockquote><p>一句话介绍：okhttp是一款基于HTTP和HTTP2.0协议的网络框架，服务于java和android客户端</p><p>上榜理由：okhttp以20.4k的stars量雄踞github中android子标题第二名。大型公司比如淘宝也封装的是okhttp。Retrofit2.0开始内置okhttp框架，Retrofit专注封装接口完成业务需求，okhttp专注网络请求的安全高效，笔者将两者区分开，是想让后来学习者知道，这是两套框架，学习框架原理时可以分开学习，以免理解混乱。</p></blockquote><p>官网地址：<a href="http://square.github.io/okhttp/">http://square.github.io/okhttp/</a></p><p>github：<a href="https://github.com/square/okhttp">https://github.com/square/okhttp</a></p><p>作者：square团队</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.squareup.okhttp3:okhttp:3.8.0&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="Butter-Knife"><a href="#Butter-Knife" class="headerlink" title="Butter Knife"></a>Butter Knife</h3><blockquote><p>一句话介绍：Butter Knife所提供了一种能力——使用注解生成模板代码，将view与方法和参数绑定。</p><p>上榜理由：github上16.5K个star，配合Androidstudio提供的Butter Knife插件，帮助开发者省却了频繁findviewbyid的烦恼，最新的Butter Knife还提供了onclick绑定以及字符串的初始化，初学者可以查阅Butter Knife以及Butter Knife插件进一步学习！</p></blockquote><p>官网地址：<a href="http://jakewharton.github.io/butterknife/">http://jakewharton.github.io/butterknife/</a></p><p>github：<a href="https://github.com/JakeWharton/butterknife">https://github.com/JakeWharton/butterknife</a></p><p>作者：JakeWharton ，也是square团队成员之一</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile &#x27;com.jakewharton:butterknife:8.6.0&#x27;</span><br><span class="line">  annotationProcessor &#x27;com.jakewharton:butterknife-compiler:8.6.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="MPAndroidChart"><a href="#MPAndroidChart" class="headerlink" title="MPAndroidChart"></a>MPAndroidChart</h3><blockquote><p>一句话介绍：MPAndroidChart是一款图表框架</p><p>上榜理由：github上16.1K个star，以快速、简洁。强大著称的图表框架</p></blockquote><p>官网地址：<a href="https://github.com/PhilJay/MPAndroidChart">https://github.com/PhilJay/MPAndroidChart</a>  </p><p>github：<a href="https://github.com/PhilJay/MPAndroidChart">https://github.com/PhilJay/MPAndroidChart</a></p><p>作者：PhilJay</p><p>使用：</p><ul><li>在根目录的 build.gradle上加入:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在app的build.gradle上加入：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.github.PhilJay:MPAndroidChart:v3.0.2&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="glide"><a href="#glide" class="headerlink" title="glide"></a>glide</h3><blockquote><p>一句话介绍：glide是一款专注于提供流畅划动能力的“图片加载和缓存框架”</p><p>上榜理由：15.9k个star，图片加载类框架排名第一的框架，google 在2014开发者大会上演示的camera app就是基于gilde框架开发的</p></blockquote><p>github：<a href="https://github.com/bumptech/glide">https://github.com/bumptech/glide</a></p><p>作者：Bump Technologies团队</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.github.bumptech.glide:glide:3.8.0&#x27;</span><br><span class="line">    compile &#x27;com.android.support:support-v4:19.1.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="leakcanary"><a href="#leakcanary" class="headerlink" title="leakcanary"></a>leakcanary</h3><blockquote><p>一句话介绍：一款内存检测框架，服务于java和android客户端</p><p>上榜理由：方便，简洁是leakcanary最大的特点，只需在应用的apllication中集成，就可以直接使用它；15.5k个star说明了它有多么受欢迎</p></blockquote><p>github：<a href="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a></p><p>作者：square团队</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   debugCompile &#x27;com.squareup.leakcanary:leakcanary-android:1.5.1&#x27;</span><br><span class="line">   releaseCompile &#x27;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&#x27;</span><br><span class="line">   testCompile &#x27;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在 Application 中写入:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleApplication extends Application &#123;</span><br><span class="line">  @Override public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    if (LeakCanary.isInAnalyzerProcess(this)) &#123;</span><br><span class="line">      // This process is dedicated to LeakCanary for heap analysis.</span><br><span class="line">      // You should not init your app in this process.</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    LeakCanary.install(this);</span><br><span class="line">    // Normal app init code...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Android-Universal-Image-Loader"><a href="#Android-Universal-Image-Loader" class="headerlink" title="Android-Universal-Image-Loader"></a>Android-Universal-Image-Loader</h3><blockquote><p>一句话介绍：曾经的图片加载框架王者，android开发老手都用过它</p><p>上榜理由:android端图片加载框架的老大哥了，15.3k个star足以证明它的热门，UIL与gilde最大区别是可定制，UIL提供了大量配置方式，图片加载状态的回调（成功，失败，进行中），加载动画等；以及提供了移动端图片加载框架的缓存思路：三级缓存策略 sd卡-内存-网络；值得注意的是，UIL以及两年未更新了，但笔者仍推荐各位使用！</p></blockquote><p>github：<a href="https://github.com/nostra13/Android-Universal-Image-Loader">https://github.com/nostra13/Android-Universal-Image-Loader</a></p><p>作者：nostra13</p><p>使用：<br>下载地址   <a href="https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/downloads/universal-image-loader-1.9.5.jar">universal-image-loader-1.9.5.jar</a></p><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><blockquote><p>一句话介绍：EventBus是一款本地组件间通信框架</p><p>上榜理由：组件间通信框架star量第一：14.8k，在大型项目的Activities，fragments，Threads，Services都可以看到它的使用场景，尽管EventBus在向未创建的组件传递事件时有些局限，仅适合在“活着的”组件间传递消息，但仍不妨碍它活跃在各个大型项目各个场景里。</p></blockquote><p>官网地址：<a href="http://greenrobot.org/eventbus/documentation/how-to-get-started/">http://greenrobot.org/eventbus/documentation/how-to-get-started/</a></p><p>github：<a href="https://github.com/greenrobot/EventBus">https://github.com/greenrobot/EventBus</a></p><p>作者：greenrobot </p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;org.greenrobot:eventbus:3.0.0&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="zxing"><a href="#zxing" class="headerlink" title="zxing"></a>zxing</h3><blockquote><p>一句话介绍：条码图像处理库</p><p>上榜理由：如果你用过二维码，你肯定已经间接使用过大名鼎鼎的zxing了。13.9K的star量，让它排在本榜单第九，实至名归，如果你有了解二维码的需求，不妨从了解、修改它源码入手。</p></blockquote><p>github：<a href="https://github.com/zxing/zxing">https://github.com/zxing/zxing</a></p><p>作者：Sean Owen</p><h3 id="picasso"><a href="#picasso" class="headerlink" title="picasso"></a>picasso</h3><blockquote><p>一句话介绍：强力的图片下载、缓存框架</p><p>上榜理由：本榜单出现的第三款图片类框架，不同的是picasso更强调图片下载，你可以将picasso集成进你的项目中，你也可以结合gilde和UIL与picasso，三者一齐封装至你的项目中，按需所用。</p></blockquote><p>官网地址：<a href="http://square.github.io/picasso/">http://square.github.io/picasso/</a></p><p>github：<a href="https://github.com/square/picasso">https://github.com/square/picasso</a></p><p>作者：square团队</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.squareup.picasso:picasso:2.5.2&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="lottie-android"><a href="#lottie-android" class="headerlink" title="lottie-android"></a>lottie-android</h3><blockquote><p>一句话介绍：一款可以在Android端快速展示Adobe Afeter Effect（AE）工具所作动画的框架</p><p>上榜理由：动画类框架第一名，github上13.3k个star证明了他的优越性，利用json文件快速实现动画效果是它最大的便利，而这个json文件也是由Adobe提供的After Effects（AE）工具制作的，在AE中装一个Bodymovin的插件，使用这个插件最终将动画效果生成json文件，这个json文件即可由LottieAnimationView解析并生成绚丽的动画效果。而且它还支持跨平台哟。</p></blockquote><p>github：<a href="https://github.com/airbnb/lottie-android">https://github.com/airbnb/lottie-android</a></p><p>作者：Airbnb 团队</p><h3 id="fresco"><a href="#fresco" class="headerlink" title="fresco"></a>fresco</h3><blockquote><p>一句话介绍：一款可以管理图片内存的框架</p><p>上榜理由:github上12.8k个star，图片类排行榜第四名，facebook的出身证明了它并非是重复造的轮子，在管理图片内存领域上有着它的一片天地，渐进式加载、加载gif都是它与前三位相比独有的特性</p></blockquote><p>官网地址： <a href="https://www.fresco-cn.org/">https://www.fresco-cn.org/</a></p><p>github：<a href="https://github.com/facebook/fresco">https://github.com/facebook/fresco</a></p><p>作者：facebook</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // 其他依赖</span><br><span class="line">  compile &#x27;com.facebook.fresco:fresco:0.12.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面的依赖需要根据需求添加：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // 在 API &lt; 14 上的机器支持 WebP 时，需要添加</span><br><span class="line">  compile &#x27;com.facebook.fresco:animated-base-support:0.12.0&#x27;</span><br><span class="line"></span><br><span class="line">  // 支持 GIF 动图，需要添加</span><br><span class="line">  compile &#x27;com.facebook.fresco:animated-gif:0.12.0&#x27;</span><br><span class="line"></span><br><span class="line">  // 支持 WebP （静态图+动图），需要添加</span><br><span class="line">  compile &#x27;com.facebook.fresco:animated-webp:0.12.0&#x27;</span><br><span class="line">  compile &#x27;com.facebook.fresco:webpsupport:0.12.0&#x27;</span><br><span class="line"></span><br><span class="line">  // 仅支持 WebP 静态图，需要添加</span><br><span class="line">  compile &#x27;com.facebook.fresco:webpsupport:0.12.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="RxAndroid"><a href="#RxAndroid" class="headerlink" title="RxAndroid"></a>RxAndroid</h3><blockquote><p>一句话介绍：一款Android客户端组件间异步通信的框架</p><p>上榜理由：github上12.7k个star，位居组件通信框架的第二名，仅在EventBus之后，如果要问两者的区别，Eventbus是用来取代组件间繁琐的interface，RxAndroid是用来取代AnsyTask的，并不冲突；当然RxAndroid的优点并不仅限于此，更多优雅的实现，可以去官网查阅！</p></blockquote><p>github：<a href="https://github.com/ReactiveX/RxAndroid">https://github.com/ReactiveX/RxAndroid</a></p><p>作者：JakeWharton</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;io.reactivex.rxjava2:rxandroid:2.0.1&#x27;</span><br><span class="line">compile &#x27;io.reactivex.rxjava2:rxjava:2.1.0&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="SlidingMenu"><a href="#SlidingMenu" class="headerlink" title="SlidingMenu"></a>SlidingMenu</h3><blockquote><p>一句话介绍：侧滑菜单栏框架</p><p>上榜理由：与Userval-Image-loader 齐名的上古神器框架——为你的app提供侧滑菜单栏的功能；github闪更有10.5k个star，证明了它的经久不衰，即使在Google推出了NavigationDrawer，仍然没有减少开发者对SildingMenu的拥簇，经典总是经得起考验的，这个上古神兽已经四年没有更新了；有太多太多的app使用过它，这些都可以在软件的开源许可上看到！</p></blockquote><p>github：<a href="https://github.com/jfeinstein10/SlidingMenu">https://github.com/jfeinstein10/SlidingMenu</a></p><p>作者：Jeremy Feinstein</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在gihub上fork源码，集成进项目中</span><br></pre></td></tr></table></figure></p><h3 id="PhotoView"><a href="#PhotoView" class="headerlink" title="PhotoView"></a>PhotoView</h3><blockquote><p>一句话介绍：一款ImageView展示框架，支持缩放，响应手势</p><p>上榜理由：10.3k的star数量，位于图片类框架排行榜第五位，PhotoView与前四位不同的是这次带来的是图片的展示能力，你一定好奇微信的头像点击放大是如何实现的，很多App的图片显示响应手势按压是如何实现的，了解PhotoView，你一定会开心的！（笔者也不会告诉你ImageView的点击放大效果在Android的sample也有）</p></blockquote><p>github：<a href="https://github.com/chrisbanes/PhotoView">https://github.com/chrisbanes/PhotoView</a></p><p>作者：chrisbanes</p><p>使用：<br>在app根目录的build.gradle中加入：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在app的module目录的build.gralde中加入：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.github.chrisbanes:PhotoView:latest.release.here&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.github.chrisbanes.photoview.PhotoView</span><br><span class="line">    android:id=&quot;@+id/photo_view&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PhotoView photoView = (PhotoView) findViewById(R.id.photo_view);</span><br><span class="line">photoView.setImageResource(R.drawable.image);</span><br></pre></td></tr></table></figure></p><h3 id="material-dialogs"><a href="#material-dialogs" class="headerlink" title="material-dialogs"></a>material-dialogs</h3><blockquote><p>一句话介绍：一款自定义dialog框架</p><p>上榜理由：9.9k个star，也是继PhotoView，SlidingMenu之后第三款自定义View框架，也许你还是自定义View的新人，对Dialog使用的还有点生疏，你可以通过它提升你的Dilaog使用能力</p></blockquote><p>github：<a href="https://github.com/afollestad/material-dialogs">https://github.com/afollestad/material-dialogs</a></p><p>作者：Aidan Follestad</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // ... other dependencies here</span><br><span class="line">    compile &#x27;com.afollestad.material-dialogs:core:0.9.4.5&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="droid-async-http"><a href="#droid-async-http" class="headerlink" title="droid-async-http"></a>droid-async-http</h3><blockquote><p>一句话介绍：一款基于Http协议的异步请求的网络框架，</p><p>上榜理由：虽然你有无数个使用retrofit+okhttp的理由，但9.8k个star，证明它仍然值得你深入学习。值得注意的是，它也已经有两年没更新了，你尽管拿去当你懒惰的理由！</p></blockquote><p>github：<a href="https://github.com/loopj/android-async-http">https://github.com/loopj/android-async-http</a></p><p>作者：James Smith</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  maven &#123;</span><br><span class="line">    url &#x27;https://oss.sonatype.org/content/repositories/snapshots/&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile &#x27;com.loopj.android:android-async-http:1.5.0-SNAPSHOT&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="androidannotations"><a href="#androidannotations" class="headerlink" title="androidannotations"></a>androidannotations</h3><blockquote><p>一句话介绍：一款基于注解的快速开发框架</p><p>上榜理由：与Butterknife一样基于注解，利用注解快速完成view的初始化，不同的是androidannotations提供了更多的能力：简单的线程模型等；笔者只接触过Butterknife，无法更进一步叙述androidannotations的优势，如果你志在深入了解注解的妙用，可以尝试探索一下！</p></blockquote><p>官网地址：<a href="http://androidannotations.org/">http://androidannotations.org/</a></p><p>github：<a href="https://github.com/androidannotations/androidannotations">https://github.com/androidannotations/androidannotations</a></p><p>作者： WonderCsabo</p><h3 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h3><blockquote><p>一句话介绍:一款基于json解析、生成的框架</p><p>上榜理由：从它的名字不难看出，快速是它最大的特性，阿里巴巴的出身保证了代码的质量和优越，9.4k的star数量，也是榜单里第一个出现的中国开源框架，涉及网络的app都会用到json，fastjson值得作为你的首选！</p></blockquote><p>github：<a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a></p><p>作者：alibaba</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.alibaba:fastjson:1.1.58.android&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="Material-Animations"><a href="#Material-Animations" class="headerlink" title="Material-Animations"></a>Material-Animations</h3><blockquote><p>一句话介绍：一款提供场景转换过渡能力的动画框架</p><p>上榜理由：Android动画框架排行榜第二名，9.3k个star数量，与动画框架榜单第一名lottie-android不同的是，Material-Animations提供的是场景切换的动画效果。Android 官网sample中已经提供了部分Transition （转场动画）的展示，作为初学者很难快速拓展到自己项目中，Material-Animations的示例出现为开发者省去了此类麻烦，直接照搬应用到自己的App中吧。</p></blockquote><p>github：<a href="https://github.com/lgvalle/Material-Animations">https://github.com/lgvalle/Material-Animations</a></p><p>作者：Luis G. Valle</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">down源码，修改学习</span><br></pre></td></tr></table></figure></p><h3 id="tinker"><a href="#tinker" class="headerlink" title="tinker"></a>tinker</h3><blockquote><p>一句话介绍：它是微信官网的Android热补丁解决方案</p><p>上榜理由：9.1k个star，微信在用的热补丁方案，心动不如行动</p></blockquote><p>官网地址：<a href="http://www.tinkerpatch.com/Docs/intro">http://www.tinkerpatch.com/Docs/intro</a></p><p>github：<a href="https://github.com/Tencent/tinker">https://github.com/Tencent/tinker</a></p><p>作者：Tencent</p><h3 id="ViewPagerIndicator"><a href="#ViewPagerIndicator" class="headerlink" title="ViewPagerIndicator"></a>ViewPagerIndicator</h3><blockquote><p>一句话介绍：一款基于ViewPager的页面指示器开源框架</p><p>上榜理由：上古神器，尽管已经五年未更新了，但你仍然可以在淘宝等app中看到它的使用场景，8.9K的star量让它不愠不火的在矗立在榜单里</p></blockquote><p>官网地址：<a href="http://viewpagerindicator.com/">http://viewpagerindicator.com/</a></p><p>github：<a href="https://github.com/JakeWharton/ViewPagerIndicator">https://github.com/JakeWharton/ViewPagerIndicator</a></p><p>作者：JakeWharton </p><p>使用：</p><p>下载地址 <a href="https://github.com/JakeWharton/Android-ViewPagerIndicator/zipball/master">JakeWharton-ViewPagerIndicator-2.4.1-0</a> </p><h3 id="Android-CleanArchitecture"><a href="#Android-CleanArchitecture" class="headerlink" title="Android-CleanArchitecture"></a>Android-CleanArchitecture</h3><blockquote><p>一句话介绍：一个讲解设计框架的demo</p><p>上榜理由：它不是框架，你可以把它当作一本书，它将教会你如何设计简洁的架构，工程里有一个sample app，配合图文讲解，你将对Android客户端的架构有更深一层的认识。8.8k的star数量，证明了它是一本“好书”哟。</p></blockquote><p>github：<a href="https://github.com/android10/Android-CleanArchitecture">https://github.com/android10/Android-CleanArchitecture</a></p><p>作者：Fernando Cejas</p><h3 id="Android-PullToRefresh"><a href="#Android-PullToRefresh" class="headerlink" title="Android-PullToRefresh"></a>Android-PullToRefresh</h3><blockquote><p>一句话介绍：一款为普通视图提供刷新UI的视图框架</p><p>上榜理由：8.2K的star数量使它位居刷新类UI框架榜首，强大的兼容能力，该框架支持ListView，GrdiView，WebViewScrollView，ViewPager等众多View增加刷新的能力，如果你有增加上拉加载，下拉加载的需求，你应该考虑它了！</p></blockquote><p>github：<a href="https://github.com/chrisbanes/Android-PullToRefresh">https://github.com/chrisbanes/Android-PullToRefresh</a></p><p>作者：Chris Banes</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github：fork源码，集成到项目中</span><br></pre></td></tr></table></figure></p><h3 id="flexbox-layout"><a href="#flexbox-layout" class="headerlink" title="flexbox-layout"></a>flexbox-layout</h3><blockquote><p>一句话介绍：一款弹性伸缩布局</p><p>上榜理由：8.1k个star，前端H5开发者转Android开发的福音，FlexboxLayout作为LinearLayout和RelativeLayout的替代者，值得各位一试，与其一同推出的还有ConstraintLayout。</p></blockquote><p>github：<a href="https://github.com/google/flexbox-layout">https://github.com/google/flexbox-layout</a></p><p>作者：Google</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.google.android:flexbox:0.3.0-alpha3&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="AndroidSwipeLayout"><a href="#AndroidSwipeLayout" class="headerlink" title="AndroidSwipeLayout"></a>AndroidSwipeLayout</h3><blockquote><p>一句话介绍：非常强大滑动式布局</p><p>上榜理由:滑动删除是国产app常见需求，商品详情的上下滑动需求作为开发者的我们也经常遇到，AndroidSwipeLayout在github上拥有8K个star，证明它经受住了检验，各位值得一试</p></blockquote><p>github：<a href="https://github.com/daimajia/AndroidSwipeLayout">https://github.com/daimajia/AndroidSwipeLayout</a></p><p>作者：daimajia</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.android.support:recyclerview-v7:21.0.0&#x27;</span><br><span class="line">    compile &#x27;com.android.support:support-v4:20.+&#x27;</span><br><span class="line">    compile &quot;com.daimajia.swipelayout:library:1.2.0@aar&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>或下载 <a href="https://github.com/daimajia/AndroidSwipeLayout/releases/download/v1.1.8/AndroidSwipeLayout-v1.1.8.jar">AndroidSwipeLayout-v1.1.8.jar</a></p><h3 id="realm-java"><a href="#realm-java" class="headerlink" title="realm-java"></a>realm-java</h3><blockquote><p>一句话介绍：Realm是一款移动端数据库框架</p><p>上榜理由：核心数据引擎C++打造，比普通的Sqlite型数据库快的多。笔者猜测正是如此，realm以7892个star数让它位于大名鼎鼎的数据库框架GreenDao（7877）之前</p></blockquote><p>官网地址：<a href="https://realm.io/cn/">https://realm.io/cn/</a></p><p>github：<a href="https://github.com/realm/realm-java">https://github.com/realm/realm-java</a></p><p>作者：Realm团队 </p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://realm.io/docs/java/latest/</span><br></pre></td></tr></table></figure></p><h3 id="greenDAO"><a href="#greenDAO" class="headerlink" title="greenDAO"></a>greenDAO</h3><blockquote><p>一句话介绍：greenDAO是一款高效、快速的SQLite型数据库</p><p>上榜理由：greenDAO的star数量与Realm不相上下，且与EventBus师出同门，也是由greenrobot团队开发维护的，质量有所保证，但若拷问笔者Realm与greenDao两者的优劣性，只能具体到实际使用当中，模拟线上的使用情形，进行高强度测试后才能下判断，故在此不能一言两语说完，深表遗憾</p></blockquote><p>官网地址：<a href="http://greenrobot.org/greendao/">http://greenrobot.org/greendao/</a></p><p>github：<a href="https://github.com/greenrobot/greenDAO">https://github.com/greenrobot/greenDAO</a></p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral() // add repository</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#x27;com.android.tools.build:gradle:2.3.1&#x27;</span><br><span class="line">        classpath &#x27;org.greenrobot:greendao-gradle-plugin:3.2.2&#x27; // add plugin</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">apply plugin: &#x27;com.android.application&#x27;</span><br><span class="line">apply plugin: &#x27;org.greenrobot.greendao&#x27; // apply plugin</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;org.greenrobot:greendao:3.2.2&#x27; // add library</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="stetho"><a href="#stetho" class="headerlink" title="stetho"></a>stetho</h3><blockquote><p>一句话介绍：一款提供在Chrome开发者工具上调试Android app能力的开源框架</p><p>上榜理由：上古时期Android程序员要调试本地数据库，需要进入Android Device Monitor找到/data/data/com.xxx.xxx/databases里面的db文件，导出到PC端，用PC的数据工具查看，现在使用stetho省却了如此的麻烦；如今的Android程序员如果想调试网络请求响应过程中的报文段，需要在请求中加入Log语句，一个信息一个信息打印出来，相当繁琐，现在请使用stetho，省却诸如此类的麻烦把！7.8K个star数，广大Android开发者调试的福音，你值得拥有！</p></blockquote><p>作者：FaceBook</p><p>官网地址： <a href="http://facebook.github.io/stetho/">http://facebook.github.io/stetho/</a></p><p>github：<a href="https://github.com/facebook/stetho">https://github.com/facebook/stetho</a></p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.facebook.stetho:stetho:1.5.0&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="BaseRecyclerViewAdapterHelper"><a href="#BaseRecyclerViewAdapterHelper" class="headerlink" title="BaseRecyclerViewAdapterHelper"></a>BaseRecyclerViewAdapterHelper</h3><blockquote><p>一句话介绍：强大、流畅的Recyvlerview通用适配器</p><p>上榜理由：如果你是RecyclerView的拥簇者，你一定要体验这款专门服务该view的适配器，7.7K个star，让这个家伙位于github上Android 适配器排行榜第一，还有很多惊喜等你去探寻！</p></blockquote><p>官网地址：<a href="http://www.recyclerview.org/">http://www.recyclerview.org/</a></p><p>作者：陈宇明以及他的小伙伴</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">        compile &#x27;com.github.CymChad:BaseRecyclerViewAdapterHelper:VERSION_CODE&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="AndroidViewAnimations"><a href="#AndroidViewAnimations" class="headerlink" title="AndroidViewAnimations"></a>AndroidViewAnimations</h3><blockquote><p>一句话介绍：一款提供可爱动画集合的框架</p><p>上榜理由：正如作者所说，它囊括了开发需求过程中所有的动画效果，集成进了这个简洁可爱的动画框架。7.6K的star数，证明了它在动画框架领域的战斗力，让它仅仅位列lottie-android和Material-Animations两个动画框架霸主之后，屈居第三名</p></blockquote><p>github：<a href="https://github.com/daimajia/AndroidViewAnimations">https://github.com/daimajia/AndroidViewAnimations</a></p><p>作者：daimajia</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &#x27;com.android.support:support-compat:25.1.1&#x27;</span><br><span class="line">        compile &#x27;com.daimajia.easing:library:2.0@aar&#x27;</span><br><span class="line">        compile &#x27;com.daimajia.androidanimations:library:2.2@aar&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sample：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YoYo.with(Techniques.Tada)</span><br><span class="line">    .duration(700)</span><br><span class="line">    .repeat(5)</span><br><span class="line">    .playOn(findViewById(R.id.edit_area));</span><br></pre></td></tr></table></figure></p><h3 id="MaterialDrawer"><a href="#MaterialDrawer" class="headerlink" title="MaterialDrawer"></a>MaterialDrawer</h3><blockquote><p>一句话介绍：强大的塑料风格的抽屉框架</p><p>上榜理由：7.6K的star数量，作者的持续更新状态，如果你还在犹豫上手SlidingMenu遇到bug没人管的困境，那么你可以入手它作为你的抽屉布局 </p></blockquote><p>github：<a href="https://github.com/mikepenz/MaterialDrawer">https://github.com/mikepenz/MaterialDrawer</a></p><p>作者：Mike Penz</p><p>使用:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compile(&#x27;com.mikepenz:materialdrawer:5.9.2@aar&#x27;) &#123;</span><br><span class="line">    transitive = true</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">new DrawerBuilder().withActivity(this).build();</span><br></pre></td></tr></table></figure></p><h3 id="Android-ObservableScrollView"><a href="#Android-ObservableScrollView" class="headerlink" title="Android-ObservableScrollView"></a>Android-ObservableScrollView</h3><blockquote><p>一句话介绍：一款让视图滑动更具有视觉效果的滑动式框架</p><p>上榜理由：7.5K的star数量，证明了它曾经的价值，github上提供了12种滑动效果，你可以用它弥补其他框架的不足，提升你的App体验！</p></blockquote><p>github：<a href="https://github.com/ksoichiro/Android-ObservableScrollView">https://github.com/ksoichiro/Android-ObservableScrollView</a></p><p>作者：Soichiro Kashima</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile com.github.ksoichiro:android-observablescrollview</span><br></pre></td></tr></table></figure></p><h3 id="CircleImageView"><a href="#CircleImageView" class="headerlink" title="CircleImageView"></a>CircleImageView</h3><blockquote><p>一句话介绍：圆角ImageView</p><p>上榜理由：也许你已经听说过无数种展示圆角图片的方法，但如果你不尝试尝试CircleImageView，那么你的知识库会因为少了它黯然失色，有的时候完成需求是开发者优先考虑的，不同实现方法牵扯到的性能差异更值得让人深思，如果你有心在图片性能上有所涉猎，那么CircleImageView绝对不会让你败兴而归。最后别忘了记得去看Romain Guy的建议哟。</p></blockquote><p>github：<a href="https://github.com/hdodenhof/CircleImageView">https://github.com/hdodenhof/CircleImageView</a></p><p>作者：Henning Dodenhof</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    compile &#x27;de.hdodenhof:circleimageview:2.1.0&#x27;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;de.hdodenhof.circleimageview.CircleImageView</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:id=&quot;@+id/profile_image&quot;</span><br><span class="line">    android:layout_width=&quot;96dp&quot;</span><br><span class="line">    android:layout_height=&quot;96dp&quot;</span><br><span class="line">    android:src=&quot;@drawable/profile&quot;</span><br><span class="line">    app:civ_border_width=&quot;2dp&quot;</span><br><span class="line">    app:civ_border_color=&quot;#FF000000&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h3 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h3><blockquote><p>一句话介绍：一款让log日志优雅显示的框架</p><p>上榜理由：logger作为调试框架，并未给出很强大的能力，它最大的亮点是优雅的输出log信息，并且支持多种格式：线程、Json、Xml、List、Map等，如果你整日沉迷于汪洋大海般的log信息不能自拔，logger就是你的指路明灯！6.6k个star让他位列调试框架第二名，屈居facebook的stetho之后</p></blockquote><p>github：<a href="https://github.com/orhanobut/logger">https://github.com/orhanobut/logger</a></p><p>作者：Orhan Obut</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.orhanobut:logger:2.1.1&#x27;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Logger.d(MAP);</span><br><span class="line">Logger.d(SET);</span><br><span class="line">Logger.d(LIST);</span><br><span class="line">Logger.d(ARRAY);</span><br><span class="line">Logger.json(JSON_CONTENT);</span><br><span class="line">Logger.xml(XML_CONTENT);</span><br></pre></td></tr></table></figure></p><h3 id="agera"><a href="#agera" class="headerlink" title="agera"></a>agera</h3><blockquote><p>一句话介绍:一款服务于Android平台的响应式编程框架</p><p>上榜理由：google专门推出一套响应式编程框架服务于Android开发者，相比于之响应式编程框架榜首的 RxJava RxAndroid，它更轻量，两者最大的不同点在于agera基于push event、pull data （VS Rx系列 push data）。</p></blockquote><p>github：<a href="https://github.com/google/agera">https://github.com/google/agera</a></p><p>作者：Google</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.google.android.agera:agera:1.3.0&#x27;</span><br></pre></td></tr></table></figure><br>扩展能力<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.google.android.agera:content:1.3.0&#x27;</span><br><span class="line">compile &#x27;com.google.android.agera:database:1.3.0&#x27;</span><br><span class="line">compile &#x27;com.google.android.agera:net:1.3.0&#x27;</span><br><span class="line">compile &#x27;com.google.android.agera:rvadapter:1.3.0&#x27;</span><br><span class="line">compile &#x27;com.google.android.agera:rvdatabinding:1.3.0&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="BottmBar"><a href="#BottmBar" class="headerlink" title="BottmBar"></a>BottmBar</h3><blockquote><p>一句话介绍：一款底部导航栏视图框架</p><p>上榜理由：底部栏里的王者框架，6.3K的star数量，证明了它的优秀，完全遵循材料设计规范，上手非常方便。如果说缺点，无法设置icon与titile的间距，无法自定义视图的大小等，但这些都可以通过修改源代码解决，笔者献丑也修改了一套符合国内开发者的底部导航框架，即将开源。</p></blockquote><p>github：<a href="https://github.com/roughike/BottomBar">https://github.com/roughike/BottomBar</a></p><p>作者：Iiro Krankka</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.roughike:bottom-bar:2.3.1&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="Calligraphy"><a href="#Calligraphy" class="headerlink" title="Calligraphy"></a>Calligraphy</h3><blockquote><p>一句话介绍：一款自定义字体框架</p><p>上榜理由：如果你还在为一键修改App内所有字体样式而烦恼，6.3K个star的Calligraphy就值得你拥有，它可以同时修改整个整个项目的Textview字体，也可以单独 设置某个Textview的字体，还在等什么，快来试试吧！</p></blockquote><p>github：<a href="https://github.com/chrisjenx/Calligraphy">https://github.com/chrisjenx/Calligraphy</a></p><p>作者：Christopher Jenkins</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;uk.co.chrisjenx:calligraphy:2.3.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="AndroidSlidingUpPanel"><a href="#AndroidSlidingUpPanel" class="headerlink" title="AndroidSlidingUpPanel"></a>AndroidSlidingUpPanel</h3><blockquote><p>一句话介绍：可拖动的滑动面板视图框架</p><p>上榜理由：如果你的项目需要一个可拖拽的滑动式面板（展示某些详情信息，播放音乐，地图信息等），那么推荐你使用它，6.3k个star，来自创业公司umano的作品，证明它是用心推出的杰作</p></blockquote><p>github：<a href="https://github.com/umano/AndroidSlidingUpPanel">https://github.com/umano/AndroidSlidingUpPanel</a></p><p>作者：umano</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compile &#x27;com.sothree.slidinguppanel:library:3.3.1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="AppIntro"><a href="#AppIntro" class="headerlink" title="AppIntro"></a>AppIntro</h3><blockquote><p>一句话介绍：一款提供快速制作欢迎页的框架</p><p>上榜理由：笔者从未把打算把欢迎页框架纳入排行榜当中，作为国内开发者，ViewPager开发App的欢迎页已经是手到擒来的需求，为何一个开源的欢迎页框架会在github上拥有6.3k个star？也许你会不屑一顾，是的，往往就在不屑一顾的瞬间，机遇就悄悄溜走了。</p></blockquote><p>github：<a href="https://github.com/apl-devs/AppIntro">https://github.com/apl-devs/AppIntro</a></p><p>作者：Paolo Rotolo<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        maven &#123; url &#x27;https://jitpack.io&#x27; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">        compile &#x27;com.github.apl-devs:appintro:v4.2.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="recyclerview-animators"><a href="#recyclerview-animators" class="headerlink" title="recyclerview-animators"></a>recyclerview-animators</h3><blockquote><p>一句话介绍：一款为Recyclerview提供扩展动画能力的框架</p><p>上榜理由：有一句老话：如果有天你失去对新事物的兴趣，那就说明你老了。recyclerview已经推出快三年了，还在用listview的人们，是否已经发掘自己渐渐变老；不要灰心，快为你的项目加入recyclerview-animators框架吧，为“自己”加入新鲜的血液和能量！（笔者备注：6.2K个star）</p></blockquote><p>github：<a href="https://github.com/wasabeef/recyclerview-animators">https://github.com/wasabeef/recyclerview-animators</a></p><p>作者；<a href="https://github.com/wasabeef">https://github.com/wasabeef</a></p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  // jCenter</span><br><span class="line">  compile &#x27;jp.wasabeef:recyclerview-animators:2.2.6&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="dagger"><a href="#dagger" class="headerlink" title="dagger"></a>dagger</h3><blockquote><p>一句话介绍：一款通过依赖注入降低程序间耦合的开发框架</p><p>上榜理由：github：上dagger1版本 有6.2k个star ， dagger2版本有7.3k个；由square完成的dagger1版本，到如今google团队接手的dagger2版本，强力开发团队保证了代码在设计上的优越性；如果你想探究Android 领域的设计模式，这也是不错的选择。</p></blockquote><p>官网地址：<a href="https://google.github.io/dagger/">https://google.github.io/dagger/</a></p><p>github：：<a href="https://github.com/google/dagger">https://github.com/google/dagger</a></p><p>作者：google</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile &#x27;com.google.dagger:dagger:2.x&#x27;</span><br><span class="line">  annotationProcessor &#x27;com.google.dagger:dagger-compiler:2.x&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>If you’re using classes in dagger.android you’ll also want to include:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.google.dagger:dagger-android:2.x&#x27;</span><br><span class="line">compile &#x27;com.google.dagger:dagger-android-support:2.x&#x27; </span><br><span class="line">annotationProcessor &#x27;com.google.dagger:dagger-android-processor:2.x&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="Android-Bootstarp"><a href="#Android-Bootstarp" class="headerlink" title="Android-Bootstarp"></a>Android-Bootstarp</h3><blockquote><p>一句话介绍：一款提供在Android应用上实现Bootstrap（web框架）所作出效果的框架</p><p>上榜理由：榜单上第二款响应web技术的Android 端框架，还记得第一名是谁吗——flexbox-layout，作为Android开发者，你有必要去了解Web技术了。5.9k个star，证明它不容小觑</p></blockquote><p>github：<a href="https://github.com/Bearded-Hen/Android-Bootstrap">https://github.com/Bearded-Hen/Android-Bootstrap</a></p><p>作者:Bearded-Hen团队</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   compile &#x27;com.beardedhen:androidbootstrap:&#123;X.X.X&#125;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="RxBinding"><a href="#RxBinding" class="headerlink" title="RxBinding"></a>RxBinding</h3><blockquote><p>一句话介绍：一款提供UI组件事件响应能力的框架</p><p>上榜理由：如果你还未开始RxAndroid 之旅，RxBinding可以作为你的第一站，通过RXBinding，你将理解响应式编程的快乐，让项目里的事件流程更清晰。5.6K个star，RxAndroid作者亲自操刀，快来试用吧！</p></blockquote><p>github：<a href="https://github.com/JakeWharton/RxBinding">https://github.com/JakeWharton/RxBinding</a></p><p>作者：JakeWharton</p><p>Platform bindings:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.jakewharton.rxbinding2:rxbinding:2.0.0&#x27;</span><br><span class="line">&#x27;support-v4&#x27; library bindings:</span><br><span class="line"></span><br><span class="line">compile &#x27;com.jakewharton.rxbinding2:rxbinding-support-v4:2.0.0&#x27;</span><br><span class="line">&#x27;appcompat-v7&#x27; library bindings:</span><br><span class="line"></span><br><span class="line">compile &#x27;com.jakewharton.rxbinding2:rxbinding-appcompat-v7:2.0.0&#x27;</span><br><span class="line">&#x27;design&#x27; library bindings:</span><br><span class="line"></span><br><span class="line">compile &#x27;com.jakewharton.rxbinding2:rxbinding-design:2.0.0&#x27;</span><br><span class="line">&#x27;recyclerview-v7&#x27; library bindings:</span><br><span class="line"></span><br><span class="line">compile &#x27;com.jakewharton.rxbinding2:rxbinding-recyclerview-v7:2.0.0&#x27;</span><br><span class="line">&#x27;leanback-v17&#x27; library bindings:</span><br><span class="line"></span><br><span class="line">compile &#x27;com.jakewharton.rxbinding2:rxbinding-leanback-v17:2.0.0&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="ListViewAnimations"><a href="#ListViewAnimations" class="headerlink" title="ListViewAnimations"></a>ListViewAnimations</h3><blockquote><p>一句话介绍：一款为ListView提供动展示画效果能力的框架</p><p>上榜理由：如果有一天我承认自己老了，我还会排排我的兄弟——ListView，证明我和它一起战斗过。ListViewAnimations的存在就是证明我们这些“老年人”仍有用武之地，也许你有说不出口的难处，无法体会到RecyclerView里动画的快乐，拥有ListViewAnimations，你一样可以骄傲的说，我的孩子（每个item）也有自己的动效啦。（笔者备注 5.6K个star）</p></blockquote><p>github：<a href="https://github.com/nhaarman/ListViewAnimations">https://github.com/nhaarman/ListViewAnimations</a></p><p>作者：nhaarman</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.nhaarman.listviewanimations:lib-core:3.1.0@aar&#x27;</span><br><span class="line">    compile &#x27;com.nhaarman.listviewanimations:lib-manipulation:3.1.0@aar&#x27;</span><br><span class="line">    compile &#x27;com.nhaarman.listviewanimations:lib-core-slh:3.1.0@aar&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="UItimateRecyclerView"><a href="#UItimateRecyclerView" class="headerlink" title="UItimateRecyclerView"></a>UItimateRecyclerView</h3><blockquote><p>一句话介绍：一款提供刷新、加载更多、动画特效等额外能力的RecyclerView框架</p><p>上榜理由：榜单上第三次出现RecyclerView的身影，足以证明RecyclerView的优异性，5.5K个star，框架里所提供众多的能力，如果你是个功利开发者，那么此框架会为你节省很多学习时间，它可以完成多item式布局的大多数需求，值得注意的是，这个项目也是在其他项目的思路上二次开发的。</p></blockquote><p>github：<a href="https://github.com/cymcsg/UltimateRecyclerView">https://github.com/cymcsg/UltimateRecyclerView</a></p><p>作者：MarshalChen</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    compile &#x27;com.marshalchen.ultimaterecyclerview:library:0.7.2&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="uCrop"><a href="#uCrop" class="headerlink" title="uCrop"></a>uCrop</h3><blockquote><p>一句话介绍：一款优雅的图片裁剪框架</p><p>上榜理由：5.3K个star，图片编辑模块单独拎出来也是一款优雅的App。</p></blockquote><p>github：<a href="https://github.com/Yalantis/uCrop">https://github.com/Yalantis/uCrop</a></p><p>作者：Yalantis</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">   repositories &#123;</span><br><span class="line">      jcenter()</span><br><span class="line">      maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compile &#x27;com.github.yalantis:ucrop:2.2.1&#x27; </span><br></pre></td></tr></table></figure></p><h3 id="RxJava-Android-Samples"><a href="#RxJava-Android-Samples" class="headerlink" title="RxJava-Android-Samples"></a>RxJava-Android-Samples</h3><blockquote><p>一句话介绍：一款介绍RxJava使用场景的app</p><p>上榜理由：榜单出现的第一个“仅仅为告诉你如何使用另一个项目”的开源项目，它可以说是RxJava的用例，你想得到的想不到的RxJava用法这里都有，这就是为什么它以5.2k个star矗立在这份榜单里的原因。遗憾自己没有创作这么一个受人追捧的demo？赶快动手写个其他的“XX项目用例吧”</p></blockquote><p>github：<a href="https://github.com/kaushikgopal/RxJava-Android-Samples">https://github.com/kaushikgopal/RxJava-Android-Samples</a></p><p>作者：kaushikgopal</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone到本地慢慢探索吧</span><br></pre></td></tr></table></figure></p><h3 id="AndroidAutoLayout"><a href="#AndroidAutoLayout" class="headerlink" title="AndroidAutoLayout"></a>AndroidAutoLayout</h3><blockquote><p>一句话介绍：一个提供适配能力的框架</p><p>上榜理由：5.2K个star，鸿洋老弟的作品，适合小项目的开发团队，拿到设计MM的px像素设计稿是不是很头疼捏？这个框架一键式搞定你的问题，它有很多的不足，但在追求完美适配的路上，你值得探索和了解它！笔者并不推荐把它应用到已经成熟运行的项目中，毕竟市面上已经有太多的适配解决方案了，适配问题就像是个大杂烩，想炒一盘好菜，就得备好各种佐料（适配小方案），当你把各种小佐料用的炉火纯青的时候，你离美食大厨就不远了。</p></blockquote><p>github：<a href="https://github.com/hongyangAndroid/AndroidAutoLayout">https://github.com/hongyangAndroid/AndroidAutoLayout</a></p><p>作者：张鸿洋</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.zhy:autolayout:1.4.5&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="EffectiveAndroidUI"><a href="#EffectiveAndroidUI" class="headerlink" title="EffectiveAndroidUI"></a>EffectiveAndroidUI</h3><blockquote><p>一句话介绍：一款讲解高效展示UI的教学型App</p><p>上榜理由：编程新手很难对MVC MVP,MVVM等模式有深刻的理解，如果有一个示例型app，那对初学者会有很大裨益，笔者在遇到它时也是相见恨晚。4.8K个star，证明了它经受了广大开发者的考验与审视，其中Effective UI的编程思想更是与Android官方课程里的Effective UI课程不谋而合，并且，此项目还包含了fragment、dagger、主题样式、Butterknife等众多小知识点，作为编程初学者的学习用例再适合不过了</p></blockquote><p>github：<a href="https://github.com/pedrovgs/EffectiveAndroidUI">https://github.com/pedrovgs/EffectiveAndroidUI</a></p><p>作者：Pedro Vicente </p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone项目到本地</span><br></pre></td></tr></table></figure></p><h3 id="Luban"><a href="#Luban" class="headerlink" title="Luban"></a>Luban</h3><blockquote><p>一句话介绍：最接近微信的图片压缩框架</p><p>上榜理由：好的思路总是可以让你大放异彩，Luban仅以图片压缩单一功能，俘获了4.8K个star，证明了它在图片压缩上的造诣，它可能不是最优秀的，但它是让你我最接近伟大的项目</p></blockquote><p>github：<a href="https://github.com/Curzibn/Luban">https://github.com/Curzibn/Luban</a></p><p>作者：Curzibn</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;top.zibin:Luban:1.1.1&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="DroidPlugin"><a href="#DroidPlugin" class="headerlink" title="DroidPlugin"></a>DroidPlugin</h3><blockquote><p>一句话介绍：一款热门的插件化开发框架</p><p>上榜理由：4.8K个star，插件化框架榜单第一名，，360团队出品，框架质量有保证，有成功案例——360手机助手，并且持续维护着<br>github：<a href="https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md">https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md</a></p></blockquote><p>作者：Andy Zhang</p><p>使用:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone项目到本地</span><br></pre></td></tr></table></figure></p><h3 id="otto"><a href="#otto" class="headerlink" title="otto"></a>otto</h3><blockquote><p>一句话介绍:一款老旧且强大的事件总线框架</p><p>上榜理由：4.8K个star，是square团队早先推出的事件响应型框架，淘宝app的事件驱动也是基于此框架封装的，如今square已经建议开发者采用RxJava RxAndroid来代替otto了。但otto仍有与EventBus横向对比的价值，纵向来说，otto与square自家开发的Rx系列框架的差异同样值得开发者们去探究。</p></blockquote><p>github：<a href="https://github.com/square/otto">https://github.com/square/otto</a></p><p>作者：square</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compile &#x27;com.michaelpardo:activeandroid:3.1.0-SNAPSHOT&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="u2020"><a href="#u2020" class="headerlink" title="u2020"></a>u2020</h3><blockquote><p>一句话介绍：一款提供Dagger的高级教学示例的app（额，名字是有点绕）</p><p>上榜理由：4.7K个star，JakeWharton牵头开发的教学类app，教你使用Dagger在其他高级框架的用法，它展示了Dagger与ButterKnife、Retrofit、Moshi、Picasso、Okhttp、RxJava、Timber、Madge、LeakCanar等众多优秀框架结合起来的高级用法，你也可以借鉴到自己的项目当中</p></blockquote><p>github：<a href="https://github.com/JakeWharton/u2020">https://github.com/JakeWharton/u2020</a></p><p>作者：JakeWharton</p><h3 id="buck"><a href="#buck" class="headerlink" title="buck"></a>buck</h3><blockquote><p>一句话介绍：buck是一个快速构建系统</p><p>上榜理由：facebook+google出身的作者，对构建代码的出色理解，加上大型团队的维护，以及增量更新时的快速高效，让buck成为了微信Android团队构建项目的首选，构建大型项目时，它比gradle更快，然而中小公司并不适合此框架，但作为立志在框架设计领域有一番作为的人们，欢迎来一探究竟</p></blockquote><p>官网地址：<a href="https://buckbuild.com/">https://buckbuild.com/</a></p><p>github：<a href="https://github.com/facebook/buck">https://github.com/facebook/buck</a></p><p>作者：facebook</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux or mac system  +docs</span><br></pre></td></tr></table></figure></p><h3 id="PermissionsDispatcher"><a href="#PermissionsDispatcher" class="headerlink" title="PermissionsDispatcher"></a>PermissionsDispatcher</h3><blockquote><p>一句话介绍：一款基于注解的提供解决运行时危险权限方案的框架</p><p>上榜理由：自Android6.0 Google提出危险权限一词起，用户安全性被提到一定的高度，一些运行时对用户较为危险的权限将不再自动被开发者获取，需要经过用户批准，开发者才可以继续使用该权限，如果你曾经被权限问题搞的抓耳挠腮，建议你试试这个框架，它足够解决你的问题</p></blockquote><p>官网地址：<a href="https://hotchemi.github.io/PermissionsDispatcher/">https://hotchemi.github.io/PermissionsDispatcher/</a></p><p>github：<a href="https://github.com/hotchemi/PermissionsDispatcher">https://github.com/hotchemi/PermissionsDispatcher</a></p><p>作者：Shintaro Katafuchi</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  compile(&#x27;com.github.hotchemi:permissionsdispatcher:$&#123;latest.version&#125;&#x27;) &#123;</span><br><span class="line">      exclude module: &quot;support-v13&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  annotationProcessor &#x27;com.github.hotchemi:permissionsdispatcher-processor:$&#123;latest.version&#125;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">  jcenter()</span><br><span class="line">  maven &#123; url &#x27;http://oss.jfrog.org/artifactory/oss-snapshot-local/&#x27; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="android-gif-drawable"><a href="#android-gif-drawable" class="headerlink" title="android-gif-drawable"></a>android-gif-drawable</h3><blockquote><p>一句话介绍:一款提供展示GIF动画能力的视图框架</p><p>上榜理由：据我所查国内著名App——知乎使用了android-gif-drawable，因此证明了它的存在价值，尽管在榜单第十一位介绍了lottie-android直接应用AE动画的示例，但AE设计师不是每个公司都配备的，GIF的存在，就必然存在了展示GIF的需要，它值得你拥有！</p></blockquote><p>github：<a href="https://github.com/koral--/android-gif-drawable">https://github.com/koral--/android-gif-drawable</a></p><p>作者：Karol Wrótniak</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;pl.droidsonroids.gif:android-gif-drawable:1.2.+&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Apktool"><a href="#Apktool" class="headerlink" title="Apktool"></a>Apktool</h3><blockquote><p>一句话介绍：一款反编译apk的工具</p><p>上榜理由：开源的反编译工具，对于志在了解apk逆向破解的诸位，值得拥有，4.5k个star，逆向破解apk神器！</p></blockquote><p>github：<a href="https://github.com/iBotPeaches/Apktool">https://github.com/iBotPeaches/Apktool</a></p><p>官网地址：<a href="https://ibotpeaches.github.io/Apktool/">https://ibotpeaches.github.io/Apktool/</a></p><p>作者：Connor Tumbleson</p><h3 id="dynamic-load-apk"><a href="#dynamic-load-apk" class="headerlink" title="dynamic-load-apk"></a>dynamic-load-apk</h3><blockquote><p>一句话介绍：插件化开发框架</p><p>上榜理由：4.5k个star，位于插件化开发框架第二名（第一名来自360团队），全面的文档介绍让你很快就能上手插件化开发，如果你喜欢大段文字讲解，那么这个项目一定适合你</p></blockquote><p>github：<a href="https://github.com/singwhatiwanna/dynamic-load-apk">https://github.com/singwhatiwanna/dynamic-load-apk</a></p><p>作者：singwhatiwanna</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github上的文档配合作者博客更配哟</span><br></pre></td></tr></table></figure></p><h3 id="atlas"><a href="#atlas" class="headerlink" title="atlas"></a>atlas</h3><blockquote><p>一句话介绍：淘宝推出的组件化开发框架</p><p>上榜理由：淘宝团队所出的精品，atlas框架提供了解耦、组件、动态的开发能力，4.5k个star让他位列组件化开发框架第一名</p></blockquote><p>github：<a href="https://github.com/alibaba/atlas">https://github.com/alibaba/atlas</a></p><p>作者：alibaba</p><h3 id="volley"><a href="#volley" class="headerlink" title="volley"></a>volley</h3><blockquote><p>一句话介绍：google推荐使用的Android端网络请求框架</p><p>上榜理由：4.4k个star，并不是他不够优秀，而是使用volley已经渐渐成为广大开发者的习惯</p></blockquote><p>github：<a href="https://github.com/google/volley（新版volley地址）">https://github.com/google/volley（新版volley地址）</a></p><p>作者：google</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone源码到本地</span><br></pre></td></tr></table></figure></p><h3 id="androidmvp"><a href="#androidmvp" class="headerlink" title="androidmvp"></a>androidmvp</h3><blockquote><p>一句话介绍：一款展示Android端Mvp设计的demo</p><p>上榜理由：榜单里为数不多、仅凭展示某种设计模式就获得4.2K个star的项目，如果你有尝试mvp的打算，androidmvp可以作为你的前哨站<br>github：<a href="https://github.com/antoniolg/androidmvp">https://github.com/antoniolg/androidmvp</a></p></blockquote><p>作者：Antonio Leiva</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone到本地</span><br></pre></td></tr></table></figure></p><h3 id="SwipeBackLayout"><a href="#SwipeBackLayout" class="headerlink" title="SwipeBackLayout"></a>SwipeBackLayout</h3><blockquote><p>一句话介绍:一款可以让你通过滑动手势关闭页面的的框架</p><p>上榜理由：仿微信滑动退出当前聊天界面的效果，提供了activity的滑动关闭能力，通过这种思路，实现fragment的滑动关闭轻而易举;笔者坚持建议诸位clone源码到本地探索一番；4.2k个star证明很多人都喜爱它</p></blockquote><p>github：<a href="https://github.com/ikew0ng/SwipeBackLayout">https://github.com/ikew0ng/SwipeBackLayout</a></p><p>作者：ike_w0ng</p><p>使用:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;me.imid.swipebacklayout.lib:library:1.0.0&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="FlycoTabLayout"><a href="#FlycoTabLayout" class="headerlink" title="FlycoTabLayout"></a>FlycoTabLayout</h3><blockquote><p>一句话介绍：一款可以让作出多种多样指示器效果的框架</p><p>上榜理由：尽管我们没有理由为了给app加入页面指示器功能就集成2.5M的依赖库，但是作为了解viewpager或swip views的指示器设计原理的优秀框架，你值得打开它试试，笔者建议单独拆分所需源码，加入到自己的项目中去。4.1K个star，二次开发的作品，仍然推荐！</p></blockquote><p>github：<a href="https://github.com/H07000223/FlycoTabLayout">https://github.com/H07000223/FlycoTabLayout</a></p><p>作者：Flyco</p><h3 id="android-testing"><a href="#android-testing" class="headerlink" title="android-testing"></a>android-testing</h3><blockquote><p>一句话介绍：一款展示四大自动化测试框架用例的demo（Espresso，UiAutomator，AndroidJunitRunner，JUnit4）</p><p>上榜理由：学习者经常会陷入似懂非懂的境地，如果你有幸学习过Android Testing Support Library site的课程，那么你一定对android的四大测试框架迫不及待，这款demo非常适合你，快来学习这个4.1k个star的明星项目吧</p></blockquote><p>github：<a href="https://github.com/googlesamples/android-testing">https://github.com/googlesamples/android-testing</a></p><p>作者：googlesampes团队</p><h3 id="FileDownloader"><a href="#FileDownloader" class="headerlink" title="FileDownloader"></a>FileDownloader</h3><blockquote><p>一句话介绍：一款高效、稳定、灵活、易用的文件下载引擎</p><p>上榜理由：4.1k证明了它有多受人喜爱，文件下载看似简单的背后暗藏了多少的坑坑点点，我知道你有能力自己实现文件下载功能，但优秀的框架可以提升你的设计编码能力，这款框架可以提升你的实力！</p></blockquote><p>github：<a href="https://github.com/lingochamp/FileDownloader">https://github.com/lingochamp/FileDownloader</a></p><p>作者:LingoChamp团队</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.liulishuo.filedownloader:library:1.5.5&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="JieCaoVideoPlayer"><a href="#JieCaoVideoPlayer" class="headerlink" title="JieCaoVideoPlayer"></a>JieCaoVideoPlayer</h3><blockquote><p>一句话介绍：基于MediaPlayer api——VideoView 的多媒体播放框架</p><p>上榜理由：榜单里第三款多媒体播放框架，它以灵巧的身姿挤入本榜单，精巧是它最大的优点，不到100k，拥有它，你就可以快速开发类似今日头条那样的视频播放效果，4k个star，证明它值得一试</p></blockquote><p>github：<a href="https://github.com/lipangit/JieCaoVideoPlayer">https://github.com/lipangit/JieCaoVideoPlayer</a></p><p>作者：Nathen</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;fm.jiecao:jiecaovideoplayer:5.5.4&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="glide-transformations"><a href="#glide-transformations" class="headerlink" title="glide-transformations"></a>glide-transformations</h3><blockquote><p>一句话介绍：为众多著名图片加载框架提供图片形状变幻能力的框架</p><p>上榜理由：在榜单靠前的部分已经介绍过glide，Picasso，Fresco等图片加载框架，glide-transformations就是一款为他们提供图片变形能力的框架，使用起来非常简单，因此受到了大家的喜爱，github上有3.8K个star</p></blockquote><p>github：<a href="https://github.com/wasabeef/glide-transformations">https://github.com/wasabeef/glide-transformations</a></p><p>作者：Daichi Furiya</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;jp.wasabeef:glide-transformations:2.0.2&#x27;</span><br><span class="line">    // If you want to use the GPU Filters</span><br><span class="line">    compile &#x27;jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Glide里设置变幻效果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this).load(R.drawable.demo)</span><br><span class="line">        .bitmapTransform(new BlurTransformation(context))</span><br><span class="line">        .into((ImageView) findViewById(R.id.image));</span><br></pre></td></tr></table></figure></p><h3 id="android-gpuimage"><a href="#android-gpuimage" class="headerlink" title="android-gpuimage"></a>android-gpuimage</h3><blockquote><p>一句话介绍：一款基于OpenGL的图片渲染引擎</p><p>上榜理由：放下GpuImage在IOS平台的荣誉不谈，Android版的android-gpuimage就提供多达70多种图片渲染效果，你还在好奇美图秀秀是如何实现图片变幻的？有了它，一切都不是问题。如果你是美图工具类的工程师，此框架的建设思路也会对你大有裨益。笔者也是通过android-gpuimage仿造了美图App并俘获女友芳心的，再次为它的实力点赞。ios版+android版一共19k个star，已经证明了它的实力，还在等什么呢？</p></blockquote><p>github：<a href="https://github.com/CyberAgent/android-gpuimage">https://github.com/CyberAgent/android-gpuimage</a></p><p>作者：CyberAgent 团队</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>更多的改造方法，还需要阅读Ios的编程文档，对于有毅力的小伙伴强力推荐！</p><h3 id="RxPermissions"><a href="#RxPermissions" class="headerlink" title="RxPermissions"></a>RxPermissions</h3><blockquote><p>一句话介绍：一款基于RxJava完成权限申请的框架</p><p>上榜理由：榜单里第二款提供权服务的框架，基于RxJava的设计，让你可以专心写业务，3.7K个star已经证明了它的实用价值</p></blockquote><p>github：<a href="https://github.com/tbruyelle/RxPermissions">https://github.com/tbruyelle/RxPermissions</a></p><p>作者：Thomas Bruyelle</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter() // If not already there</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.tbruyelle.rxpermissions:rxpermissions:0.9.4@aar&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>优雅的使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RxPermissions rxPermissions = new RxPermissions(this); </span><br><span class="line"></span><br><span class="line">rxPermissions</span><br><span class="line">    .request(Manifest.permission.CAMERA)</span><br><span class="line">    .subscribe(granted -&gt; &#123;</span><br><span class="line">        if (granted) &#123; // I can control the camera now</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           // Oups permission denied</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><h3 id="freeline"><a href="#freeline" class="headerlink" title="freeline"></a>freeline</h3><blockquote><p>一句话介绍：一款动态替换的编译构建框架</p><p>上榜理由：继Facebook的Buck，Androdi官方的InstRun之后，蚂蚁金服推出了Freeline编译框架，官网宣称Freeline与业内主流构建方式相比仍然有数倍的速度领先;排行有先后，编译速度并不在本榜单排序的考据因素中，因此freeline以3.7个star，暂列编译框架第二名</p></blockquote><p>官网地址：<a href="https://www.freelinebuild.com/">https://www.freelinebuild.com/</a></p><p>github：<a href="https://github.com/alibaba/freeline">https://github.com/alibaba/freeline</a></p><p>作者：alibaba</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#x27;com.antfortune.freeline:gradle:0.8.7&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &#x27;com.antfortune.freeline&#x27;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">File → Settings... → Plugins → Browse repositories →freeline.</span><br></pre></td></tr></table></figure></p><h3 id="RxLifecycle"><a href="#RxLifecycle" class="headerlink" title="RxLifecycle"></a>RxLifecycle</h3><blockquote><p>一句话介绍：一款提供在使用RxJava过程中管理Activity和Fragment生命周期能力的框架</p><p>上榜理由：在榜单靠前的部分，你已经了解RxJava和RxAndroid的强大之处，但部分粗心的开发者因为没有及时取消订阅而产生严重的内存泄漏，不要担心，RxLifecycle可以为你解决难题，在gtihub上拥有3.7K个star，国内知名软件——知乎和淘宝也都在使用它</p></blockquote><p>github：<a href="https://github.com/trello/RxLifecycle">https://github.com/trello/RxLifecycle</a></p><p>作者：trello团队</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone源码到本地</span><br></pre></td></tr></table></figure></p><h3 id="classyshark"><a href="#classyshark" class="headerlink" title="classyshark"></a>classyshark</h3><blockquote><p>一句话介绍：一款可执行文件浏览器</p><p>上榜理由：榜单里继Apktool之后第二款apk逆向工具，如果你喜欢优雅的图形数据展示，那么你一定不能错过他，classyshark可以将破解的结果以图形化展示用户，方便分析，3.7K个star，让它暂列apk逆向工具第二位！</p></blockquote><p>github：<a href="https://github.com/google/android-classyshark">https://github.com/google/android-classyshark</a></p><p>作者：google</p><p>使用：<br>下载地址 <a href="https://github.com/google/android-classyshark/releases">https://github.com/google/android-classyshark/releases</a></p><h3 id="acra"><a href="#acra" class="headerlink" title="acra"></a>acra</h3><blockquote><p>一句话介绍：一款提供记录APP崩溃日志能力的框架</p><p>上榜理由：如果你面临着收集APP崩溃日志的需求，那么acra是个不错的选择。3.7K个star，让acra位列崩溃日志框架排行榜第一名，acra有足够的能力记录线上APP，并且发回服务端，acra也提供了相当棒的崩溃日志统计服务端框架Acralyzer，cralyzer工作在Apache CouchDB之上，所以除了CouchDB之外，没有必要安装任何额外的软件，移动端开发者也可以借此学习服务端的建设，一举两得！</p></blockquote><p>github：<a href="https://github.com/ACRA/acra">https://github.com/ACRA/acra</a></p><p>服务端github：<a href="https://github.com/ACRA/acralyzer">https://github.com/ACRA/acralyzer</a></p><p>作者：acra团队</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没有什么方法比clone源码到本地更方便了</span><br></pre></td></tr></table></figure></p><h3 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h3><blockquote><p>一句话介绍：一款提供磁盘文件缓存管理能力的框架</p><p>上榜理由：3.7k个star并不足以说明DiskLruCache的优秀，仅仅以管理磁盘文件能力单独拎出来成为一个框架，作者需要很大的勇气，很幸运，作者做到了，并且也成为Google官网提倡的缓存  ；如还记得上次做“一键清除缓存”、“查看缓存文件大小”功能是什么时候吗？DiskLruCache一句话就可以搞定！</p></blockquote><p>github：<a href="https://github.com/JakeWharton/DiskLruCache">https://github.com/JakeWharton/DiskLruCache</a></p><p>作者：JakeWharton</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.jakewharton:disklrucache:2.0.2&#x27;</span><br></pre></td></tr></table></figure><br>或者下载 <a href="https://search.maven.org/remote_content?g=com.jakewharton&amp;a=disklrucache&amp;v=LATEST">latest.jar</a></p><h3 id="dexposed"><a href="#dexposed" class="headerlink" title="dexposed"></a>dexposed</h3><blockquote><p>一句话介绍：一款支撑阿里大部分App客户端热修复、线上调试能力的框架</p><p>上榜理由：榜单上再次出现热修复框架的身影，证明App热修复技术的火热，dexposed提供图形化的性能监控、在线热修复bug漏洞、支持AOP编程思想等，不论你是企业热修复技术的设计者还是打算在热修复领域一探究竟的新人，这款框架很适合你。3.5k个star，证明它作为一门技术框架的存在，是多么令人喜爱！</p></blockquote><p>github：<a href="https://github.com/alibaba/dexposed">https://github.com/alibaba/dexposed</a></p><p>作者：alibaba</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile &#x27;com.taobao.android:dexposed:0.1.1@aar&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Litho"><a href="#Litho" class="headerlink" title="Litho"></a>Litho</h3><blockquote><p>一句话介绍：一款提供高效构建UI能力的框架 </p><p>上榜理由：作为一款专门构建UI的框架，Litho高效的地方在于：单独开辟了用于渲染和布局的线程，然后将创建好的组件传递给UI线程去完成最终的渲染，使用更少的视图层级，来提升界面的滚动速度，值得注意的是，它仅支持开发者作出不可改变的UI组件 ,3.5K个star，证明了它在构建UI领域的价值，更多的妙处，期待你亲自去发掘！</p></blockquote><p>github：<a href="https://github.com/facebook/litho">https://github.com/facebook/litho</a></p><p>作者：facebook</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ependencies &#123;</span><br><span class="line">  // ...</span><br><span class="line">  // Litho</span><br><span class="line">  compile &#x27;com.facebook.litho:litho-core:0.3.1&#x27;</span><br><span class="line">  compile &#x27;com.facebook.litho:litho-widget:0.3.1&#x27;</span><br><span class="line">  provided &#x27;com.facebook.litho:litho-annotations:0.3.1&#x27;</span><br><span class="line"></span><br><span class="line">  annotationProcessor &#x27;com.facebook.litho:litho-processor:0.3.1&#x27;</span><br><span class="line"></span><br><span class="line">  // SoLoader</span><br><span class="line">  compile &#x27;com.facebook.soloader:soloader:0.2.0&#x27;</span><br><span class="line"></span><br><span class="line">  // Optional</span><br><span class="line">  // For debugging</span><br><span class="line">  debugCompile &#x27;com.facebook.litho:litho-stetho:0.3.1&#x27;</span><br><span class="line"></span><br><span class="line">  // For integration with Fresco</span><br><span class="line">  compile &#x27;com.facebook.litho:litho-fresco:0.3.1&#x27;</span><br><span class="line"></span><br><span class="line">  // For testing</span><br><span class="line">  testCompile &#x27;com.facebook.litho:litho-testing:0.3.1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mosby"><a href="#mosby" class="headerlink" title="mosby"></a>mosby</h3><blockquote><p>一句话介绍：一款提供构建MVP项目能力的框架</p><p>上榜理由：榜单靠前的部分已经介绍了MVC,MVVM,MVP的框架项目，想必此时你在构建企业项目架构上，选择或者开发一款合适的MVP框架迫在眉睫，mosby可以作为你的第一步参考，你可以封装它，也可以照抄它，无论如何，3.4K个star，证明了它在框架设计上有多受开发者的喜爱</p></blockquote><p>github：<a href="https://github.com/sockeqwe/mosby">https://github.com/sockeqwe/mosby</a></p><p>作者：Hannes Dorfmann</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">  compile &#x27;com.hannesdorfmann.mosby3:mvi:3.0.4&#x27; // Model-View-Intent</span><br><span class="line">  // or</span><br><span class="line">  compile &#x27;com.hannesdorfmann.mosby3:mvp:3.0.4&#x27; // Plain MVP</span><br><span class="line">  // or</span><br><span class="line">  compile &#x27;com.hannesdorfmann.mosby3:viewstate:3.0.4&#x27; // MVP + ViewState support</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="AndResGuard"><a href="#AndResGuard" class="headerlink" title="AndResGuard"></a>AndResGuard</h3><blockquote><p>一句话介绍：一款提供资源文件路径混淆 的工具</p><p>上榜理由：如果你是个对APK大小很敏感的人，那么AndResGuard一定适合你，它的原理类似Java Proguard，但是只针对资源。他会将原本冗长的资源路径变短，例如将res/drawable/wechat变为r/d/a，3.4K个star，证明了在优化APK道路上，你不是一个人在战斗！</p></blockquote><p>github：<a href="https://github.com/shwenzhang/AndResGuard">https://github.com/shwenzhang/AndResGuard</a></p><p>作者：wechat team</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone项目到本地，其实也就是个三两句话的文档</span><br></pre></td></tr></table></figure></p><h3 id="StatusBarUtil"><a href="#StatusBarUtil" class="headerlink" title="StatusBarUtil"></a>StatusBarUtil</h3><blockquote><p>一句话介绍：一款提供设置沉浸式状态栏样式能力的框架</p><p>上榜理由：设计师MM总是抱怨系统状态栏不优雅？那就给她一个完美的沉浸式状态栏。StatusBarUtil可以随心所欲的设置状态栏样式，3.3K个star，足以说明它有多受设计MM的喜爱</p></blockquote><p>github：<a href="https://github.com/laobie/StatusBarUtil">https://github.com/laobie/StatusBarUtil</a></p><p>作者：Jaeger</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.jaeger.statusbarutil:library:1.4.0&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="robolectric"><a href="#robolectric" class="headerlink" title="robolectric"></a>robolectric</h3><blockquote><p>一句话介绍：一款不依赖于Android设备的单元测试框架，</p><p>上榜理由：sample中列举了如何对Android四大组件和常见功能测试的用例，3.2K个star，值得充满好奇心的人尝试</p></blockquote><p>官网地址：<a href="http://robolectric.org/">http://robolectric.org/</a></p><p>github：<a href="https://github.com/robolectric/robolectric">https://github.com/robolectric/robolectric</a></p><p>作者：robolectric</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testCompile &quot;org.robolectric:robolectric:3.3.2&quot;</span><br></pre></td></tr></table></figure></p><h3 id="Fragmentation"><a href="#Fragmentation" class="headerlink" title="Fragmentation"></a>Fragmentation</h3><blockquote><p>一句话介绍:一款提供管理Fragmen嵌套t能力的框架</p><p>上榜理由：对于Activity和Fragment使用，你一定得心应手，但如果要做一套通用的Activity&amp;Fragment嵌套设计，想必你有点手足无措了，Fragmentation可以作为你设计Fragment管理上的第一步，3.2K个star，笔者认为有点名副其实了，项目介绍里说的是Fragment的管理能力，但并未提供Fragment&amp;Activity生命周期、任务栈的管理能力，因此很难直接应用到企业项目当中，但源码当中的设计思路，值得笔者与诸位借鉴，拾人牙慧留有余香！</p></blockquote><p>github：<a href="https://github.com/YoKeyword/Fragmentation">https://github.com/YoKeyword/Fragmentation</a></p><p>作者：YoKey</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// appcompat v7包是必须的</span><br><span class="line">compile &#x27;me.yokeyword:fragmentation:0.10.7&#x27;</span><br><span class="line">// 如果想使用SwipeBack 滑动边缘退出Fragment/Activity功能，请再添加下面的库</span><br><span class="line">// compile &#x27;me.yokeyword:fragmentation-swipeback:0.10.4&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="Small"><a href="#Small" class="headerlink" title="Small"></a>Small</h3><blockquote><p>一句话介绍：轻巧的插件化框架</p><p>上榜理由：作为插件框架榜单的新成员，Small的优点是轻巧，适合作为小团队的插件开发方案，3.1K个star，让它获得了酷狗音乐等著名开发团队的青睐，如果你们的团队想逐步实施插件化开发，Small是个不错的选择！</p></blockquote><p>官网地址：<a href="http://code.wequick.net/Small/cn/cases">http://code.wequick.net/Small/cn/cases</a></p><p>github：<a href="https://github.com/wequick/Small">https://github.com/wequick/Small</a></p><p>作者：wequick 团队</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildscript  &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#x27;net.wequick.tools.build:gradle-small:1.2.0-alpha6&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &#x27;net.wequick.small&#x27;</span><br><span class="line"></span><br><span class="line">small &#123;</span><br><span class="line">    aarVersion = &#x27;1.2.0-alpha6&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="JsBridge"><a href="#JsBridge" class="headerlink" title="JsBridge"></a>JsBridge</h3><blockquote><p>一句话介绍：一款提供WebView和Javascript通信能力的框架</p><p>上榜理由：该框架提供给了允许H5页面调用通过JS调用App方法的能力；3.1K个star，简洁的通讯方式，值得每一个Web\Hybrid App开发者尝试</p></blockquote><p>gtihub <a href="https://github.com/lzyzsd/JsBridge">https://github.com/lzyzsd/JsBridge</a></p><p>作者：hi大头鬼hi</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    // ...</span><br><span class="line">    maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.github.lzyzsd:jsbridge:1.0.4&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="richeditor-android"><a href="#richeditor-android" class="headerlink" title="richeditor-android"></a>richeditor-android</h3><blockquote><p>一句话介绍：一款强大的富文本编辑框架 </p><p>上榜理由：2.8k个star，榜单里第一个为TextView提供扩展能力的框架，你暂时不需要它，但不能不知道它</p></blockquote><p>github：<a href="https://github.com/wasabeef/richeditor-android">https://github.com/wasabeef/richeditor-android</a></p><p>作者：Daichi Furiya</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;jp.wasabeef:richeditor-android:1.2.2&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Transitions-Everywhere"><a href="#Transitions-Everywhere" class="headerlink" title="Transitions-Everywhere"></a>Transitions-Everywhere</h3><blockquote><p>一句话介绍：一款教你正确使用Transitions API（Android 转场动画API）的教学型项目</p><p>上榜理由：你可能还未尝试过Android API的Transitions 框架，可能听过，但却无法做出优雅奇妙的动效——别担心，Transitions-Everywhere正如它的名字一样，它将带你全面体验Transitions 的强大之处</p></blockquote><p>github：<a href="https://github.com/andkulikov/Transitions-Everywhere">https://github.com/andkulikov/Transitions-Everywhere</a></p><p>作者：Andrey Kulikov</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &quot;com.andkulikov:transitionseverywhere:1.7.4&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="android-viewbadger"><a href="#android-viewbadger" class="headerlink" title="android-viewbadger"></a>android-viewbadger</h3><blockquote><p>一句话介绍：能够快速的为Android 视图加入“勋章”能力的框架</p><p>上榜理由：如果说勋章一词听起来陌生，那么显示已读未读个数、小红点标记信息这一类词语你一定不太陌生，笔者相信在诸位实际开发中经常遇到为某些item加入小红点标记的需求，聪明的各位一定有着各种实现方案，为什么不能快速优雅的完成呢？android-viewbadger可以帮你实现，当然，在某些情况下，你需要具备修改源码的能力，以符合设计MM的需求！值得注意的是，这宽项目已经五年没有更新了！</p></blockquote><p>github：<a href="https://github.com/jgilfelt/android-viewbadger">https://github.com/jgilfelt/android-viewbadger</a></p><p>作者：Jeff Gilfelt</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">View target = findViewById(R.id.target_view);</span><br><span class="line">BadgeView badge = new BadgeView(this, target);</span><br><span class="line">badge.setText(&quot;1&quot;);</span><br><span class="line">badge.show();</span><br></pre></td></tr></table></figure></p><h3 id="AndroidWiFiADB"><a href="#AndroidWiFiADB" class="headerlink" title="AndroidWiFiADB"></a>AndroidWiFiADB</h3><blockquote><p>一句话介绍：一款不用数据线也可以让你调试手机设备APP的插件项目</p><p>上榜理由：你是否还在担心测试过程中高强度的拔插数据线对手机电池和USB端口造成终生难以弥补的损害？别担心，有wifi有AndroidWiFiADB，无须数据线也可以调试应用了，更有趣的是，在测试工程师一边拿着手机一边找你聊bug的时候，你已经偷偷在它的手机上修复了bug，深藏功与名！</p></blockquote><p>github：<a href="https://github.com/pedrovgs/AndroidWiFiADB">https://github.com/pedrovgs/AndroidWiFiADB</a></p><p>作者：Pedro Vicente Gómez Sánchez</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Preferences/Settings-&gt;Plugins-&gt;Browse Repositories-&gt;serch AndroidWiFiADB</span><br></pre></td></tr></table></figure></p><h3 id="emojicon"><a href="#emojicon" class="headerlink" title="emojicon"></a>emojicon</h3><blockquote><p>一句话介绍：一款提供在TextView、EdiText展示表情包能力的框架</p><p>上榜理由：2.7k个star，,榜单第二款增强TextView显示能力的框架，这款专为表情包设计，如果你曾经好奇微信、QQ的表情显示是如何做到的？这款框架一定能满足你的求知欲。</p></blockquote><h3 id="packer-ng-plugin"><a href="#packer-ng-plugin" class="headerlink" title="packer-ng-plugin"></a>packer-ng-plugin</h3><blockquote><p>一句话介绍：一款打爆工具插件</p><p>上榜理由：笔者尽力维护榜单涉及范围的全面性，因此引入此插件项目——项目号称完成100个渠道包只需要10秒钟，在市面上各种各样多渠道打包方案的今天，选择一款适合自己团队的，才是上上选择</p></blockquote><p>github：<a href="https://github.com/mcxiaoke/packer-ng-plugin">https://github.com/mcxiaoke/packer-ng-plugin</a></p><p>作者：Xiaoke Zhang</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ......</span><br><span class="line">    dependencies&#123;</span><br><span class="line">    // add packer-ng</span><br><span class="line">        classpath &#x27;com.mcxiaoke.gradle:packer-ng:1.0.9&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">apply plugin: &#x27;packer&#x27; </span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.mcxiaoke.gradle:packer-helper:1.0.9&#x27;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    //...</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">      release &#123;</span><br><span class="line">          // 满足下面两个条件时需要此配置</span><br><span class="line">          // 1. Gradle版本 &gt;= 2.14.1</span><br><span class="line">          // 2. Android Gradle Plugin 版本 &gt;= 2.2.0</span><br><span class="line">          // 作用是只使用旧版签名，禁用V2版签名模式</span><br><span class="line">        v2SigningEnabled false </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="android-priority-jobqueue"><a href="#android-priority-jobqueue" class="headerlink" title="android-priority-jobqueue"></a>android-priority-jobqueue</h3><blockquote><p>一句话介绍：一款提供后台任务管理能力的框架</p><p>上榜理由：如果你是个志在深入研究多线程操作的开发者，这个项目一定不要错过，不论是Activity重新加载、Service使用线程池时的任务优先级和并发问题，都不要担心，Job Manage会照顾优先级，持久性，负载平衡，延迟，网络控制，分组，2.4K个star，优秀的多线程管理能力，况且它依赖的第三方框架很少，值得你一试</p></blockquote><p>github：<a href="https://github.com/yigit/android-priority-jobqueue">https://github.com/yigit/android-priority-jobqueue</a></p><p>作者：Yigit Boyar</p><h3 id="Android-Debug-Database"><a href="#Android-Debug-Database" class="headerlink" title="Android-Debug-Database"></a>Android-Debug-Database</h3><blockquote><p>一句话介绍：一款提供测试App内部数据库能力的框架</p><p>上榜理由：榜单里第二款针对调试数据库的框架，一行代码集成，直接在浏览器增删改查App的数据库，2.3k个star，心动不如行动！</p></blockquote><p>github：<a href="https://github.com/amitshekhariitbhu/Android-Debug-Database">https://github.com/amitshekhariitbhu/Android-Debug-Database</a></p><p>作者：AMIT SHEKHAR</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debugCompile &#x27;com.amitshekhar.android:debug-db:1.0.0&#x27;</span><br><span class="line"></span><br><span class="line">浏览器键入</span><br><span class="line"></span><br><span class="line">http://XXX.XXX.X.XXX:8080</span><br></pre></td></tr></table></figure></p><h3 id="conceal"><a href="#conceal" class="headerlink" title="conceal"></a>conceal</h3><blockquote><p>一句话介绍：一款facebook提供的加密本地大文件的框架</p><p>上榜理由：如果还在担心App内的图片的隐私问题，这款facebook提供的文件加密框架足以解决你的问题，facebook客户端的图片和数据都是使用conceal加密的</p></blockquote><p>官网地址：<a href="http://facebook.github.io/conceal/">http://facebook.github.io/conceal/</a></p><p>github：<a href="https://github.com/facebook/conceal">https://github.com/facebook/conceal</a></p><p>作者：facebook</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone项目到本地/官网下载jar</span><br></pre></td></tr></table></figure></p><h3 id="ARouter"><a href="#ARouter" class="headerlink" title="ARouter"></a>ARouter</h3><blockquote><p>一句话介绍：一款提供服务、页面跳转路由的框架</p><p>上榜理由：正如作者宣称的那样，该框架提供：从外部URL映射到内部页面、跨模块的页面跳转（页面解耦）、拦截跳转过程等能力，还有更多功能等你去发掘，2.1K个star，值得为企业级的框架喝彩</p></blockquote><p>github：<a href="https://github.com/alibaba/ARouter">https://github.com/alibaba/ARouter</a></p><p>作者：alibaba </p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">            arguments = [ moduleName : project.getName() ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    // 替换成最新版本, 需要注意的是api</span><br><span class="line">    // 要与compiler匹配使用，均使用最新版可以保证兼容</span><br><span class="line">    compile &#x27;com.alibaba:arouter-api:x.x.x&#x27;</span><br><span class="line">    annotationProcessor &#x27;com.alibaba:arouter-compiler:x.x.x&#x27;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末&#x27;其他#4&#x27;</span><br><span class="line">// Kotlin配置参考文末&#x27;其他#5&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="MagicaSakura"><a href="#MagicaSakura" class="headerlink" title="MagicaSakura"></a>MagicaSakura</h3><blockquote><p>一句话介绍：一款提供多主题切换能力的框架</p><p>上榜理由：框架所提供的能力，一直是本榜单所看重的，这款由bilibili提供的多主题框架，作为榜单所涉及范围能补充，1.9个star，感谢bilibili团队所作出的贡献！</p></blockquote><p>github：<a href="https://github.com/Bilibili/MagicaSakura">https://github.com/Bilibili/MagicaSakura</a></p><p>作者:Bilibili</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.bilibili:magicasakura:0.1.6@aar&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="CustomActivityOnCrash"><a href="#CustomActivityOnCrash" class="headerlink" title="CustomActivityOnCrash"></a>CustomActivityOnCrash</h3><blockquote><p>一句话介绍：一款当APP crash的时候自动载入某个Activity的框架（而不是显示Unfortunately, X has stopped）</p><p>上榜理由：新奇的创意是榜单所需要的，所以它赢得了1.8K个star；作为开发者应该拥有考虑到各种潜伏的bug的能力，但我们不能总是面面俱到，其他系统端的同事也可能造成程序的意外crash，因此，如何让程序优雅的crash-&gt;重启值得我们思考，这款框架就提供了这种能力</p></blockquote><p>github：<a href="https://github.com/Ereza/CustomActivityOnCrash">https://github.com/Ereza/CustomActivityOnCrash</a></p><p>作者：Eduard Ereza Martínez</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;cat.ereza:customactivityoncrash:2.1.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>添加到 Application class:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line"></span><br><span class="line">    CaocConfig.Builder.create()</span><br><span class="line">        .backgroundMode(CaocConfig.BACKGROUND_MODE_SILENT) </span><br><span class="line">        .enabled(false) //default: true</span><br><span class="line">        .showErrorDetails(false) //default: true</span><br><span class="line">        .showRestartButton(false) //default: true</span><br><span class="line">        .trackActivities(true) //default: false</span><br><span class="line">        .minTimeBetweenCrashesMs(2000) //default: 3000</span><br><span class="line">        .errorDrawable(R.drawable.ic_custom_drawable) //default: bug image</span><br><span class="line">        .restartActivity(YourCustomActivity.class) //default: null (your app&#x27;s launch activity)</span><br><span class="line">        .errorActivity(YourCustomErrorActivity.class) //default: null (default error activity)</span><br><span class="line">        .eventListener(new YourCustomEventListener()) //default: null</span><br><span class="line">        .apply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="XhsEmoticonsKeyboard"><a href="#XhsEmoticonsKeyboard" class="headerlink" title="XhsEmoticonsKeyboard"></a>XhsEmoticonsKeyboard</h3><blockquote><p>一句话介绍：最开心的开源表情解决方案</p><p>上榜理由：如果你还在发愁如何为你的APP自制键盘，那么此框架非常适合你，而且还提供表情包展示能力，1.7个star证明了它的独特。此外作者还附赠了高仿微信键盘，QQ键盘的demo，分享给诸位</p></blockquote><p>github：<a href="https://github.com/w446108264/XhsEmoticonsKeyboard">https://github.com/w446108264/XhsEmoticonsKeyboard</a></p><p>作者：zhongdaxia</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url &quot;https://jitpack.io&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123; </span><br><span class="line">    compile &#x27;com.github.w446108264:XhsEmoticonsKeyboard:2.0.4&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="完整项目"><a href="#完整项目" class="headerlink" title="完整项目"></a>完整项目</h2><h3 id="iosche"><a href="#iosche" class="headerlink" title="iosche"></a>iosche</h3><blockquote><p>一句话介绍：谷歌2016开发者大会的展示项目</p><p>上榜理由：github上有13.4k个star，位居企业级项目排行榜第一位，牛逼的开发者，权威的设计模式，标准的项目写法，值得一试；笔者建议初学者down下源码，找到app入口，每个页面走一通，配合设计模式的概念加深理解。</p></blockquote><p>github：<a href="https://github.com/google/iosched">https://github.com/google/iosched</a></p><p>作者： Google</p><h3 id="Plaid"><a href="#Plaid" class="headerlink" title="Plaid"></a>Plaid</h3><blockquote><p>一句话介绍：提供设计新闻和灵感的开源app</p><p>上榜理由：标准的material design设计，新闻类app，github上9k的star量值得你摒弃市面上参差不齐的新闻app，快点下手研究它吧！</p></blockquote><p>github：<a href="https://github.com/nickbutcher/plaid">https://github.com/nickbutcher/plaid</a></p><p>作者： Nick Butcher</p><h3 id="PocketHub"><a href="#PocketHub" class="headerlink" title="PocketHub"></a>PocketHub</h3><blockquote><p>一句话介绍：Github的Android版</p><p>上榜理由：8.7K的star数量，Github的亲生儿子，开放的源码值得各位一探究竟</p></blockquote><p>github：<a href="https://github.com/pockethub/PocketHub">https://github.com/pockethub/PocketHub</a></p><p>作者：Fadil Sutomo</p><h3 id="Signal-Android"><a href="#Signal-Android" class="headerlink" title="Signal Android"></a>Signal Android</h3><blockquote><p>一句话介绍：Signal是一款安全通讯的短信类app，</p><p>上榜理由：7.9K的star数量，工具类app的标签属性，让它在排行榜中独一无二，如果你对短信app有兴趣，可以深入探究一番</p></blockquote><p>github：<a href="https://github.com/WhisperSystems/Signal-Android">https://github.com/WhisperSystems/Signal-Android</a></p><p>作者：WhisperSystems</p><h3 id="android-UniversalMusicPlayer"><a href="#android-UniversalMusicPlayer" class="headerlink" title="android-UniversalMusicPlayer"></a>android-UniversalMusicPlayer</h3><blockquote><p>一句话介绍：一款跨设备运行的多媒体app</p><p>上榜理由：googlesamples良心推荐，github拥有7.9k个star，可以在Android手机，汽车，平板，穿戴设备上使用，对于仅仅体验过Android手机开发的程序员，会不会很新奇呢？你值得一试！</p></blockquote><p>github：<a href="https://github.com/googlesamples/android-UniversalMusicPlayer">https://github.com/googlesamples/android-UniversalMusicPlayer</a></p><p>作者：Google</p><h3 id="HomeMirror"><a href="#HomeMirror" class="headerlink" title="HomeMirror"></a>HomeMirror</h3><blockquote><p>一句话介绍：如果你是个爱美的家伙那么你一定需要这面镜子！</p><p>上榜理由：工具类App很难再github上有一席之地，除非它提供特别新奇的功能，比如HomeMirror，github上有用7599个star，仅仅因为它提供了镜子的功能。从现在起，Android 手机、pad，都将成为你旅游居家神器，值得拥有！</p></blockquote><p>github：<a href="https://github.com/HannahMitt/HomeMirror">https://github.com/HannahMitt/HomeMirror</a></p><p>作者：Hannah Mittens </p><p>HomeMirror初体验：<br><img src="http://dinson-blog.hdinson.cn/FiiUDY6BeK1y7xkiXJQnY8jV8dM8.png" alt=""></p><h3 id="ExoPlayer"><a href="#ExoPlayer" class="headerlink" title="ExoPlayer"></a>ExoPlayer</h3><blockquote><p>一句话介绍：一款 替代Android原生MediaPlayer的媒体播放器</p><p>上榜理由：也许是Google对自家MediaPlayer API不甚满意，所以诞生了ExoPlayer，ExoPlayer提供了强大的扩展API，使用它来制作多媒体播放器更快捷，更容易扩展，对多媒体播放器感兴趣的同仁们可以用它来大展身手了！6.9K个star，证明它有多受开发者们喜爱，更难能可贵的是，google还在更新维护着！</p></blockquote><p>官网地址：<a href="https://google.github.io/ExoPlayer/">https://google.github.io/ExoPlayer/</a></p><p>github：<a href="https://github.com/google/ExoPlayer">https://github.com/google/ExoPlayer</a></p><p>作者：google</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line">compile &#x27;com.google.android.exoplayer:exoplayer:r2.X.X&#x27;</span><br><span class="line"></span><br><span class="line">compile &#x27;com.google.android.exoplayer:exoplayer-core:r2.X.X&#x27;</span><br><span class="line">compile &#x27;com.google.android.exoplayer:exoplayer-dash:r2.X.X&#x27;</span><br><span class="line">compile &#x27;com.google.android.exoplayer:exoplayer-ui:r2.X.X&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="cheesesquare"><a href="#cheesesquare" class="headerlink" title="cheesesquare"></a>cheesesquare</h3><blockquote><p>一句话介绍：Android 材料设计的展示性项目</p><p>上榜理由:作者被称为是Android Support Lib背后的男人，他写出的展示性项目，怎能不推荐上榜？材料设计已经炒了好几年了，但作为最权威的展示项目，你一定需要它，6.7个star证明了它是多么的受欢迎。</p></blockquote><p>github：<a href="https://github.com/chrisbanes/cheesesquare">https://github.com/chrisbanes/cheesesquare</a></p><p>作者：Chris Banes</p><h3 id="DanmakuFlameMaster"><a href="#DanmakuFlameMaster" class="headerlink" title="DanmakuFlameMaster"></a>DanmakuFlameMaster</h3><blockquote><p>一句话介绍：android端开源弹幕引擎</p><p>上榜理由：bilibili出品，保证了它的纯种品质，并且ndk源码也一并开源，可谓业界良心，该弹幕引擎的开源节省了很多视频直播小伙伴的开发成本，笔者强力推荐！</p></blockquote><p>github：<a href="https://github.com/Bilibili/DanmakuFlameMaster">https://github.com/Bilibili/DanmakuFlameMaster</a></p><p>作者：bilibili</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#x27;com.github.ctiao:DanmakuFlameMaster:0.8.3&#x27;</span><br><span class="line">    compile &#x27;com.github.ctiao:ndkbitmap-armv7a:0.8.3&#x27;</span><br><span class="line"></span><br><span class="line">    # Other ABIs: optional</span><br><span class="line">    compile &#x27;com.github.ctiao:ndkbitmap-armv5:0.8.3&#x27;</span><br><span class="line">    compile &#x27;com.github.ctiao:ndkbitmap-x86:0.8.3&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="facebook-android-sdk"><a href="#facebook-android-sdk" class="headerlink" title="facebook-android-sdk"></a>facebook-android-sdk</h3><blockquote><p>一句话介绍：一款提供接入facebook平台能力的框架</p><p>上榜理由：无论是你有接入facebook的需求，还是有学习自制sdk的需求，这都是很棒的途径；如何开发一套企业级sdk，是进阶优秀开发工程师的必须之路，4.1k个star，facebook持久更新质量保证，你值得拥有！</p></blockquote><p>github：<a href="https://github.com/facebook/facebook-android-sdk">https://github.com/facebook/facebook-android-sdk</a></p><p>作者：facebook</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developers.facebook.com/docs/android</span><br></pre></td></tr></table></figure></p><h3 id="android-oss"><a href="#android-oss" class="headerlink" title="android-oss"></a>android-oss</h3><blockquote><p>一句话介绍：国外创意社区Kickstarter 开源的Android版客户端</p><p>上榜理由：精致的企业级APP，每个页面处理得都很棒，如果你志在成为一个优雅工程师，这款开源项目一定适合你，3.8k个star证明了它不俗的生命力</p></blockquote><p>github：<a href="https://github.com/kickstarter/android-oss">https://github.com/kickstarter/android-oss</a></p><p>作者：kickstarter</p><h3 id="k-9"><a href="#k-9" class="headerlink" title="k-9"></a>k-9</h3><blockquote><p>一句话介绍：Android端客户端邮件App</p><p>上榜理由：还记得张小龙的成名作——FoxMail吗？如果你想做一款移动端Email App，k-9具有很好的借鉴价值，此外对于应用层协议你也会有更深的认识</p></blockquote><p>官网地址： <a href="https://k9mail.github.io/">https://k9mail.github.io/</a></p><p>github：<a href="https://github.com/k9mail/k-9">https://github.com/k9mail/k-9</a></p><h3 id="Timber"><a href="#Timber" class="headerlink" title="Timber"></a>Timber</h3><blockquote><p>一句话介绍：一款音乐播放器类App</p><p>上榜理由：3K个star，完全按照材料设计规范，提供十几种播放特性，而且还提供App的通用设置能力，这一点做的同样优秀，对于志在提升开发技术的同学值得一试</p></blockquote><p>github：<a href="https://github.com/naman14/Timber">https://github.com/naman14/Timber</a></p><p>作者：Naman Dwivedi</p><h3 id="remusic"><a href="#remusic" class="headerlink" title="remusic"></a>remusic</h3><blockquote><p>一句话介绍：仿网易云音乐Android版App</p><p>上榜理由：学习完Timer，是否还不太满足你的胃口？remusic可以满足你的胃口——它甚至可以拿去直接当上线项目了！2.9K个star，基于Timber的设计（入手的前提是先搞懂Timber）值得入手；有一个问题：如果由你重构，你会如何做呢？</p></blockquote><p>github：<a href="https://github.com/aa112901/remusic">https://github.com/aa112901/remusic</a></p><p>作者：MW</p><h3 id="Douya"><a href="#Douya" class="headerlink" title="Douya"></a>Douya</h3><blockquote><p>一句话介绍：开源豆瓣客户端</p><p>上榜理由：一款功能全面、架构设计不俗的开源APP；仅仅是对豆瓣APP设计思路不满而进行的重构项目，可见作者对产品的痴迷和热爱，2.9K个star，证明该项目并不是头脑发热一时兴起的作品，如果每一个idea都能实现，那我们的世界将会多么美妙！</p></blockquote><p>github：<a href="https://github.com/DreaminginCodeZH/Douya">https://github.com/DreaminginCodeZH/Douya</a></p><p>作者：Zhang Hai</p><h3 id="BookReader"><a href="#BookReader" class="headerlink" title="BookReader"></a>BookReader</h3><blockquote><p>一句话介绍：开源小说阅读器</p><p>上榜理由：2.7K个star，榜单里第一款阅读器APP，具有很高的学习价值（针对有兴趣往阅读工具类方向发展的同学）</p></blockquote><p>github：<a href="https://github.com/JustWayward/BookReader">https://github.com/JustWayward/BookReader</a></p><p>作者：JustWayward 团队</p><h3 id="bilibili-android-client"><a href="#bilibili-android-client" class="headerlink" title="bilibili-android-client"></a>bilibili-android-client</h3><blockquote><p>一句话介绍:高仿bilibili的Android客户端</p><p>上榜理由：2.5K个star，榜单里第一款视频直播开源App；适合对视频直播、社区互动感兴趣的同学；bilibili-android-client里使用了很多大型框架，此项目并不适合基础薄弱的同学，不要灰心，学习页面的布局设计也是值得的！</p></blockquote><p>github：<a href="https://github.com/HotBitmapGG/bilibili-android-client">https://github.com/HotBitmapGG/bilibili-android-client</a></p><p>作者：Hcc</p><h3 id="AndroidChromium"><a href="#AndroidChromium" class="headerlink" title="AndroidChromium"></a>AndroidChromium</h3><blockquote><p>一句话介绍：Android版chrome浏览器</p><p>上榜理由：正如作者宣称的那样:</p><ul><li>谷歌浏览器安卓版源码项目</li><li>世界级的安卓架构</li><li>理清本项目业务逻辑完全可以胜任国内一线公司工程师</li></ul></blockquote><p>github：<a href="https://github.com/JackyAndroid/AndroidChromium">https://github.com/JackyAndroid/AndroidChromium</a></p><p>作者：JackYAndroid</p><h2 id="开发框架：（排名无先后、只按类型划分）"><a href="#开发框架：（排名无先后、只按类型划分）" class="headerlink" title="开发框架：（排名无先后、只按类型划分）"></a>开发框架：（排名无先后、只按类型划分）</h2><h3 id="libgdx"><a href="#libgdx" class="headerlink" title="libgdx"></a>libgdx</h3><blockquote><p>一句话介绍：一款跨平台的android端游戏开发框架</p><p>上榜理由：android端开发框架类第一名，11.7K的star量，游戏框架是它的专属标签，更重要的是它是跨平台的</p></blockquote><p>官网地址：<a href="http://libgdx.badlogicgames.com/">http://libgdx.badlogicgames.com/</a></p><p>github：<a href="https://github.com/libgdx/libgdx">https://github.com/libgdx/libgdx</a></p><h3 id="xUtils"><a href="#xUtils" class="headerlink" title="xUtils"></a>xUtils</h3><blockquote><p>一句话介绍：老牌企业级开发框架</p><p>上榜理由：4.9K个star，xUtils作为上古时期程序员备受推崇的开发框架，最大的原因——省事。xUtls包含四大模块，与之而来的是提供四大操作能力：数据操作、UI操作、Http协议操作、图片操作。xUtils作为笔者初学Android框架设计的导师型项目，在笔者多年经验中，看到xUtils作为众多中小银行Android端框架方案首选，足以证明它的受欢迎程度。该框架现在已经更新到了xUtils3，如果你对Android框架涉及有一定的想法，可以从xUtils入手，进阶为框架大师行列。虽然框架中很多引擎已经过时，各个模块的做法都可以用其他框架替代，但xUtils作为国内开发者的骄傲，上古时期的框架宠儿，值得你拥有！</p></blockquote><p>github：<a href="https://github.com/wyouflf/xUtils">https://github.com/wyouflf/xUtils</a></p><p>作者：wyouflf</p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;org.xutils:xutils:3.5.0&#x27;</span><br></pre></td></tr></table></figure></p><h3 id="android-common"><a href="#android-common" class="headerlink" title="android-common"></a>android-common</h3><blockquote><p>一句话介绍： 一款android快速开发框架</p><p>上榜理由：滴滴资深级Android工程师出品，历经多年开发者的检验，以4.3K屹立于快速开发框架榜第三名，该框架提供了图片缓存、Http缓存、DropDownListView、下载模块、开发常用工具类等，作为上古时期程序员最早的总结性开发框架，它是一代人智慧的结晶，值得我们为作者Trinea鼓掌喝彩</p></blockquote><p>github：<a href="https://github.com/Trinea/android-common">https://github.com/Trinea/android-common</a></p><p>作者：Trinea</p><h3 id="Vitamio"><a href="#Vitamio" class="headerlink" title="Vitamio"></a>Vitamio</h3><blockquote><p>一句话介绍：一款支持跨平台的Android多媒体开发框架</p><p>上榜理由：如果之前提到的exoplayer不能满足你开发多媒体的需求，那我保证vitamio值得你一试</p></blockquote><p>官网地址：<a href="https://www.vitamio.org/">https://www.vitamio.org/</a></p><p>github：<a href="https://github.com/yixia/VitamioBundle">https://github.com/yixia/VitamioBundle</a></p><p>作者：yixia团队</p><h3 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h3><blockquote><p>一句话介绍：移动端跨平台开发的解决方案</p><p>上榜理由：14.4K个star，有成熟应用案例的企业级混合开发框架，阿里巴巴出品，为什么不试试呢？</p></blockquote><p>官网地址：<a href="https://weex.apache.org/cn/">https://weex.apache.org/cn/</a></p><p>github：<a href="https://github.com/alibaba/weex">https://github.com/alibaba/weex</a></p><p>作者：alibaba</p><h3 id="cordova-android（Hybrid-开发框架、WebApp开发框架）"><a href="#cordova-android（Hybrid-开发框架、WebApp开发框架）" class="headerlink" title="cordova-android（Hybrid 开发框架、WebApp开发框架）"></a>cordova-android（Hybrid 开发框架、WebApp开发框架）</h3><blockquote><p>一句话介绍：跨平台的开发框架</p><p>上榜理由：cordova有足够的能力完成混合开发、WebApp开发的需求：不论你是Web开发者，或者是Native开发者，使用cordova都可以作出跨平台的App </p></blockquote><p>官网地址：<a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/overview/index.html">http://cordova.axuer.com/docs/zh-cn/latest/guide/overview/index.html</a></p><p>github：<a href="https://github.com/apache/cordova-android">https://github.com/apache/cordova-android</a></p><h3 id="react-native"><a href="#react-native" class="headerlink" title="react-native"></a>react-native</h3><blockquote><p>一句话介绍：一款以Javascript的语言来操作多个系统语言（Ios、Android）的框架</p><p>上榜理由：很难讲react-native属于什么类别，它适合前端工程师开发移动端App，也适合Native开发者进行跨平台的开发，但对于Navitve开发者来说陡峭的学习曲线会吓走一大批“框架爱好者”；前端界有一句名言：Web代表着未来，Native代表着现在，而我们处在现在与未来的道路上；49K个star，似乎让我们离未来更进一步</p></blockquote><p>官网地址： <a href="http://facebook.github.io/react-native/docs/getting-started.html">http://facebook.github.io/react-native/docs/getting-started.html</a></p><p>github：<a href="https://github.com/facebook/react-native">https://github.com/facebook/react-native</a></p><p>作者：facebook </p><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><h3 id="AndroidUtilCode"><a href="#AndroidUtilCode" class="headerlink" title="AndroidUtilCode"></a>AndroidUtilCode</h3><blockquote><p>一句话介绍：提供了数量庞大的工具类</p><p>上榜理由：10.8K的star个数，足以证明它是多么受欢迎，欢迎你提供常用的工具类壮大它！</p></blockquote><p>github：<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/README-CN.md">https://github.com/Blankj/AndroidUtilCode/blob/master/README-CN.md</a></p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File → Settings... → Plugins → Browse repositories...</span><br></pre></td></tr></table></figure><br>and search for <code>freeline</code>.</p><h3 id="kotiln"><a href="#kotiln" class="headerlink" title="kotiln"></a>kotiln</h3><blockquote><p>一句话介绍：Google推出的Android编程语言</p><p>上榜理由：就像AndroidStudio取代Eclipse那样，Goolg将kotiln作为Android的官网语言，也许是为了避免同Oracle的专利诉讼，但kotlin 100%兼容java，大幅精简java代码量，以及函数式编程的思想这些优异的特性同意值得我们注意，还记得在榜单之前说过的吗？未来是kotlin的，当下是java的，但我们处在当下通往未来的道路上——学习未来的编程语言，提升自己的工作效率，早点下班打豆豆，何乐而不为？</p></blockquote><p>官网地址：<a href="http://kotlinlang.org/">http://kotlinlang.org/</a></p><p>github：<a href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></p><p>使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://kotlinlang.org/docs/reference/   提供了 api-android用例-书籍等资源</span><br></pre></td></tr></table></figure></p><h2 id="书籍类项目（排序无先后）"><a href="#书籍类项目（排序无先后）" class="headerlink" title="书籍类项目（排序无先后）"></a>书籍类项目（排序无先后）</h2><h3 id="Android-developer中国官网培训课程"><a href="#Android-developer中国官网培训课程" class="headerlink" title="Android developer中国官网培训课程"></a>Android developer中国官网培训课程</h3><blockquote><p>一句话介绍：符合中国国情的Google开发者官网的子产品——Android开发者官网</p><p>上榜理由：这里有培训课程、API用例课程、Sample用例、依赖库介绍、AndroidStudio官网…等等一系列公开免费的课程，尽管大部分内容还是英文讲解，可是你肯靠着英语词典一篇一篇啃完，相信我，你的Android知识水平将秒杀国内市面上大部分的Android书籍</p></blockquote><p>官网地址：<a href="https://developer.android.google.cn/training/index.html">https://developer.android.google.cn/training/index.html</a></p><p>作者：google</p><h3 id="android-architecture"><a href="#android-architecture" class="headerlink" title="android-architecture"></a>android-architecture</h3><blockquote><p>一句话介绍：google提供的Android当下各种基本框架</p><p>上榜理由：看完它，mvp，mvvm都将入切瓜砍菜，秋风扫落叶一般…</p></blockquote><p>github：<a href="https://github.com/googlesamples/android-architecture">https://github.com/googlesamples/android-architecture</a></p><p>作者：google</p><h3 id="andorid-open-project"><a href="#andorid-open-project" class="headerlink" title="andorid-open-project"></a>andorid-open-project</h3><blockquote><p>一句话介绍：囊括Android几乎所有的开源项目的导航类目录</p><p>上榜理由：23k个star的导航类目录，与其盛名不符的是，该项目的导航、浏览阅读体验做的非常差，建议消遣之余阅读；推荐理由——中国人做的最全的Android 开源项目导航目录</p></blockquote><p>github：<a href="https://github.com/Trinea/android-open-project">https://github.com/Trinea/android-open-project</a></p><p>作者：Trinea</p><h3 id="awesome-android-ui"><a href="#awesome-android-ui" class="headerlink" title="awesome-android-ui"></a>awesome-android-ui</h3><blockquote><p>一句话介绍：Android的开源项目目录</p><p>上榜理由：国外的一款导航目录，23k个star</p></blockquote><p>github：<a href="https://github.com/wasabeef/awesome-android-ui">https://github.com/wasabeef/awesome-android-ui</a></p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android庶系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排行榜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模仿手机QQ底部导航栏Icon拖拽效果</title>
      <link href="/2017/06/20/17-06-20/"/>
      <url>/2017/06/20/17-06-20/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>实现的方式有很多，我说一下我的思路：我的思路比较简单，无非就是上下两层图片可拖动的范围和速度不一样呗（大图标拖动范围和速度小于小图标拖动范围和速度）。</p></blockquote><p>PS（以第一个消息图标为例）：大图标指的是外面的气泡图标，小图标指的是气泡里面的眼睛和嘴巴图标。切图时将一张整体图片切成了这两个图标。具体可下载Demo参考里面的图片资源。<br>自定义属性</p><span id="more"></span><!-- 这是　　缩进--> <h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;  </span><br><span class="line">    &lt;declare-styleable name=&quot;QQNaviView&quot;&gt;  </span><br><span class="line">        &lt;attr name=&quot;bigIconSrc&quot; format=&quot;reference&quot;/&gt;  </span><br><span class="line">        &lt;attr name=&quot;smallIconSrc&quot; format=&quot;reference&quot;/&gt;  </span><br><span class="line">        &lt;attr name=&quot;iconWidth&quot; format=&quot;dimension&quot;/&gt;  </span><br><span class="line">        &lt;attr name=&quot;iconHeight&quot; format=&quot;dimension&quot;/&gt;  </span><br><span class="line">        &lt;attr name=&quot;range&quot; format=&quot;float&quot;/&gt;  </span><br><span class="line">    &lt;/declare-styleable&gt;  </span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><p> 其中range为可拖动的范围（其实是倍数），默认值是1，不宜设置过大。</p><h2 id="主要的拖动代码"><a href="#主要的拖动代码" class="headerlink" title="主要的拖动代码"></a>主要的拖动代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;  </span><br><span class="line">    float x = event.getX();  </span><br><span class="line">    float y = event.getY();  </span><br><span class="line">    switch (event.getAction())&#123;  </span><br><span class="line">        case MotionEvent.ACTION_DOWN:  </span><br><span class="line">            lastX = x;  </span><br><span class="line">            lastY = y;  </span><br><span class="line">            break;  </span><br><span class="line">        case MotionEvent.ACTION_MOVE:  </span><br><span class="line">            float deltaX = x - lastX;  </span><br><span class="line">            float deltaY = y - lastY;  </span><br><span class="line"></span><br><span class="line">            moveEvent(mBigIcon, deltaX, deltaY, mSmallRadius);  </span><br><span class="line">            //因为可拖动大半径是小半径的1.5倍， 因此这里x,y也相应乘1.5  </span><br><span class="line">            moveEvent(mSmallIcon, 1.5f * deltaX, 1.5f * deltaY, mBigRadius);  </span><br><span class="line">            break;  </span><br><span class="line">        case MotionEvent.ACTION_UP:  </span><br><span class="line">            //抬起时复位  </span><br><span class="line">            mBigIcon.setX(0);  </span><br><span class="line">            mBigIcon.setY(0);  </span><br><span class="line">            mSmallIcon.setX(0);  </span><br><span class="line">            mSmallIcon.setY(0);  </span><br><span class="line">            break;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return super.onTouchEvent(event);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先得到X轴拖动的距离deltaX和Y轴拖动的距离deltaY，大图标对应小半径，小图标对应大半径。然后看moveEvent方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void moveEvent(View view, float deltaX, float deltaY, float radius)&#123;  </span><br><span class="line">  </span><br><span class="line">    //先计算拖动距离  </span><br><span class="line">    float distance = getDistance(deltaX, deltaY);  </span><br><span class="line"></span><br><span class="line">    //拖动的方位角，atan2出来的角度是带正负号的  </span><br><span class="line">    double degree = Math.atan2(deltaY, deltaX);  </span><br><span class="line"></span><br><span class="line">    //如果大于临界半径就不能再往外拖了  </span><br><span class="line">    if (distance &gt; radius)&#123;  </span><br><span class="line">        view.setX(view.getLeft() + (float) (radius * Math.cos(degree)));  </span><br><span class="line">        view.setY(view.getTop() + (float) (radius * Math.sin(degree)));  </span><br><span class="line">    &#125;else &#123;  </span><br><span class="line">        view.setX(view.getLeft() + deltaX);  </span><br><span class="line">        view.setY(view.getTop() + deltaY);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>方法很简单，注释结合这张图就一目了然了，主要是注意在抬起时图标复位就好了。</p><p><img src="http://dinson-blog.hdinson.cn/FnR-HX50f9CT6__4u2VooWRtZLSN.png" alt=""></p><h2 id="简单看一下初始化"><a href="#简单看一下初始化" class="headerlink" title="简单看一下初始化"></a>简单看一下初始化</h2><blockquote><p>由于图标下面一般会带文字，因此直接继承了LinearLayout，并且默认设置成了垂直排列。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public QQNaviView(@NonNull Context context, @Nullable AttributeSet attrs, @AttrRes int defStyleAttr) &#123;  </span><br><span class="line">    super(context, attrs, defStyleAttr);  </span><br><span class="line">  </span><br><span class="line">    mContext = context;  </span><br><span class="line">  </span><br><span class="line">    TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.QQNaviView, defStyleAttr, 0);  </span><br><span class="line">    mBigIconSrc = ta.getResourceId(R.styleable.QQNaviView_bigIconSrc, R.drawable.big);  </span><br><span class="line">    mSmallIconSrc = ta.getResourceId(R.styleable.QQNaviView_smallIconSrc, R.drawable.small);  </span><br><span class="line">    mIconWidth = ta.getDimension(R.styleable.QQNaviView_iconWidth, dp2px(context, 60));  </span><br><span class="line">    mIconHeight = ta.getDimension(R.styleable.QQNaviView_iconHeight, dp2px(context, 60));  </span><br><span class="line">    mRange = ta.getFloat(R.styleable.QQNaviView_range, 1);  </span><br><span class="line">    ta.recycle();  </span><br><span class="line">  </span><br><span class="line">    //默认垂直排列  </span><br><span class="line">    setOrientation(LinearLayout.VERTICAL);  </span><br><span class="line">  </span><br><span class="line">    init(context);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>在init方法中进行了布局文件的绑定，并且让该view水平居中。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void init(Context context) &#123;  </span><br><span class="line">    mView = inflate(context, R.layout.view_icon, null);  </span><br><span class="line">    mBigIcon = (ImageView) mView.findViewById(R.id.iv_big);  </span><br><span class="line">    mSmallIcon = (ImageView) mView.findViewById(R.id.iv_small);  </span><br><span class="line">  </span><br><span class="line">    mBigIcon.setImageResource(mBigIconSrc);  </span><br><span class="line">    mSmallIcon.setImageResource(mSmallIconSrc);  </span><br><span class="line">  </span><br><span class="line">    setWidthAndHeight(mBigIcon);  </span><br><span class="line">    setWidthAndHeight(mSmallIcon);  </span><br><span class="line">  </span><br><span class="line">    LayoutParams lp = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);  </span><br><span class="line">    lp.gravity = Gravity.CENTER_HORIZONTAL;  </span><br><span class="line">    mView.setLayoutParams(lp);  </span><br><span class="line">    addView(mView);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>这里值得注意的是onMeasure方法。由于图标可以往外拖动，所以要给ImageView一个默认的padding，不然拖动时最外面部分会消失。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;  </span><br><span class="line">        setupView();  </span><br><span class="line">        measureDimension(widthMeasureSpec, heightMeasureSpec);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 确定view以及拖动相关参数 </span><br><span class="line">     */  </span><br><span class="line">    private void setupView() &#123;  </span><br><span class="line">  </span><br><span class="line">        //根据view的宽高确定可拖动半径的大小  </span><br><span class="line">        mSmallRadius = 0.1f * Math.min(mView.getWidth(), mView.getHeight()) * mRange;  </span><br><span class="line">        mBigRadius = 1.5f * mSmallRadius;  </span><br><span class="line">  </span><br><span class="line">        //设置imageview的padding，不然拖动时图片边缘部分会消失  </span><br><span class="line">        int padding = (int) mBigRadius;  </span><br><span class="line">        mBigIcon.setPadding(padding, padding, padding, padding);  </span><br><span class="line">        mSmallIcon.setPadding(padding, padding, padding, padding);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后就没啥好说了，直接看源码吧。</p><h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">public class QQNaviView extends LinearLayout &#123;  </span><br><span class="line">  </span><br><span class="line">    private static final String TAG = &quot;QQNaviView&quot;;  </span><br><span class="line">  </span><br><span class="line">    private Context mContext;  </span><br><span class="line">  </span><br><span class="line">    /* 主view */  </span><br><span class="line">    private View mView;  </span><br><span class="line">  </span><br><span class="line">    /* 外层icon/拖动幅度较小icon */  </span><br><span class="line">    private ImageView mBigIcon;  </span><br><span class="line">  </span><br><span class="line">    /* 里层icon/拖动幅度较大icon */  </span><br><span class="line">    private ImageView mSmallIcon;  </span><br><span class="line">  </span><br><span class="line">    /* 外层icon资源 */  </span><br><span class="line">    private int mBigIconSrc;  </span><br><span class="line">  </span><br><span class="line">    /* 里面icon资源 */  </span><br><span class="line">    private int mSmallIconSrc;  </span><br><span class="line">  </span><br><span class="line">    /* icon宽度 */  </span><br><span class="line">    private float mIconWidth;  </span><br><span class="line">  </span><br><span class="line">    /* icon高度 */  </span><br><span class="line">    private float mIconHeight;  </span><br><span class="line">  </span><br><span class="line">    /* 拖动幅度较大半径 */  </span><br><span class="line">    private float mBigRadius;  </span><br><span class="line">  </span><br><span class="line">    /* 拖动幅度小半径 */  </span><br><span class="line">    private float mSmallRadius;  </span><br><span class="line">  </span><br><span class="line">    /* 拖动范围 可调 */  </span><br><span class="line">    private float mRange;  </span><br><span class="line">  </span><br><span class="line">    private float lastX;  </span><br><span class="line">  </span><br><span class="line">    private float lastY;  </span><br><span class="line">  </span><br><span class="line">    public QQNaviView(@NonNull Context context) &#123;  </span><br><span class="line">        this(context, null);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public QQNaviView(@NonNull Context context, @Nullable AttributeSet attrs) &#123;  </span><br><span class="line">        this(context, attrs, 0);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public QQNaviView(@NonNull Context context, @Nullable AttributeSet attrs, @AttrRes int defStyleAttr) &#123;  </span><br><span class="line">        super(context, attrs, defStyleAttr);  </span><br><span class="line">  </span><br><span class="line">        mContext = context;  </span><br><span class="line">  </span><br><span class="line">        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.QQNaviView, defStyleAttr, 0);  </span><br><span class="line">        mBigIconSrc = ta.getResourceId(R.styleable.QQNaviView_bigIconSrc, R.drawable.big);  </span><br><span class="line">        mSmallIconSrc = ta.getResourceId(R.styleable.QQNaviView_smallIconSrc, R.drawable.small);  </span><br><span class="line">        mIconWidth = ta.getDimension(R.styleable.QQNaviView_iconWidth, dp2px(context, 60));  </span><br><span class="line">        mIconHeight = ta.getDimension(R.styleable.QQNaviView_iconHeight, dp2px(context, 60));  </span><br><span class="line">        mRange = ta.getFloat(R.styleable.QQNaviView_range, 1);  </span><br><span class="line">        ta.recycle();  </span><br><span class="line">  </span><br><span class="line">        //默认垂直排列  </span><br><span class="line">        setOrientation(LinearLayout.VERTICAL);  </span><br><span class="line">  </span><br><span class="line">        init(context);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    private void init(Context context) &#123;  </span><br><span class="line">        mView = inflate(context, R.layout.view_icon, null);  </span><br><span class="line">        mBigIcon = (ImageView) mView.findViewById(R.id.iv_big);  </span><br><span class="line">        mSmallIcon = (ImageView) mView.findViewById(R.id.iv_small);  </span><br><span class="line">  </span><br><span class="line">        mBigIcon.setImageResource(mBigIconSrc);  </span><br><span class="line">        mSmallIcon.setImageResource(mSmallIconSrc);  </span><br><span class="line">  </span><br><span class="line">        setWidthAndHeight(mBigIcon);  </span><br><span class="line">        setWidthAndHeight(mSmallIcon);  </span><br><span class="line">  </span><br><span class="line">        LayoutParams lp = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);  </span><br><span class="line">        lp.gravity = Gravity.CENTER_HORIZONTAL;  </span><br><span class="line">        mView.setLayoutParams(lp);  </span><br><span class="line">        addView(mView);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 设置icon宽高 </span><br><span class="line">     * @param view </span><br><span class="line">     */  </span><br><span class="line">    private void setWidthAndHeight(View view)&#123;  </span><br><span class="line">        FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) view.getLayoutParams();  </span><br><span class="line">        lp.width = (int) mIconWidth;  </span><br><span class="line">        lp.height = (int) mIconHeight;  </span><br><span class="line">        view.setLayoutParams(lp);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;  </span><br><span class="line">        setupView();  </span><br><span class="line">        measureDimension(widthMeasureSpec, heightMeasureSpec);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 确定view以及拖动相关参数 </span><br><span class="line">     */  </span><br><span class="line">    private void setupView() &#123;  </span><br><span class="line">  </span><br><span class="line">        //根据view的宽高确定可拖动半径的大小  </span><br><span class="line">        mSmallRadius = 0.1f * Math.min(mView.getWidth(), mView.getHeight()) * mRange;  </span><br><span class="line">        mBigRadius = 1.5f * mSmallRadius;  </span><br><span class="line">  </span><br><span class="line">        //设置imageview的padding，不然拖动时图片边缘部分会消失  </span><br><span class="line">        int padding = (int) mBigRadius;  </span><br><span class="line">        mBigIcon.setPadding(padding, padding, padding, padding);  </span><br><span class="line">        mSmallIcon.setPadding(padding, padding, padding, padding);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    private void measureDimension(int widthMeasureSpec, int heightMeasureSpec) &#123;  </span><br><span class="line">        final int sizeWidth = MeasureSpec.getSize(widthMeasureSpec);  </span><br><span class="line">        final int sizeHeight = MeasureSpec.getSize(heightMeasureSpec);  </span><br><span class="line">        final int modeWidth = MeasureSpec.getMode(widthMeasureSpec);  </span><br><span class="line">        final int modeHeight = MeasureSpec.getMode(heightMeasureSpec);  </span><br><span class="line">        int width = 0;  </span><br><span class="line">        int height = 0;  </span><br><span class="line">        for (int i = 0; i &lt; getChildCount(); i++)&#123;  </span><br><span class="line">            final View child = getChildAt(i);  </span><br><span class="line">            if (child.getVisibility() != GONE)&#123;  </span><br><span class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);  </span><br><span class="line">                LayoutParams lp = (LayoutParams) child.getLayoutParams();  </span><br><span class="line">                final int childWidth = child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin;  </span><br><span class="line">                final int childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;  </span><br><span class="line">                width += childWidth;  </span><br><span class="line">                height += childHeight;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        setMeasuredDimension((modeWidth == MeasureSpec.EXACTLY) ? sizeWidth : width,  </span><br><span class="line">                (modeHeight == MeasureSpec.EXACTLY) ? sizeHeight : height);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;  </span><br><span class="line">        int childLeft;  </span><br><span class="line">        int childTop = 0;  </span><br><span class="line">        for (int i = 0; i &lt; getChildCount(); i ++)&#123;  </span><br><span class="line">            final View child = getChildAt(i);  </span><br><span class="line">            LayoutParams lp = (LayoutParams) child.getLayoutParams();  </span><br><span class="line">            if (child.getVisibility() != GONE)&#123;  </span><br><span class="line">                final int childWidth = child.getMeasuredWidth();  </span><br><span class="line">                final int childHeight = child.getMeasuredHeight();  </span><br><span class="line">                //水平居中显示  </span><br><span class="line">                childLeft = (getWidth() - childWidth) / 2;  </span><br><span class="line">                //当前子view的top  </span><br><span class="line">                childTop += lp.topMargin;  </span><br><span class="line">                child.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight);  </span><br><span class="line">                //下一个view的top是当前子view的top + height + bottomMargin  </span><br><span class="line">                childTop += childHeight + lp.bottomMargin;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;  </span><br><span class="line">        float x = event.getX();  </span><br><span class="line">        float y = event.getY();  </span><br><span class="line">        switch (event.getAction())&#123;  </span><br><span class="line">            case MotionEvent.ACTION_DOWN:  </span><br><span class="line">                lastX = x;  </span><br><span class="line">                lastY = y;  </span><br><span class="line">                break;  </span><br><span class="line">            case MotionEvent.ACTION_MOVE:  </span><br><span class="line">                float deltaX = x - lastX;  </span><br><span class="line">                float deltaY = y - lastY;  </span><br><span class="line">  </span><br><span class="line">                moveEvent(mBigIcon, deltaX, deltaY, mSmallRadius);  </span><br><span class="line">                //因为可拖动大半径是小半径的1.5倍， 因此这里x,y也相应乘1.5  </span><br><span class="line">                moveEvent(mSmallIcon, 1.5f * deltaX, 1.5f * deltaY, mBigRadius);  </span><br><span class="line">                break;  </span><br><span class="line">            case MotionEvent.ACTION_UP:  </span><br><span class="line">                //抬起时复位  </span><br><span class="line">                mBigIcon.setX(0);  </span><br><span class="line">                mBigIcon.setY(0);  </span><br><span class="line">                mSmallIcon.setX(0);  </span><br><span class="line">                mSmallIcon.setY(0);  </span><br><span class="line">                break;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return super.onTouchEvent(event);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 拖动事件 </span><br><span class="line">     * @param view </span><br><span class="line">     * @param deltaX </span><br><span class="line">     * @param deltaY </span><br><span class="line">     * @param radius </span><br><span class="line">     */  </span><br><span class="line">    private void moveEvent(View view, float deltaX, float deltaY, float radius)&#123;  </span><br><span class="line">  </span><br><span class="line">        //先计算拖动距离  </span><br><span class="line">        float distance = getDistance(deltaX, deltaY);  </span><br><span class="line">  </span><br><span class="line">        //拖动的方位角，atan2出来的角度是带正负号的  </span><br><span class="line">        double degree = Math.atan2(deltaY, deltaX);  </span><br><span class="line">  </span><br><span class="line">        //如果大于临界半径就不能再往外拖了  </span><br><span class="line">        if (distance &gt; radius)&#123;  </span><br><span class="line">            view.setX(view.getLeft() + (float) (radius * Math.cos(degree)));  </span><br><span class="line">            view.setY(view.getTop() + (float) (radius * Math.sin(degree)));  </span><br><span class="line">        &#125;else &#123;  </span><br><span class="line">            view.setX(view.getLeft() + deltaX);  </span><br><span class="line">            view.setY(view.getTop() + deltaY);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    private int dp2px(Context context, float dpVal) &#123;  </span><br><span class="line">        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,  </span><br><span class="line">                dpVal, context.getResources().getDisplayMetrics());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    private float getDistance(float x, float y)&#123;  </span><br><span class="line">        return (float) Math.sqrt(x * x + y * y);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void setBigIcon(int res)&#123;  </span><br><span class="line">        mBigIcon.setImageResource(res);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void setSmallIcon(int res)&#123;  </span><br><span class="line">        mSmallIcon.setImageResource(res);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void setIconWidthAndHeight(float width, float height)&#123;  </span><br><span class="line">        mIconWidth = dp2px(mContext, width);  </span><br><span class="line">        mIconHeight = dp2px(mContext, height);  </span><br><span class="line">        setWidthAndHeight(mBigIcon);  </span><br><span class="line">        setWidthAndHeight(mSmallIcon);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void setRange(float range)&#123;  </span><br><span class="line">        mRange = range;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>bigIconSrc</td><td>大图标资源</td></tr><tr><td>smallIconSrc</td><td>小图标资源</td></tr><tr><td>iconWidth</td><td>图标宽度</td></tr><tr><td>iconHeight</td><td>图标高度</td></tr><tr><td>range</td><td>可拖动范围</td></tr></tbody></table></div><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义VIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splash 页面三秒跳转和动态下载最新背景图</title>
      <link href="/2017/06/18/17-06-18/"/>
      <url>/2017/06/18/17-06-18/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>最近公司产品大大说我们需要一个动态替换的闪屏页面，like 某猫，某东一样，可以动态替换。<br>产品大大就是厉害，说一句话我们就需要实现好几个功能：</p><ol><li>创建一个冷启动后的闪屏页面（Splash 页面）</li><li>这个页面默认 3s 倒计时，点击倒计时按钮可以跳转并结束倒计时</li><li>点击图片如果有外链，则跳转应用的 web 页面用来作为活动页面（没错这点和某猫很像）</li><li>动态替换厉害了，我们需要在进入这个页面后去后台请求一下是否有新的图片，如果是新的图片则下载到本地，替换掉原来的图片，下次用户在进入 Splash 就会看到一个崭新的图片。</li></ol></blockquote><p><img src="http://dinson-blog.hdinson.cn/FvIf_0HDYO6ORF0G4pp-wLu1Fghp.png" alt=""></p><span id="more"></span><!-- 这是　　缩进--><h2 id="布局实现"><a href="#布局实现" class="headerlink" title="布局实现"></a>布局实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">             android:layout_width=&quot;match_parent&quot;</span><br><span class="line">             android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/sp_bg&quot;</span><br><span class="line">        android:src=&quot;@mipmap/icon_splash&quot;</span><br><span class="line">        android:scaleType=&quot;centerCrop&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:visibility=&quot;invisible&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:textSize=&quot;10sp&quot;</span><br><span class="line">        android:textColor=&quot;@color/white&quot;</span><br><span class="line">        android:id=&quot;@+id/sp_jump_btn&quot;</span><br><span class="line">        android:background=&quot;@drawable/btn_splash_shape&quot;</span><br><span class="line">        android:layout_width=&quot;60dp&quot;</span><br><span class="line">        android:layout_height=&quot;30dp&quot;</span><br><span class="line">        android:layout_alignParentRight=&quot;true&quot;</span><br><span class="line">        android:layout_alignParentTop=&quot;true&quot;</span><br><span class="line">        android:layout_marginRight=&quot;20dp&quot;</span><br><span class="line">        android:layout_marginTop=&quot;20dp&quot;/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p>布局文件文件相对来说还是比较简单，就需要一个 ImageView 和 Button 即可，Button 的背景是一个自定义的 shape，透明度颜色啥的,根据UI妹砸说的算就好了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">       android:shape=&quot;rectangle&quot;&gt;</span><br><span class="line">    &lt;solid android:color=&quot;#99c4c4c4&quot;/&gt;</span><br><span class="line">    &lt;corners android:radius=&quot;20dp&quot;/&gt;</span><br><span class="line">    &lt;stroke</span><br><span class="line">        android:width=&quot;0.7dp&quot;</span><br><span class="line">        android:color=&quot;#7fffffff&quot;/&gt;</span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure></p><h2 id="倒计时功能实现"><a href="#倒计时功能实现" class="headerlink" title="倒计时功能实现"></a>倒计时功能实现</h2><p>实现倒计时的功能方法有很多，最基本的你可以使用 Handler 来实现吧，还可以是用 Timer 吧。</p><p>但是由于之前写验证码倒计时的时候发现 android.os 中有一个神奇的类叫 <a href="https://developer.android.com/reference/android/os/CountDownTimer.html"><code>CountDownTimer</code></a> 的类，此类神奇之处就在于你完全不需要理会那些线程交互他都给你处理好了，你只管在回调中处理时间设置跳转逻辑就好了。</p><p>但是有一个不足的地方就它的第一秒的倒计时有时候会不可见，所以我们将倒计时总时间设置为 3200ms 。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private CountDownTimer countDownTimer = new CountDownTimer(3200, 1000) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onTick(long millisUntilFinished) &#123;</span><br><span class="line">        mSpJumpBtn.setText(&quot;跳过(&quot; + millisUntilFinished / 1000 + &quot;s)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFinish() &#123;</span><br><span class="line">        mSpJumpBtn.setText(&quot;跳过(&quot; + 0 + &quot;s)&quot;);</span><br><span class="line">        gotoLoginOrMainActivity();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>最后需要在有闪屏页面的情况下，进入开启倒计时：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void startClock() &#123;</span><br><span class="line">    mSpJumpBtn.setVisibility(View.VISIBLE);</span><br><span class="line">    countDownTimer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="下载功能实现点击跳转功能实现"><a href="#下载功能实现点击跳转功能实现" class="headerlink" title="下载功能实现点击跳转功能实现"></a>下载功能实现点击跳转功能实现</h2><p>上边说了我们 APP 点击图片需要可以跳转，下面代码给出了背景点击跳转的逻辑：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_splash);</span><br><span class="line">    ButterKnife.bind(this);</span><br><span class="line">    checkSDCardPermission();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@OnClick(&#123;R.id.sp_bg, R.id.sp_jump_btn&#125;)</span><br><span class="line">public void onViewClicked(View view) &#123;</span><br><span class="line">    switch (view.getId()) &#123;</span><br><span class="line">        case R.id.sp_bg:</span><br><span class="line">            gotoWebActivity();</span><br><span class="line">            break;</span><br><span class="line">        case R.id.sp_jump_btn:</span><br><span class="line">            gotoLoginOrMainActivity();</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>跳转逻辑可以根据实际的项目需求来规定，下面的代码中 Splash 为本地序列化的 model 用来存储网络下载的闪屏页面信息，稍后会有详细的序列化过程，此刻我们只需要关注跳转逻辑：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Splash mSplash;</span><br><span class="line">private void gotoWebActivity() &#123;</span><br><span class="line">    if (mSplash != null &amp;&amp; mSplash.click_url != null) &#123;</span><br><span class="line">        Intent intent = new Intent(this, BannerActivity.class);</span><br><span class="line">        intent.putExtra(&quot;url&quot;, mSplash.click_url);</span><br><span class="line">        intent.putExtra(&quot;title&quot;, mSplash.title);</span><br><span class="line">        intent.putExtra(&quot;fromSplash&quot;, true);</span><br><span class="line">        intent.putExtra(&quot;needShare&quot;, false);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>机智的你可能看出来我们并没有在离开页面的时候结束掉 timer，其实我们是复写了 onDestroy 方法。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    if (countDownTimer != null)</span><br><span class="line">        countDownTimer.cancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其实跳转以后还有一个坑就是，从 web 页面返回的时候，因为闪屏页面是你应用的第一个页面，而跳转到 web 页面的是你 finish 掉了该页面，那么从 web 页返回的时候不做处理，用户就直接退出了 app 这样当然是不允许的。</p><p>所以请在 web 页面中添加以下逻辑：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//此方法是toolbar 的返回事件调用的方法 mFromSplash 为启动页面传递过来的参数</span><br><span class="line">@Override</span><br><span class="line">protected void onLeftClick(View view) &#123;</span><br><span class="line">    if (mFromSplash) &#123;</span><br><span class="line">        gotoLoginOrMainActivity();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        super.onLeftClick(view);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此方法为系统返回键的监听</span><br><span class="line">@Override</span><br><span class="line">public void onBackPressed() &#123;</span><br><span class="line">    if (mWebView.canGoBack()) &#123;</span><br><span class="line">        mWebView.goBack();</span><br><span class="line">    &#125; else if (mFromSplash) &#123;</span><br><span class="line">        gotoLoginOrMainActivity();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        super.onBackPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> // 下面是跳转逻辑 </span><br><span class="line"> private void gotoLoginOrMainActivity() &#123;</span><br><span class="line">    if (UserCenter.getInstance().getToken() == null) &#123;</span><br><span class="line">        gotoLoginActivity();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        gotoMainActivity();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.... gotoLoginActivity，gotoMainActivity 太长了，不给了自己写 (*^__^*) 嘻嘻……</span><br></pre></td></tr></table></figure></p><h2 id="下载网络图片以及序列化本地"><a href="#下载网络图片以及序列化本地" class="headerlink" title="下载网络图片以及序列化本地"></a>下载网络图片以及序列化本地</h2><p>上边说了我们有这样一个需求，就是如果后台的接口返回的图片与本地序列化的图片不同，我们需要将新的图片下载到本地，然后下次进入 Splash 的时候就展示的新的图片了。</p><p>这里你需要知道知识有下边几个：</p><blockquote><ol><li>java bean 序列化与反序列化的知识</li><li>IntentService 服务的知识</li><li>AsycTask 的使用</li><li>6.0 以上权限申请 EasyPermissions 的使用。<br>以上不熟悉的同学，看到下边的代码可能会引起适量身体不适</li></ol><p>其实这里更好的操作，我们可以将图片下载到内存中，这样并不需要申请sdk权限。这里当时实现的时候有点欠考虑了。如果您们保存图片的地址在内存中，就可以跳过这一步。</p></blockquote><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>首先我们注意到已进入 Splash 页面我们就进行权限检查，因为我们需要下载最新的闪屏到本地，并取出序列化的对象，来展示对应的内容。</p><p>其中 checkSDCardPermission 涉及到 6.0 以上下载最新图片的逻辑，这里采用的是 官方的 EasyPermissions 来处理，关于 EasyPermissions 的使用这里就不多说了，需要了解的请移步 <a href="https://github.com/googlesamples/easypermissions">EasyPermissions</a>；<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static final int RC_PERMISSION = 123;</span><br><span class="line"></span><br><span class="line">@TargetApi(Build.VERSION_CODES.JELLY_BEAN)</span><br><span class="line">@AfterPermissionGranted(RC_PERMISSION)</span><br><span class="line">private void checkSDCardPermission() &#123;</span><br><span class="line">    if (EasyPermissions.hasPermissions(this, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE)) &#123;</span><br><span class="line">        initSplashImage();</span><br><span class="line">        startImageDownLoad();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        EasyPermissions.requestPermissions(this, &quot;需要您提供【**】App 读写内存卡权限来确保应用更好的运行&quot;, RC_PERMISSION, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>简单来说在 <code>EasyPermissions.hasPermissions</code> 的回调中我们就可以正确的做我们下载图片的工作了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void initSplashImage() &#123;</span><br><span class="line">    mSplash = getLocalSplash();  </span><br><span class="line">    //如果取出本地序列化的对象成功 则进行图片加载和倒计时</span><br><span class="line">    if (mSplash != null &amp;&amp; !TextUtils.isEmpty(mSplash.savePath)) &#123;</span><br><span class="line">        Logcat.d(&quot;SplashActivity 获取本地序列化成功&quot; + mSplash);</span><br><span class="line">        Glide.with(this).load(mSplash.savePath).dontAnimate().into(mSpBgImage);</span><br><span class="line">        startClock();//加载成功 开启倒计时</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    // 如果本地没有 直接跳转</span><br><span class="line">        mSpJumpBtn.setVisibility(View.INVISIBLE);</span><br><span class="line">        mSpJumpBtn.postDelayed(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                gotoLoginOrMainActivity();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 400);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取出本地序列化的 Splash </span><br><span class="line">private Splash getLocalSplash() &#123;</span><br><span class="line">    Splash splash = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File serializableFile = SerializableUtils.getSerializableFile(Constants.SPLASH_PATH, Constants.SPLASH_FILE_NAME);</span><br><span class="line">        splash = (Splash) SerializableUtils.readObject(serializableFile);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        Logcat.e(&quot;SplashActivity 获取本地序列化闪屏失败&quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    return splash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="创建本地序列化对象-Splash-Entity"><a href="#创建本地序列化对象-Splash-Entity" class="headerlink" title="创建本地序列化对象 Splash Entity"></a>创建本地序列化对象 Splash Entity</h3><p>Splash 内容如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Splash implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 7382351359868556980L;//这里需要写死 序列化Id</span><br><span class="line">    public int id;</span><br><span class="line">    public String burl;//大图 url</span><br><span class="line">    public String surl;//小图url</span><br><span class="line">    public int type;//图片类型 Android 1 IOS 2</span><br><span class="line">    public String click_url; // 点击跳转 URl</span><br><span class="line">    public String savePath;//图片的存储地址</span><br><span class="line">    public String title;//图片的存储地址</span><br><span class="line"></span><br><span class="line">    public Splash(String burl, String surl, String click_url, String savePath) &#123;</span><br><span class="line">        this.burl = burl;</span><br><span class="line">        this.surl = surl;</span><br><span class="line">        this.click_url = click_url;</span><br><span class="line">        this.savePath = savePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Splash&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, burl=&#x27;&quot; + burl + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, surl=&#x27;&quot; + surl + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, type=&quot; + type +</span><br><span class="line">                &quot;, click_url=&#x27;&quot; + click_url + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, savePath=&#x27;&quot; + savePath + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="序列化反序列话的工具类-SerializableUtils"><a href="#序列化反序列话的工具类-SerializableUtils" class="headerlink" title="序列化反序列话的工具类 SerializableUtils"></a>序列化反序列话的工具类 SerializableUtils</h3><p>由于项目用到序列化地方还有挺多的，所以这里封装了一个序列化工具类<code>SerializableUtils</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class SerializableUtils &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;T extends Serializable&gt; Object readObject(File file) &#123;</span><br><span class="line">        ObjectInputStream in = null;</span><br><span class="line">        T t = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">            t = (T) in.readObject();</span><br><span class="line">        &#125; catch (EOFException e) &#123;</span><br><span class="line">            // ... this is fine</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            Logcat.e(&quot;e &quot; + e.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (in != null) in.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T extends Serializable&gt; boolean writeObject(T t, String fileName) &#123;</span><br><span class="line">        ObjectOutputStream out = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            out = new ObjectOutputStream(new FileOutputStream(fileName));</span><br><span class="line">            out.writeObject(t);</span><br><span class="line">            Logcat.d(&quot;序列化成功 &quot; + t.toString());</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Logcat.d(&quot;序列化失败 &quot; + e.getMessage());</span><br><span class="line">            return false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (out != null) out.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static File getSerializableFile(String rootPath, String fileName) throws IOException &#123;</span><br><span class="line">        File file = new File(rootPath);</span><br><span class="line">        if (!file.exists()) file.mkdirs();</span><br><span class="line">        File serializable = new File(file, fileName);</span><br><span class="line">        if (!serializable.exists()) serializable.createNewFile();</span><br><span class="line">        return serializable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>经过上边的努力我们已经完成了从本地反序列化内容，然后加载图片的工作了，剩下的需要做的就是下载最新图片的工作。</p><h3 id="请求接口下载最新的闪屏信息和图片"><a href="#请求接口下载最新的闪屏信息和图片" class="headerlink" title="请求接口下载最新的闪屏信息和图片"></a>请求接口下载最新的闪屏信息和图片</h3><blockquote><p>这里经过考虑，我决定采用服务去下载，因为这样可以少很多麻烦，也不影响程序的正常运行。但是绝不是你们要采用这样的方法，你们也可以单独写个工具类内部去开线程做这件事。</p><p>项目中使用开启 IntentServie 来下载图片，关于这中服务的最大的好处就是，我们不需要关注服务是否执行完任务，当他执行完<br>onHandleIntent 方法后他就自己挑用 stop 方法了。我们只需要关注下载逻辑和序列化逻辑就好。</p></blockquote><p><code>checkSDCardPermission</code> 中调用的 <code>startImageDownLoad（）</code> 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void startImageDownLoad() &#123;</span><br><span class="line">SplashDownLoadService.startDownLoadSplashImage(this, Constants.DOWNLOAD_SPLASH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>SplashDownLoadService 内容，IntentService 在调用了 startService 后会执行 <code>onHandleIntent</code> 方法，在这方法中我们去请求服务器最新的数据即 <code>loadSplashNetDate</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public SplashDownLoadService() &#123;</span><br><span class="line">    super(&quot;SplashDownLoad&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void startDownLoadSplashImage(Context context, String action) &#123;</span><br><span class="line">    Intent intent = new Intent(context, SplashDownLoadService.class);</span><br><span class="line">    intent.putExtra(Constants.EXTRA_DOWNLOAD, action);</span><br><span class="line">    context.startService(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onHandleIntent(@Nullable Intent intent) &#123;</span><br><span class="line">    if (intent != null) &#123;</span><br><span class="line">        String action = intent.getStringExtra(Constants.EXTRA_DOWNLOAD);</span><br><span class="line">        if (action.equals(Constants.DOWNLOAD_SPLASH)) &#123;</span><br><span class="line">            loadSplashNetDate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于是公司项目，请求方法就不给出了，但是需要讲下请求数据后如何判断是否需要执行下载任务：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mScreen = common.attachment.flashScreen;</span><br><span class="line">Splash splashLocal = getSplashLocal();</span><br><span class="line">if (mScreen != null) &#123;</span><br><span class="line">   if (splashLocal == null) &#123;</span><br><span class="line">      Logcat.d(&quot;splashLocal 为空导致下载&quot;);</span><br><span class="line">      startDownLoadSplash(Constants.SPLASH_PATH, mScreen.burl);</span><br><span class="line">    &#125; else if (isNeedDownLoad(splashLocal.savePath, mScreen.burl)) &#123;</span><br><span class="line">          Logcat.d(&quot;isNeedDownLoad 导致下载&quot;);</span><br><span class="line">          startDownLoadSplash(Constants.SPLASH_PATH, mScreen.burl);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; else &#123;//由于活动是一段时间，等活动结束后我们并不需要在进入闪屏页面，这个时候我们就需要将本地文件删除，下次在进来，本地文件为空，就会直接 finish 掉 Splash 页面，进入主页面。</span><br><span class="line">  if (splashLocal != null) &#123;</span><br><span class="line">        File splashFile = SerializableUtils.getSerializableFile(Constants.SPLASH_PATH, SPLASH_FILE_NAME);</span><br><span class="line">         if (splashFile.exists()) &#123;</span><br><span class="line">                 splashFile.delete();</span><br><span class="line">                 Logcat.d(&quot;mScreen为空删除本地文件&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于活动是一段时间，等活动结束后我们并不需要在进入闪屏页面，这个时候我们就需要将本地文件删除，下次在进来，本地文件为空，就会直接 finish 掉 Splash 页面，进入主页面。</p><p><code>getSplashLocal</code> 方法即反序列话本地存储的 Splash Entity 的过程，上边已经给出这里就不细说，主要讲一下判断逻辑 <code>isNeedDownLoad</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param path 本地存储的图片绝对路径</span><br><span class="line"> * @param url  网络获取url</span><br><span class="line"> * @return 比较储存的 图片名称的哈希值与 网络获取的哈希值是否相同</span><br><span class="line"> */</span><br><span class="line">private boolean isNeedDownLoad(String path, String url) &#123;</span><br><span class="line">    // 如果本地存储的内容为空则进行下载</span><br><span class="line">    if (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果本地文件不存在则进行下载，这里主要防止用户误删操作</span><br><span class="line">    File file = new File(path);</span><br><span class="line">    if (!file.exists()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果两者都存在则判断图片名称的 hashCode 是否相同，不相同则下载</span><br><span class="line">    if (getImageName(path).hashCode() != getImageName(url).hashCode()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>分隔 uri 取图片名称的方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private String getImageName(String url) &#123;</span><br><span class="line">        if (TextUtils.isEmpty(url)) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] split = url.split(&quot;/&quot;);</span><br><span class="line">        String nameWith_ = split[split.length - 1];</span><br><span class="line">        String[] split1 = nameWith_.split(&quot;\\.&quot;);</span><br><span class="line">        return split1[0];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>满足下载条件后则调用 DownLoadTask 下载。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public class DownLoadUtils &#123;</span><br><span class="line"></span><br><span class="line">    public interface DownLoadInterFace &#123;</span><br><span class="line">        void afterDownLoad(ArrayList&lt;String&gt; savePaths);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void downLoad(String savePath, DownLoadInterFace downLoadInterFace, String... download) &#123;</span><br><span class="line">        new DownLoadTask(savePath, downLoadInterFace).execute(download);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class DownLoadTask extends AsyncTask&lt;String, Integer, ArrayList&lt;String&gt;&gt; &#123;</span><br><span class="line">        private String mSavePath;</span><br><span class="line">        private DownLoadInterFace mDownLoadInterFace;</span><br><span class="line"></span><br><span class="line">        private DownLoadTask(String savePath, DownLoadInterFace downLoadTask) &#123;</span><br><span class="line">            this.mSavePath = savePath;</span><br><span class="line">            this.mDownLoadInterFace = downLoadTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected ArrayList&lt;String&gt; doInBackground(String... params) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">            for (String url : params) &#123;</span><br><span class="line">                if (!TextUtils.isEmpty(url)) &#123;</span><br><span class="line">                    if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">                        // 获得存储卡的路径</span><br><span class="line">                        FileOutputStream fos = null;</span><br><span class="line">                        InputStream is = null;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            URL downUrl = new URL(url);</span><br><span class="line">                            // 创建连接</span><br><span class="line">                            HttpURLConnection conn = (HttpURLConnection) downUrl.openConnection();</span><br><span class="line">                            conn.connect();</span><br><span class="line">                            // 创建输入流</span><br><span class="line">                            is = conn.getInputStream();</span><br><span class="line">                            File file = new File(mSavePath);</span><br><span class="line">                            // 判断文件目录是否存在</span><br><span class="line">                            if (!file.exists()) &#123;</span><br><span class="line">                                file.mkdirs();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            String[] split = url.split(&quot;/&quot;);</span><br><span class="line">                            String fileName = split[split.length - 1];</span><br><span class="line">                            File mApkFile = new File(mSavePath, fileName);</span><br><span class="line">                            names.add(mApkFile.getAbsolutePath());</span><br><span class="line">                            fos = new FileOutputStream(mApkFile, false);</span><br><span class="line">                            int count = 0;</span><br><span class="line">                            // 缓存</span><br><span class="line">                            byte buf[] = new byte[1024];</span><br><span class="line">                            while (true) &#123;</span><br><span class="line">                                int read = is.read(buf);</span><br><span class="line">                                if (read == -1) &#123;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                fos.write(buf, 0, read);</span><br><span class="line">                                count += read;</span><br><span class="line">                                publishProgress(count);</span><br><span class="line">                            &#125;</span><br><span class="line">                            fos.flush();</span><br><span class="line"></span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            Logcat.e(e.getMessage());</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                if (is != null) &#123;</span><br><span class="line">                                    is.close();</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (fos != null) &#123;</span><br><span class="line">                                    fos.close();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; catch (IOException e1) &#123;</span><br><span class="line">                                e1.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return names;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void onPostExecute(ArrayList&lt;String&gt; strings) &#123;</span><br><span class="line">            super.onPostExecute(strings);</span><br><span class="line">            if (mDownLoadInterFace != null) &#123;</span><br><span class="line">                mDownLoadInterFace.afterDownLoad(strings);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于下载完成后需要拿到文件存储地址这里写了一个 mDownLoadInterFace.afterDownLoad 的回调在 service 拿到回调后：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void afterDownLoad(ArrayList&lt;String&gt; savePaths) &#123;</span><br><span class="line">                if (savePaths.size() == 1) &#123;</span><br><span class="line">                    Logcat.d(&quot;闪屏页面下载完成&quot; + savePaths);</span><br><span class="line">                    if (mScreen != null) &#123;</span><br><span class="line">                        mScreen.savePath = savePaths.get(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 序列化 Splash 到本地</span><br><span class="line">                    SerializableUtils.writeObject(mScreen, Constants.SPLASH_PATH + &quot;/&quot; + SPLASH_FILE_NAME);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Logcat.d(&quot;闪屏页面下载失败&quot; + savePaths);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上边 bb 这么多，我们可以看出产品一句话，我们程序员可能就需要工作一天了，所以我们需要将这个常见的功能记录下，下个公司产品再说实现一个闪屏功能，然后我们就可以说 这功能可能需要 1天时间，然后等他答应了，copy 一下，其他的时间你就可以学习下 Rxjava2 ，kotlin， js 之类的了。哈哈哈哈 我真tm机智。</p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Splash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中高德地图与百度地图坐标转换</title>
      <link href="/2017/06/14/17-06-14/"/>
      <url>/2017/06/14/17-06-14/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>项目中实验数据点取自高德地图，它是火星坐标系统（下面会有解释），而现在希望用百度地图的SDK进行开发，两套不同的规范自然需要进行转换。如何解决这个问题呢？参考了网上很多人的博客和资料。<br>最终解决此问题用到的仍然是百度的<a href="http://lbsyun.baidu.com/index.php?title=androidsdk/guide/tool#.E5.9D.90.E6.A0.87.E8.BD.AC.E6.8D.A2">官方文档</a>有关于坐标转换的部分：</p></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h2><blockquote><p>百度地图SDK采用的是百度自有的地理坐标系（bdll09），因此开发者在做位置标注的时候，需要将其他类型的坐标转换为百度坐标。相应的接口和转换方式如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 将google地图、soso地图、aliyun地图、mapabc地图和amap地图// 所用坐标转换成百度坐标  </span><br><span class="line">CoordinateConverter converter  = new CoordinateConverter();  </span><br><span class="line">converter.from(CoordType.COMMON);  </span><br><span class="line">// sourceLatLng待转换坐标  </span><br><span class="line">converter.coord(sourceLatLng);  </span><br><span class="line">LatLng desLatLng = converter.convert();  </span><br><span class="line"> </span><br><span class="line">// 将GPS设备采集的原始GPS坐标转换成百度坐标  </span><br><span class="line">CoordinateConverter converter  = new CoordinateConverter();  </span><br><span class="line">converter.from(CoordType.GPS);  </span><br><span class="line">// sourceLatLng待转换坐标  </span><br><span class="line">converter.coord(sourceLatLng);  </span><br><span class="line">LatLng desLatLng = converter.convert();</span><br></pre></td></tr></table></figure><p>使用上面的代码就能很好地进行坐标的转化。</p><p>下面列举其他牛人的一些内容：</p><blockquote><p>大家都知道，美国GPS使用的是WGS84的坐标系统，以经纬度的形式来表示地球平面上的某一个位置，这应该是国际共识。但在我国，出于国家安全考虑，国内所有导航电子地图必须使用国家测绘局制定的加密坐标系统，即将一个真实的经纬度坐标加密成一个不正确的经纬度坐标，我们在业内将前者称之为地球坐标，后者称之为火星坐标，具体的说明可以参看百度百科中关于<a href="http://baike.baidu.com/item/%E7%81%AB%E6%98%9F%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F">火星坐标系统的解释</a>。</p></blockquote><h2 id="国内各地图API坐标系统比较"><a href="#国内各地图API坐标系统比较" class="headerlink" title="国内各地图API坐标系统比较"></a>国内各地图API坐标系统比较</h2><div class="table-container"><table><thead><tr><th>API</th><th>坐标系</th></tr></thead><tbody><tr><td>百度地图API</td><td>百度坐标</td></tr><tr><td>腾讯搜搜地图API</td><td>火星坐标</td></tr><tr><td>搜狐搜狗地图API</td><td>搜狗坐标</td></tr><tr><td>阿里云地图API</td><td>火星坐标</td></tr><tr><td>图吧MapBar地图API</td><td>图吧坐标</td></tr><tr><td>高德MapABC地图API</td><td>火星坐标</td></tr><tr><td>灵图51ditu地图API</td><td>火星坐标</td></tr></tbody></table></div><h2 id="下面是百度官方对百度坐标为何有偏移的解释"><a href="#下面是百度官方对百度坐标为何有偏移的解释" class="headerlink" title="下面是百度官方对百度坐标为何有偏移的解释"></a>下面是百度官方对百度坐标为何有偏移的解释</h2><blockquote><p>国际经纬度坐标标准为WGS-84,国内必须至少使用国测局制定的GCJ-02,对地理位置进行首次加密。百度坐标在此基础上，进行了BD-09二次加密措施,更加保护了个人隐私。百度对外接口的坐标系并不是GPS采集的真实经纬度，需要通过坐标转换接口进行转换。</p></blockquote><h2 id="火星坐标系-GCJ-02-与百度坐标系-BD-09-的转换算法"><a href="#火星坐标系-GCJ-02-与百度坐标系-BD-09-的转换算法" class="headerlink" title="火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换算法"></a>火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换算法</h2><p>GCJ-02(火星坐标)和BD-09（百度坐标）<br>算法代码如下，其中bd_encrypt将 GCJ-02坐标转换成 BD-09坐标， bd_decrypt反之。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void bd_encrypt(double gg_lat, double gg_lon, double &amp;bd_lat, double &amp;bd_lon) &#123;  </span><br><span class="line">    double x = gg_lon, y = gg_lat;  </span><br><span class="line">    double z = sqrt(x * x + y * y) + 0.00002 * sin(y * x_pi);  </span><br><span class="line">    double theta = atan2(y, x) + 0.000003 * cos(x * x_pi);  </span><br><span class="line">    bd_lon = z * cos(theta) + 0.0065;  </span><br><span class="line">    bd_lat = z * sin(theta) + 0.006;  </span><br><span class="line">&#125;  </span><br><span class="line">       </span><br><span class="line">void bd_decrypt(double bd_lat, double bd_lon, double &amp;gg_lat, double &amp;gg_lon) &#123;  </span><br><span class="line">    double x = bd_lon - 0.0065, y = bd_lat - 0.006;  </span><br><span class="line">    double z = sqrt(x * x + y * y) - 0.00002 * sin(y * x_pi);  </span><br><span class="line">    double theta = atan2(y, x) - 0.000003 * cos(x * x_pi);  </span><br><span class="line">    gg_lon = z * cos(theta);  </span><br><span class="line">    gg_lat = z * sin(theta);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="地球坐标系-WGS-84-到火星坐标系-GCJ-02-的转换算法"><a href="#地球坐标系-WGS-84-到火星坐标系-GCJ-02-的转换算法" class="headerlink" title="地球坐标系 (WGS-84) 到火星坐标系 (GCJ-02) 的转换算法"></a>地球坐标系 (WGS-84) 到火星坐标系 (GCJ-02) 的转换算法</h2><p>  WGS-84到GCJ-02的转换（即GPS加偏算法是一个普通青年轻易无法接触到的“公开”的秘密。这个算法的代码在互联网上是公开的，详情请使用Google搜索”<code>wgtochina_lb</code>“ 。<br>  整理后的算法代码请参考<a href="https://on4wp7.codeplex.com/SourceControl/changeset/view/21483#353936"> https://on4wp7.codeplex.com/SourceControl/changeset/view/21483#353936 </a>。知道了这个算法之后，就可以离线进行Google地图偏移校正，不必像之前那么麻烦。<br>至于GCJ-02到WGS-84的转换（即GPS纠偏），可以使用二分法。</p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FontMetrics以及自定义ImageSpan实现TextView图文混排时文图的居中对齐</title>
      <link href="/2017/06/10/17-06-10/"/>
      <url>/2017/06/10/17-06-10/</url>
      
        <content type="html"><![CDATA[<p><img src="http://dinson-blog.hdinson.cn/FqRj0Yf7Vco8-6vAOnkTT1NSWyJp.png" alt="&quot;dfa&quot;"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>在上图中整体实现的时候使用的是popUpWindow。该popupWindow整体使用相对布局，里面再用一个相对布局布局嵌套了三个TextView：”啊哦。。。。pass” 用一个TextView，中间灰色的上传头像的提示用了一个TextView，底部“我知道了” 也是一个TextView。上面的左划示意图使用above 放在 包含TextView的相对布局上方，并通过负的margin值将它下移并覆盖在包含TextView相对布局上。</p></blockquote><p>这个界面并没有什么难度，这里重点说的是第一个TextView中的图文混排，并让图片的横向中间线与该行文字的横向中间线对齐，也就是说，让文字与那个💔 图片的中间在水平方向对齐。</p><span id="more"></span><!-- 这是　　缩进--><h2 id="图文混排的方式有哪些？"><a href="#图文混排的方式有哪些？" class="headerlink" title="图文混排的方式有哪些？"></a>图文混排的方式有哪些？</h2><p>通常我们向TextView中插入图片实现图文混排有如下方式：</p><ol><li>使用drawableLeft等属性设置，这种方式对应的java方法是 setCompoundDrawablesWithIntrinsicBounds(leftDrawble,topDrawable,rightDrawable,bottomDrawable);</li><li>使用 SpannableString ,先将图片转成ImageSpan对象，然后通过setSpan插入到SpannableString 中，最后再将SpannableString通过setText设置给TextView。（SpannableString 继承自CharSquence）</li><li>此外，还有一种利用Html.ImageGetter格式化图片的方式。（截止目前为止，我没用过这种方式，如果想了解的话，可以参考<a href="http://wangleyiang.iteye.com/blog/1771439中的第二点）">http://wangleyiang.iteye.com/blog/1771439中的第二点）</a></li></ol><h2 id="使用SpannableString-ImageSpan怎么实现图文混排？"><a href="#使用SpannableString-ImageSpan怎么实现图文混排？" class="headerlink" title="使用SpannableString+ImageSpan怎么实现图文混排？"></a>使用SpannableString+ImageSpan怎么实现图文混排？</h2><p>(1). 基本实现方式<br>效果图如下：<br><img src="http://dinson-blog.hdinson.cn/FkIGaIysmg-9PW07xdUttjrP4k4t.png" alt=""><br>实现方式很简单，我们只需要在xml布局文件中定义一个TextView，然后在代码中获取该TextView并创建一个含有图片的SpannableString,并将该SpannableString通过setText( )设置给TextView即可。代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SpannableStringAndImageSpanActivity extends AppCompatActivity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_spannbalestring_imagespan);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line"></span><br><span class="line">        TextView tv_test = (TextView) findViewById(R.id.tv_test);</span><br><span class="line">        SpannableString spannableString = new SpannableString(&quot;点击 按钮有惊喜&quot;);</span><br><span class="line"></span><br><span class="line">        ImageSpan imageSpan = new ImageSpan(this, R.mipmap.ic_launcher);</span><br><span class="line"></span><br><span class="line">        //setSpan插入内容的时候，起始位置不替换，会替换起始位置到终止位置间的内容，含终止位置。</span><br><span class="line">        //Spanned.SPAN_EXCLUSIVE_EXCLUSIVE模式用来控制是否同步设置新插入的内容与start/end 位置的字体样式，此处没设置具体字体，所以可以随意设置</span><br><span class="line">        spannableString.setSpan(imageSpan, 2, 3, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">        tv_test.setText(spannableString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>xml布局文件中只给了一个普通的TextView，代码省略。</p><blockquote><ol><li><p>在上面的代码中，我们通过ImageSpan的构造方法得到了一个ImageSpan对象。该构造方法中传入的两个参数分别是上下文和图片的id。（imageSpan的构造方法还有很多）</p></li><li><p>SpannbaleString的setSpan方法中，传入的四个参数分别是 ImageSpan对象、将ImageSpan插入到的起始位置(start)、将ImageSpan插入到的终点位置(end)、是否应用字体样式。具体将ImageSpan对象插入到哪个位置，由第二个和第三个参数确定，插入的时候会覆盖从 start 位置开始（不包含该位置）到终止位置间的内容（包含该位置）。第四个参数是在你插入文本的时候使用的，用来控制新插入的文本与已有文本内容的字体样式是否一致的如果你插入的是图片，这里就可以随便选择一种模式。</p></li></ol></blockquote><p>经过上面虽然实现了图文混排，但是，细心的你可能发现了，这时候的文字和图片是基于底部对齐的（由于图片的原因，图片底部与边框有一点点的间距）。那么如果我想更改对齐方式怎么办呢？</p><p>(2). 更改图片与文本的对齐方式—ALIGN_BASELINE对齐</p><p>设置对齐方式的方法很简单，在构造ImageSpan对象的时候，传入第三个参数ALIGN_BASELINE 即可，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageSpan imageSpan = new ImageSpan(this, R.mipmap.ic_launcher, DynamicDrawableSpan.ALIGN_BASELINE);</span><br></pre></td></tr></table></figure><br>设置对齐方式为ALIGN_BASELINE后的效果图：<br><img src="http://dinson-blog.hdinson.cn/Fi_w7QCAL-zoRiNVTE2d8zHqgeJV.png" alt=""><br>咦，看着跟上面的图没啥区别啊？那么我再把上面没设置对齐方式的图拉下来看下：<br><img src="http://dinson-blog.hdinson.cn/FkIGaIysmg-9PW07xdUttjrP4k4t.png" alt=""><br>仔细对比下，我们发现，设置对齐方式之后，图往上跑了一点点。</p><blockquote><p><strong>其实，在ImageSpan 中，官方只给出了两中对齐方式：</strong></p><ol><li>一种是 ALIGN_BOTTOM , 表示与文字内容的底部对齐，如果在构造ImageSpan时没有传入对齐方式，那么默认就是这种底部对齐。</li><li>另一中就是 ALIGN_BASELINE, 表示与文字内容的基线对齐。那么，你可能会问我基线是啥？请继续往下看：</li></ol></blockquote><h2 id="Paint-FontMetrics-是啥？"><a href="#Paint-FontMetrics-是啥？" class="headerlink" title="Paint.FontMetrics 是啥？"></a>Paint.FontMetrics 是啥？</h2><p>(1). Paint.FontMetrics基本介绍<br>要说基线呢，我们先了解这个Paint.FontMetircs, 官方对该类的解释是：<code>Class that describes the various metrics for a font at a given text size.</code>, 意思是说，这玩意儿是绘制文本内容时存储该文本内容位置信息的一个类。这个类中有如下五个字段：<br><img src="http://dinson-blog.hdinson.cn/Fv3daCrXBC7dgBY8PHz0xL3gKbWL.png" alt=""></p><p>(2). BaseLine 基线到底是啥？<br>上图中这5个字段除了leading 外，其他四个都是相对于 基线BaseLine来确定的，那么，到底啥是基线？？先来看一张图：<br><img src="http://dinson-blog.hdinson.cn/Fm1DOwbK_ENlyHRHqkMVT0gv40k-.png" alt=""><br>如上图，<strong>标准的英文书写是基于四线三格，其中，我们书写英文的时候，都是以第三条线为基准，也就是说，基线就是这个四线三格中的第三条线！！</strong></p><p>(3). Paint.FontMetrics中字段的含义及示意图<br>官方文档中对这几个字段的解释很简单，但理解起来挺费劲，直接上图，<strong>图中的标注都是跑代码之后确定的，如果有不准确的地方，欢迎指正：</strong><br><img src="http://dinson-blog.hdinson.cn/FngzbBPGHMEfeySioy3dzCoV19em.png" alt=""><br>根据上图可知：</p><ul><li><p>ascent<br>文字内容的顶部到基线的距离。即 ascent=文字内容顶部Y坐标 - 基线Y坐标。由于android中坐标系是 右下为正，所以得到的ascent实际是一个负数。 </p></li><li><p>descent<br>文字内容的底部到基线的距离。即 descent=文字内容底部Y坐标 - 基线Y坐标。</p></li><li><p>基线<br>在图中，基线的坐标用Y表示，在ImageSpan父类的 draw( ) 中，会传入一个 float Y ,就是这个基线的坐标。实际上，基线的Y坐标=文字内容中间线Y坐标+1/2 （文字内容高度）</p></li><li><p>top<br>对应图中 文字所在行的top 坐标</p></li><li><p>bottom<br>对应图中 文字所在行的bottom 坐标<br>需要注意：如果设置了行间距，且文本内容产生了换行，那么这个bottom 也会将行间距包裹。所以， 图中蓝色的文字内容中间线的Y轴坐标并不一定等于 (bottom+top)/2</p></li></ul><h2 id="自定义ImageSpan实现文字与图片居中对齐"><a href="#自定义ImageSpan实现文字与图片居中对齐" class="headerlink" title="自定义ImageSpan实现文字与图片居中对齐"></a>自定义ImageSpan实现文字与图片居中对齐</h2><p>好了，前面说了那么多，终于进入正题了。。。<br>在上面的2 SpannableString+ImageSpan实现图文混排中，我们已经知道官方并没有给出文字与图片居中对齐的模式,所以需要我们自定义。</p><p>关于自定义ImageSpan的分析，此处不再赘述，请参考<a href="http://dinson.win/2017/06/08/17-06-08/">http://dinson.win/2017/06/08/17-06-08/</a>。但是，按照该文章中的代码实现的时候，有个问题就是：如果给TextView设置了行间距，且文本产生了换行，那么就无法对齐了！！</p><p>那么，设置了行间距之后，该如何实现文本和图片的居中对齐呢？请看：<a href="http://dinson.win/2017/06/09/17-06-09/">http://dinson.win/2017/06/09/17-06-09/</a>, 但是，这篇文章中的实现方式没有重写 getSize( ) 方法，所以也有一个问题：文本和图片并不是在TextView的居中位置，而且如果图片高于文本的话，图片会显示不全！！如下图：<br><img src="http://dinson-blog.hdinson.cn/FhKYKIaBNh4DkMbY0kENHb7aQ2vL.png" alt=""></p><h2 id="终极方案"><a href="#终极方案" class="headerlink" title="终极方案"></a>终极方案</h2><p>其实我们自定义的时候，需要做的事情是 获取文本内容的中间线以及图片的中间线，然后获取两者差值，然后在draw方法中绘制图片时将差值作为canvas.translate(x, transY) 中的transY；同时要重写 getSize( )。这样最终实现的效果是，不论是否设置行间距，不论图片大于文本还是文本大于图片，都能实现文本和图片的居中对齐！</p><p>看最终效果图：<br><img src="http://dinson-blog.hdinson.cn/FgZ8DSaHUmakjUgG-EKhKTDfYlY0.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public class SpannableStringAndImageSpanActivity extends AppCompatActivity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_spannbalestring_imagespan);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line"></span><br><span class="line">        TextView tv_test = (TextView) findViewById(R.id.tv_test);</span><br><span class="line">        SpannableString spannableString = new SpannableString(&quot;点击 按钮有惊喜&quot;);</span><br><span class="line"></span><br><span class="line">        //调用自定义的imageSpan,实现文字与图片的横向居中对齐</span><br><span class="line">        CustomImageSpan imageSpan = new CustomImageSpan(this, R.mipmap.ic_launcher, 2);</span><br><span class="line"></span><br><span class="line">        //setSpan插入内容的时候，起始位置不替换，会替换起始位置到终止位置间的内容，含终止位置。</span><br><span class="line">        //Spanned.SPAN_EXCLUSIVE_EXCLUSIVE模式用来控制是否同步设置新插入的内容与start/end 位置的字体样式，此处没设置具体字体，所以可以随意设置</span><br><span class="line">        spannableString.setSpan(imageSpan, 2, 3, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">        tv_test.setText(spannableString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自定义imageSpan实现图片与文字的居中对齐</span><br><span class="line">     */</span><br><span class="line">    class CustomImageSpan extends ImageSpan &#123;</span><br><span class="line"></span><br><span class="line">        //自定义对齐方式--与文字中间线对齐</span><br><span class="line">        private int ALIGN_FONTCENTER = 2;</span><br><span class="line"></span><br><span class="line">        public CustomImageSpan(Context context, int resourceId) &#123;</span><br><span class="line">            super(context, resourceId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public CustomImageSpan(Context context, int resourceId, int verticalAlignment) &#123;</span><br><span class="line">            super(context, resourceId, verticalAlignment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom,</span><br><span class="line">                         Paint paint) &#123;</span><br><span class="line"></span><br><span class="line">            //draw 方法是重写的ImageSpan父类 DynamicDrawableSpan中的方法，在DynamicDrawableSpan类中，虽有getCachedDrawable()，</span><br><span class="line">            // 但是私有的，不能被调用，所以调用ImageSpan中的getrawable()方法，该方法中 会根据传入的drawable ID ，获取该id对应的</span><br><span class="line">            // drawable的流对象，并最终获取drawable对象</span><br><span class="line">            Drawable drawable = getDrawable(); //调用imageSpan中的方法获取drawable对象</span><br><span class="line">            canvas.save();</span><br><span class="line"></span><br><span class="line">            //获取画笔的文字绘制时的具体测量数据</span><br><span class="line">            Paint.FontMetricsInt fm = paint.getFontMetricsInt();</span><br><span class="line"></span><br><span class="line">            //系统原有方法，默认是Bottom模式)</span><br><span class="line">            int transY = bottom - drawable.getBounds().bottom;</span><br><span class="line">            if (mVerticalAlignment == ALIGN_BASELINE) &#123;</span><br><span class="line">                transY -= fm.descent;</span><br><span class="line">            &#125; else if (mVerticalAlignment == ALIGN_FONTCENTER) &#123;    //此处加入判断， 如果是自定义的居中对齐</span><br><span class="line">                //与文字的中间线对齐（这种方式不论是否设置行间距都能保障文字的中间线和图片的中间线是对齐的）</span><br><span class="line">                // y+ascent得到文字内容的顶部坐标，y+descent得到文字的底部坐标，（顶部坐标+底部坐标）/2=文字内容中间线坐标</span><br><span class="line">                transY = ((y + fm.descent) + (y + fm.ascent)) / 2 - drawable.getBounds().bottom / 2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            canvas.translate(x, transY);</span><br><span class="line">            drawable.draw(canvas);</span><br><span class="line">            canvas.restore();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 重写getSize方法，只有重写该方法后，才能保证不论是图片大于文字还是文字大于图片，都能实现中间对齐</span><br><span class="line">         */</span><br><span class="line">        public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) &#123;</span><br><span class="line">            Drawable d = getDrawable();</span><br><span class="line">            Rect rect = d.getBounds();</span><br><span class="line">            if (fm != null) &#123;</span><br><span class="line">                Paint.FontMetricsInt fmPaint = paint.getFontMetricsInt();</span><br><span class="line">                int fontHeight = fmPaint.bottom - fmPaint.top;</span><br><span class="line">                int drHeight = rect.bottom - rect.top;</span><br><span class="line"></span><br><span class="line">                int top = drHeight / 2 - fontHeight / 4;</span><br><span class="line">                int bottom = drHeight / 2 + fontHeight / 4;</span><br><span class="line"></span><br><span class="line">                fm.ascent = -bottom;</span><br><span class="line">                fm.top = -bottom;</span><br><span class="line">                fm.bottom = top;</span><br><span class="line">                fm.descent = top;</span><br><span class="line">            &#125;</span><br><span class="line">            return rect.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>xml布局文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">              android:layout_width=&quot;match_parent&quot;</span><br><span class="line">              android:layout_height=&quot;match_parent&quot;</span><br><span class="line">              android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tv_test&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:background=&quot;#fffaa3&quot;</span><br><span class="line">        android:lineSpacingExtra=&quot;@dimen/dp100&quot;</span><br><span class="line">        android:textSize=&quot;16sp&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ImageSpan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android ImageSpan与TextView中的text居中对齐问题解决</title>
      <link href="/2017/06/09/17-06-09/"/>
      <url>/2017/06/09/17-06-09/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>先解释一个类：Paint.FontMetrics，它表示绘制字体时的度量标准。google的官方api文档对它的字段说明如下：</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/FmOSFSft1d6GF-jBifSop_HJ9AK5.png" alt=""><br><span id="more"></span><br><!-- 这是　　缩进--><br>ascent: 字体最上端到基线的距离，为负值。<br>descent：字体最下端到基线的距离，为正值。<br><img src="http://dinson-blog.hdinson.cn/Frd9IRmhf317jlVEciITR76cJ7di.png" alt=""><br>中间那条线就是基线，基线到上面那条线的距离就是ascent，基线到下面那条线的距离就是descent。</p><p>回到主题，我们要让imagespan与text对齐，只需把imagespan放到descent线和ascent线之间的中间位置就可以了。实现方式为重写ImageSpan类的draw方法。最终实现方法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void draw(@NonNull Canvas canvas, CharSequence text,</span><br><span class="line">                 int start, int end, float x,</span><br><span class="line">                 int top, int y, int bottom, @NonNull Paint paint) &#123;</span><br><span class="line">     // image to draw</span><br><span class="line">    Drawable b = getDrawable();</span><br><span class="line">    // font metrics of text to be replaced</span><br><span class="line">    Paint.FontMetricsInt fm = paint.getFontMetricsInt();</span><br><span class="line">    int transY = (y + fm.descent + y + fm.ascent) / 2 </span><br><span class="line">            - b.getBounds().bottom / 2;</span><br><span class="line">    </span><br><span class="line">    canvas.save();</span><br><span class="line">    canvas.translate(x, transY);</span><br><span class="line">    b.draw(canvas);</span><br><span class="line">    canvas.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解释下形参：</p><ul><li>x，要绘制的image的左边框到textview左边框的距离。</li><li>y，要替换的文字的基线坐标，即基线到textview上边框的距离。</li><li>top，替换行的最顶部位置。</li><li>bottom，替换行的最底部位置。注意，textview中两行之间的行间距是属于上一行的，所以这里bottom是指行间隔的底部位置。</li><li>paint，画笔，包含了要绘制字体的度量信息。</li></ul><p>这几个参数含义在代码中找不到说明，写了个demo测出来的。top和bottom参数只是解释下，函数里面用不上。<br>然后解释下代码逻辑：</p><ul><li>getDrawable获取要绘制的image，getBounds是获取包裹image的矩形框尺寸；</li><li>y + fm.descent得到字体的descent线坐标；</li><li>y + fm.ascent得到字体的ascent线坐标；</li><li>两者相加除以2就是两条线中线的坐标；</li><li>b.getBounds().bottom是image的高度（试想把image放到原点），除以2即高度一半；</li><li>前面得到的中线坐标减image高度的一半就是image顶部要绘制的目标位置；</li><li>最后把目标坐标传递给canvas.translate函数就可以了，至于这个函数的理解先不管了。</li></ul><p>原理上大致就这样了，最后提供本文提出问题的最终解决方案，使用自定义的ImageSpan类，只需重写它的draw函数，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CenteredImageSpan extends ImageSpan &#123;</span><br><span class="line">    </span><br><span class="line">    public CenteredImageSpan(Context context, final int drawableRes) &#123;</span><br><span class="line">        super(context, drawableRes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void draw(@NonNull Canvas canvas, CharSequence text,</span><br><span class="line">                     int start, int end, float x,</span><br><span class="line">                     int top, int y, int bottom, @NonNull Paint paint) &#123;</span><br><span class="line">        // image to draw</span><br><span class="line">        Drawable b = getDrawable();</span><br><span class="line">        // font metrics of text to be replaced</span><br><span class="line">        Paint.FontMetricsInt fm = paint.getFontMetricsInt();</span><br><span class="line">        int transY = (y + fm.descent + y + fm.ascent) / 2</span><br><span class="line">                - b.getBounds().bottom / 2;</span><br><span class="line"></span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.translate(x, transY);</span><br><span class="line">        b.draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后看一下效果图：<br><img src="http://dinson-blog.hdinson.cn/Fsat39vjbr9rrVeNeaj0vU-zXiiu.png" alt=""></p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ImageSpan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android ImageSpan的图文居中对齐</title>
      <link href="/2017/06/08/17-06-08/"/>
      <url>/2017/06/08/17-06-08/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>ImageSpan类为TextView提供了图文混排的形式，在ImageSpan的构造函数中提供了一个参数 int verticalAlignment，表示垂直对齐方式，有两个参数 ALIGN_BASELINE、ALIGN_BOTTOM 分别为顶部、底部对齐，但是没有居中对齐的参数（其实会找到这篇文章的人应该知道这点了。。）<br>下面说说我的实现思路及方法</p></blockquote><span id="more"></span><!-- 这是　　缩进--><ul><li><p>根据构造函数verticalAlignment参数找到影响对齐方式的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ImageSpan(Context context, int resourceId, int verticalAlignment) &#123;  </span><br><span class="line">    super(verticalAlignment);  </span><br><span class="line">    mContext = context;  </span><br><span class="line">    mResourceId = resourceId;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码可知对齐参数是在ImageSpan的父类DynamicDrawableSpan中设置的</p></li><li><p>查看DynamicDrawableSpan类源码找出对齐方式的代码，在源码中能看到两个方法getSize与draw</p></li><li>getSize方法，返回一个Int含义为图片的宽度，但是我们看源码发现里面干的事情不仅是返回宽度还设置了文字的ascent、descent的位置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) &#123;  </span><br><span class="line">    Drawable d = getCachedDrawable();  </span><br><span class="line">    Rect rect = d.getBounds();  </span><br><span class="line">  </span><br><span class="line">    if (fm != null) &#123;  </span><br><span class="line"> fm.ascent = -rect.bottom;   </span><br><span class="line">        fm.descent = 0;   </span><br><span class="line">  </span><br><span class="line">        fm.top = fm.ascent;  </span><br><span class="line">        fm.bottom = 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return rect.right;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>draw方法，根据对齐参数绘制图片。所以第一步就是修改draw方法来实现居中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123;  </span><br><span class="line">    Drawable b = getCachedDrawable();  </span><br><span class="line">    canvas.save();  </span><br><span class="line">      </span><br><span class="line">    int transY = bottom - b.getBounds().bottom;  </span><br><span class="line">    if (mVerticalAlignment == ALIGN_BASELINE) &#123;  </span><br><span class="line">        transY -= paint.getFontMetricsInt().descent;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    canvas.translate(x, transY);  </span><br><span class="line">    b.draw(canvas);  </span><br><span class="line">    canvas.restore();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修改draw方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas canvas, CharSequence text, int start, int end,  </span><br><span class="line">        float x, int top, int y, int bottom, Paint paint) &#123;  </span><br><span class="line">       Drawable b = getDrawable();  </span><br><span class="line">       canvas.save();  </span><br><span class="line">       int transY = 0;  </span><br><span class="line">       //获得将要显示的文本高度-图片高度除2等居中位置+top(换行情况)  </span><br><span class="line">       transY = ((bottom-top) - b.getBounds().bottom)/2+top;  </span><br><span class="line">       //偏移画布后开始绘制  </span><br><span class="line">       canvas.translate(x, transY);  </span><br><span class="line">       b.draw(canvas);  </span><br><span class="line">       canvas.restore();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li>这时候如果运行调试的话会发现完全没效果。。为啥呢，别急还有一个重要方法没修改，那就是getSize方法，我们还需要修过getSize方法中对文字ascent、descent等参数的设置才行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int getSize(Paint paint, CharSequence text, int start, int end,  </span><br><span class="line">        FontMetricsInt fm) &#123;  </span><br><span class="line">       Drawable d = getDrawable();  </span><br><span class="line">       Rect rect = d.getBounds();  </span><br><span class="line">       if (fm != null) &#123;  </span><br><span class="line">        FontMetricsInt fmPaint=paint.getFontMetricsInt();  </span><br><span class="line">               //获得文字、图片高度  </span><br><span class="line">        int fontHeight = fmPaint.bottom - fmPaint.top;  </span><br><span class="line">        int drHeight=rect.bottom-rect.top;  </span><br><span class="line">        //对于这段算法LZ表示也不解，正常逻辑应该同draw中的计算一样但是显示的结果不居中，经过几次调试之后才发现这么算才会居中  </span><br><span class="line">        int top= drHeight/2 - fontHeight/4;  </span><br><span class="line">        int bottom=drHeight/2 + fontHeight/4;  </span><br><span class="line">          </span><br><span class="line">        fm.ascent=-bottom;  </span><br><span class="line">        fm.top=-bottom;  </span><br><span class="line">        fm.bottom=top;  </span><br><span class="line">        fm.descent=top;  </span><br><span class="line">       &#125;  </span><br><span class="line">       return rect.right;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li>到这就完成了图文居中的功能，效果图<br><img src="http://dinson-blog.hdinson.cn/FqIDeDcW0kEl2_U1GHhlaPia6hi6.png" alt=""></li></ul><h2 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Context;  </span><br><span class="line">import android.graphics.Canvas;  </span><br><span class="line">import android.graphics.Paint;  </span><br><span class="line">import android.graphics.Paint.FontMetricsInt;  </span><br><span class="line">import android.graphics.Rect;  </span><br><span class="line">import android.graphics.drawable.Drawable;  </span><br><span class="line">import android.os.Bundle;  </span><br><span class="line">import android.support.v7.app.ActionBarActivity;  </span><br><span class="line">import android.text.SpannableString;  </span><br><span class="line">import android.text.Spanned;  </span><br><span class="line">import android.text.style.ImageSpan;  </span><br><span class="line">import android.widget.TextView;  </span><br><span class="line">  </span><br><span class="line">public class MainActivity extends ActionBarActivity &#123;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;  </span><br><span class="line">        super.onCreate(savedInstanceState);  </span><br><span class="line">        TextView textView=new TextView(this);  </span><br><span class="line">        setContentView(textView);  </span><br><span class="line">        SpannableString showString = new SpannableString(&quot;1234533333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333336&quot;);  </span><br><span class="line">        MyIm imageSpan=new MyIm(this, R.drawable.ic_launcher);  </span><br><span class="line">        MyIm imageSpan2=new MyIm(this, R.drawable.ic_launcher);  </span><br><span class="line">        MyIm imageSpan21=new MyIm(this, R.drawable.ic_launcher);  </span><br><span class="line">        showString.setSpan(imageSpan, 2, 3, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);  </span><br><span class="line">        showString.setSpan(imageSpan2, 27, 30, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);  </span><br><span class="line">        showString.setSpan(imageSpan21, 77, 78, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);  </span><br><span class="line">        textView.setText(showString);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public class MyIm extends ImageSpan  </span><br><span class="line">    &#123;  </span><br><span class="line">        public MyIm(Context arg0,int arg1) &#123;  </span><br><span class="line">            super(arg0, arg1);  </span><br><span class="line">        &#125;  </span><br><span class="line">        public int getSize(Paint paint, CharSequence text, int start, int end,  </span><br><span class="line">                FontMetricsInt fm) &#123;  </span><br><span class="line">            Drawable d = getDrawable();  </span><br><span class="line">            Rect rect = d.getBounds();  </span><br><span class="line">            if (fm != null) &#123;  </span><br><span class="line">                FontMetricsInt fmPaint=paint.getFontMetricsInt();  </span><br><span class="line">                int fontHeight = fmPaint.bottom - fmPaint.top;  </span><br><span class="line">                int drHeight=rect.bottom-rect.top;  </span><br><span class="line">                  </span><br><span class="line">                int top= drHeight/2 - fontHeight/4;  </span><br><span class="line">                int bottom=drHeight/2 + fontHeight/4;  </span><br><span class="line">                  </span><br><span class="line">                fm.ascent=-bottom;  </span><br><span class="line">                fm.top=-bottom;  </span><br><span class="line">                fm.bottom=top;  </span><br><span class="line">                fm.descent=top;  </span><br><span class="line">            &#125;  </span><br><span class="line">            return rect.right;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        @Override  </span><br><span class="line">        public void draw(Canvas canvas, CharSequence text, int start, int end,  </span><br><span class="line">                float x, int top, int y, int bottom, Paint paint) &#123;  </span><br><span class="line">            Drawable b = getDrawable();  </span><br><span class="line">            canvas.save();  </span><br><span class="line">            int transY = 0;  </span><br><span class="line">            transY = ((bottom-top) - b.getBounds().bottom)/2+top;  </span><br><span class="line">            canvas.translate(x, transY);  </span><br><span class="line">            b.draw(canvas);  </span><br><span class="line">            canvas.restore();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ImageSpan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewPager系列--仿掌上英雄联盟皮肤浏览效果</title>
      <link href="/2017/06/05/17-06-05/"/>
      <url>/2017/06/05/17-06-05/</url>
      
        <content type="html"><![CDATA[<p><img src="http://dinson-blog.hdinson.cn/FmjGWAiWMMiAjxY_Vm62n0eG1YHV.png" alt=""></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>这几天英雄联盟搞活动，抽到一个安妮限定皮肤，可把我乐坏了，于是马上就登陆掌盟客户端查看皮肤。进入皮肤浏览界面之后，觉得这个皮肤浏览的效果还真不错，如下图：</p></blockquote><span id="more"></span><!-- 这是　　缩进--><p><img src="http://dinson-blog.hdinson.cn/FjjJDYCF8cKiXXWmFMl3f9DOBimg.png" alt=""></p><h2 id="思路与分析"><a href="#思路与分析" class="headerlink" title="思路与分析"></a>思路与分析</h2><p>在开始写代码之前，我们还是来分析一下界面元素，和该用什么技术来实现各个部分。</p><ol><li>首先是整个界面的滑动，我们肯定一眼就能看出来，用ViewPager 实现。</li><li>ViewPager 滑动时有放大缩小的动画，用ViewPager.Transfoemer 轻松搞定。</li><li>ViewPager 显示多页（展示前后页面的部分）。</li><li>界面图片的形状，旋转90度的等腰梯形。这个只能用自定义View来实现了。</li><li>整个界面的背景为当前显示图片的高斯模糊图。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>上面分析了界面的构成元素，那么现在我们就来看一下具体的实现。</p><h3 id="1-ViewPager-展示多页"><a href="#1-ViewPager-展示多页" class="headerlink" title="1. ViewPager 展示多页"></a>1. ViewPager 展示多页</h3><p>这个问题在我们前一篇文章已经讲过，这里不再重复，就是用ViewGroup 的 clipChildren 属性，值为false。也就是在整个布局的跟节点添加下面一行代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:clipChildren=&quot;false&quot;</span><br></pre></td></tr></table></figure><br>然后，ViewPager需要设置左右Margin,也就是前后页显示的位置<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v4.view.ViewPager</span><br><span class="line">           android:id=&quot;@+id/my_viewpager&quot;</span><br><span class="line">           android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;300dp&quot;</span><br><span class="line">           android:clipChildren=&quot;false&quot;</span><br><span class="line">           android:layout_marginLeft=&quot;50dp&quot;</span><br><span class="line">           android:layout_marginRight=&quot;50dp&quot;</span><br><span class="line">           android:layout_centerInParent=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><br>从上面的效果图可以看到，当前页和前后页的部分是有间距的，我们只需要在Item布局中左右添加margin属性：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:layout_marginLeft=&quot;30dp&quot;</span><br><span class="line">android:layout_marginRight=&quot;30dp&quot;</span><br></pre></td></tr></table></figure><br>好了，这样ViewPager就能显示多页，并且当前页和前后页之间还有一定的间距。</p><h3 id="2-ViewPager-切换时的动画"><a href="#2-ViewPager-切换时的动画" class="headerlink" title="2. ViewPager 切换时的动画"></a>2. ViewPager 切换时的动画</h3><p>ViewPager 切换时的自定义动画用<code>ViewPager.PageTransformer</code>, 这个在上一篇文章也讲过，没看过的倒回去看一下。这里不细讲了，直接上代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class CustomViewPagerTransformer implements ViewPager.PageTransformer &#123;</span><br><span class="line">    private int maxTranslateOffsetX;</span><br><span class="line">    private ViewPager viewPager;</span><br><span class="line">    private static final float MIN_SCALE = 0.75f;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public CustomViewPagerTransformer(Context context) &#123;</span><br><span class="line">        this.maxTranslateOffsetX = dp2px(context, 160);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void transformPage(View view, float position) &#123;</span><br><span class="line">        // position的可能性的值有，其实从官方示例的注释就能看出：</span><br><span class="line">        //[-Infinity,-1)  已经看不到了</span><br><span class="line">        // (1,+Infinity] 已经看不到了</span><br><span class="line">        // [-1,1]</span><br><span class="line">        // 而我们从写PageTransformer，操作View动画的重点区间就在[-1,1]</span><br><span class="line">        if (viewPager == null) &#123;</span><br><span class="line">            viewPager = (ViewPager) view.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        int leftInScreen = view.getLeft() - viewPager.getScrollX();</span><br><span class="line">        int centerXInViewPager = leftInScreen + view.getMeasuredWidth() / 2;</span><br><span class="line">        int offsetX = centerXInViewPager - viewPager.getMeasuredWidth() / 2;</span><br><span class="line">        float offsetRate = (float) offsetX * 0.38f / viewPager.getMeasuredWidth();</span><br><span class="line">        float scaleFactor = 1 - Math.abs(offsetRate);</span><br><span class="line">        if (scaleFactor &gt; 0) &#123;</span><br><span class="line">            view.setScaleX(scaleFactor);</span><br><span class="line">            view.setScaleY(scaleFactor);</span><br><span class="line">            view.setTranslationX(-maxTranslateOffsetX * offsetRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * dp和像素转换</span><br><span class="line">     */</span><br><span class="line">    private int dp2px(Context context, float dipValue) &#123;</span><br><span class="line">        float m = context.getResources().getDisplayMetrics().density;</span><br><span class="line">        return (int) (dipValue * m + 0.5f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-自定义多边形ImageView"><a href="#3-自定义多边形ImageView" class="headerlink" title="3. 自定义多边形ImageView"></a>3. 自定义多边形ImageView</h3><p>多边形ImageView，我们通过自定义的方式实现，继承ImageView, 然后重写onDraw()方法。这里实现这种不规则的多边形View有两种方法。</p><ul><li>使用PorterDuffXfermode，这种方法需要你给一个蒙板图片，在onDraw 方法中，先绘制蒙板图片，然后设置Paint的setXfermode 为PorterDuff.Mode.SRC_IN,再绘制要显示的图片，这样就能把显示的图片裁剪成蒙板的形状。</li><li>使用canvas的clipPath() 方法，我们用Path 来绘制多边形，然后clipPath() 将画布裁剪成绘制的形状，然后在绘制要显示的图片。</li></ul><p>关于PorterDuffXfermode 的更多用法，有兴趣的可以去google 一下，网上有很多相关的文章。<strong>这里我用的是两种方法的结合，先用clipPath得到一个需要形状的bitmap，然后使用PorterDuffXfermode。</strong>自定义View代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">public class PolygonView extends AppCompatImageView &#123;</span><br><span class="line">    private int mWidth = 0;</span><br><span class="line">    private int mHeight = 0;</span><br><span class="line"></span><br><span class="line">    private Paint mPaint;</span><br><span class="line">    private Paint mBorderPaint;</span><br><span class="line"></span><br><span class="line">    private PorterDuffXfermode mXfermode;</span><br><span class="line">    private Bitmap mBitmap;</span><br><span class="line">    private int mBorderWidth;</span><br><span class="line">    private Bitmap mMaskBitmap;</span><br><span class="line">    public PolygonView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PolygonView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PolygonView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init()&#123;</span><br><span class="line">        mBorderWidth = DisplayUtils.dpToPx(4);</span><br><span class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, null);// 关闭硬件加速加速</span><br><span class="line">        mPaint = new Paint();</span><br><span class="line">        mPaint.setAntiAlias(true);</span><br><span class="line">        mPaint.setColor(Color.RED);</span><br><span class="line">        mPaint.setDither(true);</span><br><span class="line"></span><br><span class="line">        mBorderPaint = new Paint();</span><br><span class="line">        mBorderPaint.setColor(Color.WHITE);</span><br><span class="line">        mBorderPaint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">        mBorderPaint.setAntiAlias(true);//抗锯齿</span><br><span class="line">        mBorderPaint.setDither(true);//防抖动</span><br><span class="line"></span><br><span class="line">        mXfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        mWidth = getMeasuredWidth();</span><br><span class="line">        mHeight = getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">        mMaskBitmap = getMaskBitmap();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setImageResource(@DrawableRes int resId) &#123;</span><br><span class="line">        super.setImageResource(resId);</span><br><span class="line">        mBitmap = BitmapFactory.decodeResource(getResources(),resId);</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line"></span><br><span class="line">        canvas.save();</span><br><span class="line"></span><br><span class="line">        canvas.drawBitmap(mMaskBitmap,0,0,mBorderPaint);</span><br><span class="line">        mPaint.setXfermode(mXfermode);</span><br><span class="line"></span><br><span class="line">        Bitmap bitmap = getCenterCropBitmap(mBitmap,mWidth,mHeight);</span><br><span class="line">        canvas.drawBitmap(bitmap,0,0,mPaint);</span><br><span class="line">        mPaint.setXfermode(null);</span><br><span class="line">        canvas.restore();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Bitmap getMaskBitmap()&#123;</span><br><span class="line">        Bitmap bm = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888);</span><br><span class="line">        Canvas c = new Canvas(bm);</span><br><span class="line"></span><br><span class="line">        Point point1 = new Point(0,30);</span><br><span class="line">        Point point2 = new Point(mWidth,0);</span><br><span class="line">        Point point3 = new Point(mWidth,mHeight);</span><br><span class="line">        Point point4 = new Point(0,mHeight - 30);</span><br><span class="line"></span><br><span class="line">        Path path = new Path();</span><br><span class="line">        path.moveTo(point1.x,point1.y);</span><br><span class="line">        path.lineTo(point2.x,point2.y);</span><br><span class="line">        path.lineTo(point3.x,point3.y);</span><br><span class="line">        path.lineTo(point4.x,point4.y);</span><br><span class="line">        path.close();</span><br><span class="line"></span><br><span class="line">        c.drawPath(path,mBorderPaint);</span><br><span class="line"></span><br><span class="line">        return bm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对原图进行等比裁剪</span><br><span class="line">     */</span><br><span class="line">    private Bitmap scaleImage(Bitmap bitmap)&#123;</span><br><span class="line"></span><br><span class="line">        if(bitmap!=null)&#123;</span><br><span class="line"></span><br><span class="line">            int widht=bitmap.getWidth();</span><br><span class="line">            int height=bitmap.getHeight();</span><br><span class="line"></span><br><span class="line">            int new_width=0;</span><br><span class="line">            int new_height=0;</span><br><span class="line"></span><br><span class="line">            if(widht!=height)&#123;</span><br><span class="line">                if(widht&gt;height)&#123;</span><br><span class="line">                    new_height=mHeight;</span><br><span class="line">                    new_width=widht*new_height/height;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    new_width=mWidth;</span><br><span class="line">                    new_height=height*new_width/widht;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                new_width=mWidth;</span><br><span class="line">                new_height=mHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            return Bitmap.createScaledBitmap(bitmap, new_width, new_height, true);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Bitmap getCenterCropBitmap(Bitmap src, float rectWidth, float rectHeight) &#123;</span><br><span class="line"></span><br><span class="line">        float srcRatio = ((float) src.getWidth()) / src.getHeight();</span><br><span class="line">        float rectRadio = rectWidth / rectHeight;</span><br><span class="line">        if (srcRatio &lt; rectRadio) &#123;</span><br><span class="line">            return Bitmap.createScaledBitmap(src, (int)rectWidth, (int)((rectWidth / src.getWidth()) * src.getHeight()), false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Bitmap.createScaledBitmap(src, (int)((rectHeight / src.getHeight()) * src.getWidth()), (int)rectHeight, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>建议：这里使用clipPath方法的时候，会出现很多锯齿，即使Paint 设置了抗锯齿也没啥用，所以建议使用PorterDuffXfermode 方法。要实现类似的效果，最好是找设计师要一张蒙板形状图。在用PorterDuffXfermode实现，简单效果好。</p></blockquote><p>通过上面的3步，其实整个 界面的效果差不多已经出来了，最后我们需要做的就是高斯模糊背景图。</p><h3 id="4-背景图高斯模"><a href="#4-背景图高斯模" class="headerlink" title="4. 背景图高斯模"></a>4. 背景图高斯模</h3><p>背景的高斯模糊就很简单了，前面我也有写过关于几种高斯模糊方法的对比（Android 图片高斯模糊解决方案），最后封装了一个方便的库(<a href="https://github.com/pinguo-zhouwei/EasyBlur)，只需要简单几行代码就行。我们在ViewPager的onPageSelect方法中，获取显示的图片，进行高斯模糊处理。">https://github.com/pinguo-zhouwei/EasyBlur)，只需要简单几行代码就行。我们在ViewPager的onPageSelect方法中，获取显示的图片，进行高斯模糊处理。</a><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onPageSelected(int position) &#123;</span><br><span class="line">    Bitmap source = BitmapFactory.decodeResource(getResources(),VPAdapter.RES[position]);</span><br><span class="line">    Bitmap bitmap = EasyBlur.with(getApplicationContext())</span><br><span class="line">            .bitmap(source)</span><br><span class="line">            .radius(20)</span><br><span class="line">            .blur();</span><br><span class="line">    mImageBg.setImageBitmap(bitmap);</span><br><span class="line"></span><br><span class="line">    mDesc.setText(mVPAdapter.getPageTitle(position));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="完整的布局文件和Activity代码"><a href="#完整的布局文件和Activity代码" class="headerlink" title="完整的布局文件和Activity代码"></a>完整的布局文件和Activity代码</h3><p>activity布局文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">                xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">                android:orientation=&quot;vertical&quot;</span><br><span class="line">                android:clipChildren=&quot;false&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!-- 高斯模糊背景--&gt;</span><br><span class="line">       &lt;ImageView</span><br><span class="line">           android:id=&quot;@+id/activity_bg&quot;</span><br><span class="line">           android:layout_width=&quot;match_parent&quot;</span><br><span class="line">           android:layout_height=&quot;match_parent&quot;</span><br><span class="line">           android:scaleType=&quot;centerCrop&quot;/&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!-- Toolbar--&gt;</span><br><span class="line">       &lt;RelativeLayout</span><br><span class="line">           android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">           android:layout_width=&quot;match_parent&quot;</span><br><span class="line">           android:layout_height=&quot;50dp&quot;&gt;</span><br><span class="line"></span><br><span class="line">              &lt;ImageView</span><br><span class="line">                  android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                  android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                  android:src=&quot;@drawable/navigation_back_white&quot;</span><br><span class="line">                  android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">                  android:layout_marginLeft=&quot;15dp&quot;/&gt;</span><br><span class="line"></span><br><span class="line">              &lt;TextView</span><br><span class="line">                  android:id=&quot;@+id/title_name&quot;</span><br><span class="line">                  android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                  android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                  android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">                  android:textSize=&quot;18sp&quot;</span><br><span class="line">                  android:textColor=&quot;@android:color/white&quot;/&gt;</span><br><span class="line">       &lt;/RelativeLayout&gt;</span><br><span class="line"></span><br><span class="line">       &lt;android.support.v4.view.ViewPager</span><br><span class="line">           android:id=&quot;@+id/my_viewpager&quot;</span><br><span class="line">           android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;300dp&quot;</span><br><span class="line">           android:clipChildren=&quot;false&quot;</span><br><span class="line">           android:layout_marginLeft=&quot;50dp&quot;</span><br><span class="line">           android:layout_marginRight=&quot;50dp&quot;</span><br><span class="line">           android:layout_centerInParent=&quot;true&quot;/&gt;</span><br><span class="line"></span><br><span class="line">       &lt;com.zhouwei.indicatorview.CircleIndicatorView</span><br><span class="line">           android:id=&quot;@+id/indicatorView&quot;</span><br><span class="line">           android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_alignParentBottom=&quot;true&quot;</span><br><span class="line">           android:layout_marginBottom=&quot;60dp&quot;</span><br><span class="line">           android:layout_centerHorizontal=&quot;true&quot;</span><br><span class="line">           app:indicatorSelectColor=&quot;#C79EFE&quot;</span><br><span class="line">           app:indicatorSpace=&quot;5dp&quot;</span><br><span class="line">           app:indicatorRadius=&quot;8dp&quot;</span><br><span class="line">           app:enableIndicatorSwitch=&quot;false&quot;</span><br><span class="line">           app:indicatorTextColor=&quot;@android:color/white&quot;</span><br><span class="line">           app:fill_mode=&quot;number&quot;</span><br><span class="line">           app:indicatorColor=&quot;#C79EFE&quot;/&gt;</span><br><span class="line"></span><br><span class="line">       &lt;TextView</span><br><span class="line">           android:id=&quot;@+id/skin_desc&quot;</span><br><span class="line">           android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_centerHorizontal=&quot;true&quot;</span><br><span class="line">           android:layout_below=&quot;@+id/my_viewpager&quot;</span><br><span class="line">           android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">           android:textColor=&quot;@android:color/white&quot;</span><br><span class="line">           android:textSize=&quot;18sp&quot;/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure></p><p>Activity代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class ViewPagerActivity extends AppCompatActivity &#123;</span><br><span class="line">    private ViewPager mViewPager;</span><br><span class="line">    private VPAdapter mVPAdapter;</span><br><span class="line">    private ImageView mImageBg;</span><br><span class="line">    private CircleIndicatorView mCircleIndicatorView;</span><br><span class="line">    private TextView mTitle,mDesc;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.viewpager_transform_layout);</span><br><span class="line">        View view = findViewById(R.id.toolbar);</span><br><span class="line">        StatusBarUtils.setTranslucentImageHeader(this, 0,view);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        mViewPager = (ViewPager) findViewById(R.id.my_viewpager);</span><br><span class="line">        mImageBg = (ImageView) findViewById(R.id.activity_bg);</span><br><span class="line">        mCircleIndicatorView = (CircleIndicatorView) findViewById(R.id.indicatorView);</span><br><span class="line">        mTitle = (TextView) findViewById(R.id.title_name);</span><br><span class="line">        mDesc = (TextView) findViewById(R.id.skin_desc);</span><br><span class="line"></span><br><span class="line">        mTitle.setText(&quot;黑暗之女&quot;);</span><br><span class="line">        mViewPager.setPageTransformer(false,new CustomViewPagerTransformer(this));</span><br><span class="line">        // 添加监听器</span><br><span class="line">        mViewPager.addOnPageChangeListener(onPageChangeListener);</span><br><span class="line">        mVPAdapter = new VPAdapter(getSupportFragmentManager());</span><br><span class="line">        mViewPager.setAdapter(mVPAdapter);</span><br><span class="line">        mViewPager.setOffscreenPageLimit(3);</span><br><span class="line">        //  Indicator 和ViewPager 建立关联</span><br><span class="line">        mCircleIndicatorView.setUpWithViewPager(mViewPager);</span><br><span class="line">        // 首次进入展示第二页</span><br><span class="line">        mViewPager.setCurrentItem(1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        return mViewPager.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ViewPager.OnPageChangeListener onPageChangeListener = new ViewPager.OnPageChangeListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onPageSelected(int position) &#123;</span><br><span class="line">            Bitmap source = BitmapFactory.decodeResource(getResources(),VPAdapter.RES[position]);</span><br><span class="line">            Bitmap bitmap = EasyBlur.with(getApplicationContext())</span><br><span class="line">                    .bitmap(source)</span><br><span class="line">                    .radius(20)</span><br><span class="line">                    .blur();</span><br><span class="line">            mImageBg.setImageBitmap(bitmap);</span><br><span class="line"></span><br><span class="line">            mDesc.setText(mVPAdapter.getPageTitle(position));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onPageScrollStateChanged(int state) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ViewPager的每一个页面用Fragment 来展示的，Fragment代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ItemFragment extends Fragment &#123;</span><br><span class="line">    private PolygonView mPolygonView;</span><br><span class="line">    public static ItemFragment newInstance(int resId)&#123;</span><br><span class="line">        ItemFragment itemFragment = new ItemFragment();</span><br><span class="line">        Bundle bundle = new Bundle();</span><br><span class="line">        bundle.putInt(&quot;resId&quot;,resId);</span><br><span class="line">        itemFragment.setArguments(bundle);</span><br><span class="line">        return itemFragment;</span><br><span class="line">    &#125;</span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.view_pager_muti_layout,null);</span><br><span class="line">        mPolygonView = (PolygonView) view.findViewById(R.id.item_image);</span><br><span class="line">        // 做一个属性动画</span><br><span class="line">        ObjectAnimator animator = ObjectAnimator.ofFloat(mPolygonView,&quot;rotation&quot;,0f,10f);</span><br><span class="line">        animator.setDuration(10);</span><br><span class="line">        animator.start();</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onViewCreated(view, savedInstanceState);</span><br><span class="line">        int resId = getArguments().getInt(&quot;resId&quot;);</span><br><span class="line">        mPolygonView.setImageResource(resId);// 设置图片</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>说明：在Fragment中对PolygonView做了一个旋转的动画，是因为PolygonView 是一个竖着的等腰梯形，但是看效果图，其实不是，还有一个小幅度的旋转，如果将这个旋转放在PolygonView 里面做的话，发现每次ViewPager 切换的时候，都有一个旋转动画，效果不好，因此将动画放在这里。应该还有其他更优雅一点的方法，有兴趣的可以去试一下。</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote><p>本篇文章是ViewPager 系列的第三篇文章，也是这个系列的最后一些文章，这三篇文章总结了ViewPager 的一些常用方法，如Banner 、切换动画等等。还讲了如何封装一个扩展性强，比较通用的ViewPager。这也是对自己以前用过的这些知识点的一个总结和沉淀。</p></blockquote><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ViewPager系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewPager系列--仿魅族应用的广告BannerView</title>
      <link href="/2017/06/04/17-06-04/"/>
      <url>/2017/06/04/17-06-04/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Banner广告位是APP 中的一个非常重要的位置，为什么呢？因为它能带来money。是一个公司很重要的一个营收点。像那种用户数基数特别大的产品，如facebook、twitter、QQ、微信等等。Banner广告位日营收估计得上千万美刀（猜的,不知道具体数据）。一个漂亮的Banner往往能够吸引用户的眼球，引导用户点击，从而提高转化率。遗憾的是现在的大多数产品的Banner都是千篇一律的，没有什么亮点可言。但是前几天在魅族手机上发现了一个效果不错的Banner，魅族所有自家的APP所用的Banner 引起了我的注意。效果是这样子的：</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/Fttnl93cLxhrr5tGpwIB0UCkAQd7.png" alt=""></p><span id="more"></span><!-- 这是　　缩进--><p>看到这个Banner 第一眼就吸引了我，随后就反复的体验了几次了，感觉这种Banner的效果还不错。最后想着高仿一个和这种效果差不多的BannerView 。那么本文就讲一下如何实现这样一个BannerView。最终实现的效果如下：<br><img src="http://dinson-blog.hdinson.cn/FuCyfbpuGyHRcvgxpo3gqUwb7rrL.png" alt=""></p><h2 id="仿魅族Banner-效果"><a href="#仿魅族Banner-效果" class="headerlink" title="仿魅族Banner 效果"></a>仿魅族Banner 效果</h2><p>在开始实现魅族Banner效果之前，我们先来整理一下实现一个BannerView的思路，首先需要用ViewPager，其次让ViewPager无限轮播。其实BannerView就是一个无限轮播的ViewPager，然后做一些封装处理，让使用更加简单就ok。</p><p>现在我们在来看一下魅族的这个Banner。他与普通的banner的区别是当前页显示了前一页和后一页的部分内容。<br><img src="http://dinson-blog.hdinson.cn/FueAFj7emV2N7kqhC6yYc7Bv5dYa.png" alt=""></p><p>抛开切换时的动画先不说，要实现这个效果的第一步就是要让ViewPager在一个页面显示多页的内容（当前页＋前后页部分）。</p><h2 id="ViewPager展示多页"><a href="#ViewPager展示多页" class="headerlink" title="ViewPager展示多页"></a>ViewPager展示多页</h2><p>要让ViewPager页面展示多页的内容，就要用到ViewGroup的一个强大的属性。这个属性虽然强大，但是也不常用，可能有些小伙伴不知道(之前我也没用过…)，那就是<code>clipChildren</code>属性。这个属性有什么作用呢，我们看一下它的文档介绍：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * By default, children are clipped to their bounds before drawing. This</span><br><span class="line"> * allows view groups to override this behavior for animations, etc.</span><br><span class="line"> *</span><br><span class="line"> * @param clipChildren true to clip children to their bounds,</span><br><span class="line"> *        false otherwise</span><br><span class="line"> * @attr ref android.R.styleable#ViewGroup_clipChildren</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p><strong>clipChildren: </strong>默认值为true, 子View 的大小只能在父View规定的范围之内，比如父View的高为50，子View的高为60 ,那么多处的部分就会被裁剪。如果我们设置这个值为false的话，那么多处的部分就不会被裁剪了。</p><p>这里我们就可以利用这个属性来实现了这个效果了，我们设置ViewPager的父布局的clipChildren为false。然后设置ViewPager 左右一定的边距，那么左右就空出了一定的区域，利用<code>clipChildren</code>属性，就能让前后页面的部分显示在当前页了。布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:clipChildren=&quot;false&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &lt;android.support.v4.view.ViewPager</span><br><span class="line">       android:id=&quot;@+id/view_pager&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;200dp&quot;</span><br><span class="line">       android:layout_marginLeft=&quot;30dp&quot;</span><br><span class="line">       android:layout_marginRight=&quot;30dp&quot;</span><br><span class="line">       /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>这样就能实现ViewPager 展示前后页面的部分内容。</p><h2 id="自定义ViewPager-PageTransformer动画"><a href="#自定义ViewPager-PageTransformer动画" class="headerlink" title="自定义ViewPager.PageTransformer动画"></a>自定义ViewPager.PageTransformer动画</h2><p>上面实现了ViewPager当前页面显示前后页的部分内容，但是从最开始魅族的Banner效果我们可以看出，滑动的时候是有 一个放大缩小的动画的。左右显示的部分有一定比例的缩小。这就要用到ViewPager.PageTransformer了。</p><p>ViewPager.PageTransformer 干什么的呢？ViewPager.PageTransformer 是用来做ViewPager切换动画的，它是一个接口，里面只有一个方法<code>transformPage</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface PageTransformer &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Apply a property transformation to the given page.</span><br><span class="line">     *</span><br><span class="line">     * @param page Apply the transformation to this page</span><br><span class="line">     * @param position Position of page relative to the current front-and-center</span><br><span class="line">     *                 position of the pager. 0 is front and center. 1 is one full</span><br><span class="line">     *                 page position to the right, and -1 is one page position to the left.</span><br><span class="line">     */</span><br><span class="line">    void transformPage(View page, float position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然只有一个方法，但是它很强大，它能反映出在ViewPager滑动过程中，各个View的位置变化。我们拿到了这些位置变化，就能在这个过程中对View做各种各样的动画了。</p><p>要自定义动画，我们就来需要知道positon这个值的变化区间。从官方给的ViewPager的两个示例我们知道，position的变换有三个区间［－Infinity，－1），［－1，1］，（1.Infinity）。</p><ul><li>［－Infinity，－1）：已经在屏幕之外，看不到了</li><li>（1.Infinity）： 已经在屏幕之外，看不到了。</li><li>［－1，1］： 这个区间是我门操作View动画的重点区间。</li></ul><p>我们来看一下官方对于position的解释：</p><blockquote><p><strong>官方的解释：</strong>The position parameter indicates where a given page is located relative to the center of the screen. It is a dynamic property that changes as the user scrolls through the pages. When a page fills the screen, its position value is 0. When a page is drawn just off the right side of the screen, its position value is 1. If the user scrolls halfway between pages one and two, page one has a position of -0.5 and page two has a position of 0.5.</p></blockquote><p><strong>根据解释，也就是说当前停留的页面的位置为 0，右边屏幕之外绘制的这个页面位置为 1。那么，A 页面滑到 B 页面有 2 种情况：第一种：左边划出屏幕，那么 A：0 －&gt; －1,B :1 -&gt; 0。第二种：右边划出屏幕，A：0-&gt;1, B :-1-&gt; 0</strong></p><p>了解了这个方法的变化后，我们就来自定义我们的切换动画,这里很简单，我们只需要一个scale动画。代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CustomTransformer implements ViewPager.PageTransformer &#123;</span><br><span class="line">    private static final float MIN_SCALE = 0.9F;</span><br><span class="line">    @Override</span><br><span class="line">    public void transformPage(View page, float position) &#123;</span><br><span class="line"></span><br><span class="line">        if(position &lt; -1)&#123;</span><br><span class="line">            page.setScaleY(MIN_SCALE);</span><br><span class="line">        &#125;else if(position&lt;= 1)&#123;</span><br><span class="line">            //</span><br><span class="line">            float scale = Math.max(MIN_SCALE,1 - Math.abs(position));</span><br><span class="line">            page.setScaleY(scale);</span><br><span class="line">            /*page.setScaleX(scale);</span><br><span class="line"></span><br><span class="line">            if(position&lt;0)&#123;</span><br><span class="line">                page.setTranslationX(width * (1 - scale) /2);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                page.setTranslationX(-width * (1 - scale) /2);</span><br><span class="line">            &#125;*/</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            page.setScaleY(MIN_SCALE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="http://dinson-blog.hdinson.cn/FkipOvMPS9j8n8KIul1r3Sao59CW.png" alt=""><br>到此，我们仿魅族Banner的静态效果就实现了。接下来我们就要让Banner动起来，实现无限轮播效果。</p><h2 id="图片轮播"><a href="#图片轮播" class="headerlink" title="图片轮播"></a>图片轮播</h2><p>上面我们已经实现了Bannerd的静态展示和切换动画，那么我们现在就需要让Banner动起来，实现无限轮播。</p><p>ViewPager实现Banner无效轮播效果有2种方案,第一种是：在列表的最前面插入最后一条数据，在列表末尾插入第一个数据，造成循环的假象。第二种方案是：采用getCount 返回 Integer.MAX_VALUE。结下来分别看一下这两种方案。</p><ol><li>在列表的最前面插入最后一条数据，在列表末尾插入第一个数据，造成循环的假象。<br>这种方法是怎么做的呢？，是这样的：假如我们的列表有3条数据，用三个页面展示，分别编号为1，2，3。我们再创建一个新的列表，长度为真实列表的长度＋2，也就是5。在最前面插入最后一条数据，然后在末尾插入第一条数据。新列表就变成了这样了，3－1－2－3－1。如果当前滑到的是0位置（页面3）,那就通过ViewPager的setCurrentItem(int item, boolean smoothScroll)方法神不知鬼不觉的切换到3位置（页面3），当滑到4的位置时(页面1),也用这个方法滑到1位置（页面1）。这样给我们的感觉就是无限轮播了。来一张图辅助理解一下。<br><img src="http://dinson-blog.hdinson.cn/Fll56ELZOT9sVMQm6QO1cSp-vNRJ.png" alt=""></li><li>采用getCount 返回 Integer.MAX_VALUE<br>让ViewPager 的Adapter getCount 方法返回一个很大的数（这里用Integer.MAX_VALUE），理论上可以无限滑动。当显示完一个真实列表的周期后，又从真实列表的0位置显示数据，造成无限循环轮播的假象。开始时调用 mViewPager.setCurrentItem(Integer.MAX_VALUE /2)设置选中中间位置，这样最开始就可以向左滑动。关键代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int currentItem = getStartSelectItem();</span><br><span class="line"></span><br><span class="line">//设置当前选中的Item</span><br><span class="line"> mViewPager.setCurrentItem(currentItem);</span><br><span class="line"></span><br><span class="line"> private int getStartSelectItem()&#123;</span><br><span class="line">        // 我们设置当前选中的位置为Integer.MAX_VALUE / 2,这样开始就能往左滑动</span><br><span class="line">        // 但是要保证这个值与getRealPosition 的 余数为0，因为要从第一页开始显示</span><br><span class="line">        int currentItem = Integer.MAX_VALUE / 2;</span><br><span class="line">        if(currentItem % getRealCount()  ==0 )&#123;</span><br><span class="line">            return currentItem;</span><br><span class="line">        &#125;</span><br><span class="line">        // 直到找到从0开始的位置</span><br><span class="line">        while (currentItem % getRealCount()  != 0)&#123;</span><br><span class="line">            currentItem++;</span><br><span class="line">        &#125;</span><br><span class="line">        return currentItem;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>3 . 两种方案选哪一种？<br>两种方案我都试了一下，都可以实现轮播，但是第一种 方案在有切换动画的时候是有问题的，因为上面我们说了滑动到最后一页切换到第一页时，用的是ViewPager的setCurrentItem(int item, boolean smoothScroll)方法，smoothScroll 的值为false,这样界面就感觉不到我们偷偷的切换。但是这样切换就没有了动画。这样每次切换就会很生硬，因此就抛弃这种方法。选择第二种方案。<br>轮播我们采用Hanlder的postDelayed方法，关键代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable mLoopRunnable = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if(mIsAutoPlay)&#123;</span><br><span class="line">            mCurrentItem = mViewPager.getCurrentItem();</span><br><span class="line">            mCurrentItem++;</span><br><span class="line">            if(mCurrentItem == mAdapter.getCount() - 1)&#123;</span><br><span class="line">                mCurrentItem = 0;</span><br><span class="line">                mViewPager.setCurrentItem(mCurrentItem,false);</span><br><span class="line">                mHandler.postDelayed(this,mDelayedTime);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                mViewPager.setCurrentItem(mCurrentItem);</span><br><span class="line">                mHandler.postDelayed(this,mDelayedTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            mHandler.postDelayed(this,mDelayedTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在Adapter instantiateItem(ViewGroup container, final int position) 中，现在的这个position是一个很大的数字，我们需要将它转换成一个真实的position，否则会越界报错。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final int realPosition = position % getRealCount();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取真实的Count</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private int getRealCount()&#123;</span><br><span class="line">    return  mDatas==null ? 0:mDatas.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>通过以上就实现了仿魅族的BannerView，但是这还没完，虽然功能实现了，要想在任何地方拿来就可以使用，简单方便，我们还需要进一步的封装。</li></ol><h2 id="封装轮子：MZBannerView"><a href="#封装轮子：MZBannerView" class="headerlink" title="封装轮子：MZBannerView"></a>封装轮子：MZBannerView</h2><p>通过上面几步就可以实现仿魅族的BannerView,但是为了使用方便，我们将它封装成一个库，前面一篇文章讲了，如何封装一个通用的ViewPager（文章地址：ViewPager系列之 打造一个通用的ViewPager）。既然要想Banner使用方便，我们也需要封装得通用，可扩展。因为我们的Banner也是用ViewPager 实现的，因此，我们可用上一篇文章的方法，封装一个通用的BannerView。</p><p>MZBannerView 有以下功能：</p><ol><li>仿魅族BannerView 效果。</li><li>当普通Banner 使用</li><li>当普通ViewPager 使用。</li><li>当普通ViewPager使用(有魅族Banner效果)</li></ol><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><div class="table-container"><table><thead><tr><th>属性名</th><th>属性意义</th><th>取值</th></tr></thead><tbody><tr><td>open_mz_mode</td><td>是否开启魅族模式</td><td>true 为魅族Banner效果，false 则普通Banner效果</td></tr><tr><td>canLoop</td><td>是否轮播</td><td>true 轮播，false 则为普通ViewPager</td></tr><tr><td>indicatorPaddingLeft</td><td>设置指示器距离左侧的距离</td><td>单位为 dp 的值</td></tr><tr><td>indicatorPaddingRight</td><td>设置指示器距离右侧的距离</td><td>单位为 dp 的值</td></tr><tr><td>indicatorAlign</td><td>设置指示器的位置</td><td>有三个取值：left 左边，center 剧中显示，right 右侧显示</td></tr></tbody></table></div><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>xml 布局文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.example.dinson.MZBannerView</span><br><span class="line">      android:id=&quot;@+id/banner&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;200dp&quot;</span><br><span class="line">      android:layout_marginTop=&quot;10dp&quot;</span><br><span class="line">      app:open_mz_mode=&quot;true&quot;</span><br><span class="line">      app:canLoop=&quot;true&quot;</span><br><span class="line">      app:indicatorAlign=&quot;center&quot;</span><br><span class="line">      app:indicatorPaddingLeft=&quot;10dp&quot;</span><br><span class="line">      /&gt;</span><br></pre></td></tr></table></figure><br>activity中代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> mMZBanner = (MZBannerView) view.findViewById(R.id.banner);</span><br><span class="line"> // 设置页面点击事件</span><br><span class="line"> mMZBanner.setBannerPageClickListener(new MZBannerView.BannerPageClickListener() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void onPageClick(View view, int position) &#123;</span><br><span class="line">         Toast.makeText(getContext(),&quot;click page:&quot;+position,Toast.LENGTH_LONG).show();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"> for(int i=0;i&lt;RES.length;i++)&#123;</span><br><span class="line">     list.add(RES[i]);</span><br><span class="line"> &#125;</span><br><span class="line">// 设置数据</span><br><span class="line"> mMZBanner.setPages(list, new MZHolderCreator&lt;BannerViewHolder&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public BannerViewHolder createViewHolder() &#123;</span><br><span class="line">         return new BannerViewHolder();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> public static class BannerViewHolder implements MZViewHolder&lt;Integer&gt; &#123;</span><br><span class="line">     private ImageView mImageView;</span><br><span class="line">     @Override</span><br><span class="line">     public View createView(Context context) &#123;</span><br><span class="line">         // 返回页面布局文件</span><br><span class="line">         View view = LayoutInflater.from(context).inflate(R.layout.banner_item,null);</span><br><span class="line">         mImageView = (ImageView) view.findViewById(R.id.banner_image);</span><br><span class="line">         return view;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     @Override</span><br><span class="line">     public void onBind(Context context, int position, Integer data) &#123;</span><br><span class="line">         // 数据绑定</span><br><span class="line">         mImageView.setImageResource(data);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>如果是当Banner使用，注意在onResume 中调用start()方法，在onPause中调用 pause() 方法。如果当普通ViewPager使用，则不需要。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onPause() &#123;</span><br><span class="line">    super.onPause();</span><br><span class="line">    mMZBanner.pause();//暂停轮播</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onResume() &#123;</span><br><span class="line">    super.onResume();</span><br><span class="line">    mMZBanner.start();//开始轮播</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其他对外API<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/******************************************************************************************************/</span><br><span class="line">/**                             对外API                                                               **/</span><br><span class="line">/******************************************************************************************************/</span><br><span class="line">//开始轮播</span><br><span class="line"> start()</span><br><span class="line">//停止轮播</span><br><span class="line"> pause()</span><br><span class="line"></span><br><span class="line">//设置BannerView 的切换时间间隔</span><br><span class="line"> setDelayedTime(int delayedTime)</span><br><span class="line">// 设置页面改变监听器</span><br><span class="line">addPageChangeLisnter(ViewPager.OnPageChangeListener onPageChangeListener)</span><br><span class="line"></span><br><span class="line">//添加Page点击事件</span><br><span class="line"> setBannerPageClickListener(BannerPageClickListener bannerPageClickListener)</span><br><span class="line">//设置是否显示Indicator</span><br><span class="line">setIndicatorVisible(boolean visible)</span><br><span class="line">// 获取ViewPager</span><br><span class="line">ViewPager getViewPager()</span><br><span class="line">// 设置 Indicator资源</span><br><span class="line">setIndicatorRes(int unSelectRes,int selectRes)</span><br><span class="line">//设置页面数据</span><br><span class="line">setPages(List&lt;T&gt; datas,MZHolderCreator mzHolderCreator)</span><br><span class="line">//设置指示器显示位置</span><br><span class="line">setIndicatorAlign(IndicatorAlign indicatorAlign)</span><br><span class="line">//设置ViewPager（Banner）切换速度</span><br><span class="line">setDuration(int duration)</span><br></pre></td></tr></table></figure></p><p>因为是对ViewPager的包装，所有要设置某些ViewPager的属性，可以通过getViewPager 获取到ViewPager再设置对应属性</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲了如何实现一个仿魅族Banner效果。其中讲了一些关键的点和关键代码。其实普通的BannerView 是一样的，只是少了动画而已。最后，将这些功能封装成了一个通用的BannerView 控件。这个控件既有仿魅族Banner的效果，又可以当普通Banner使用。而且还可以当作一个普通的ViewPager使用。</p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ViewPager系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewPager系列--打造一个通用的ViewPager</title>
      <link href="/2017/06/03/17-06-03/"/>
      <url>/2017/06/03/17-06-03/</url>
      
        <content type="html"><![CDATA[<p><img src="http://dinson-blog.hdinson.cn/Fp12BE__fI69mJ45l7jGBc-Ktk5K.png" alt=""></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>ViewPager是Android开发者比较常用的一个控件了，由于它允许数据页从左到右或者从右到左翻页，因此这种交互也备受设计师的青睐。在APP中的很多场景都用得到，比如第一次安装APP时的用户引导页、图片浏览时左右翻页、广告Banner页等等都会用到ViewPager。ViewPager 的使用和RecyclerView的使用方式很相似，熟悉RecyclerView的朋友都知道，我们要使用RecyclerView，就得给RecyclerView提供一个Adapter来提供布局和装载数据。但是有一个比较麻烦的事情是，我们每次使用RecyclerView都要给他提供一个Adapter,并且这些Adapter中的一些方法和代码都是相同的，这使得我们写了很多重复的代码，降低了我们的开发效率，因此github有各种个样的对RecyclerView 的再度封装，目的就是减少这些重复的代码，尽量代码复用，使开发更简单。那么ViewPager的使用和RecyclerView 是非常相似的，我们同样也是给ViewPager提供一个Adapter来提供布局和装载数据。写Adapter的时候同样会写很多重复代码，那么我们是否能像RecyclerView一样，也对Viewpager来做一个再次封装，达到复用和简单的效果呢？答案是肯定的，因此这篇文章就一起来封装一个通用的ViewPager。</p></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>看过一些技术博客，对于普通的ViewPager使用封装的比较少，大多数的封装只是在用作Banner 的时候，也就是ViewPager 每页只显示一张图片。对外提供一个接口，传递一个imageUrl 数组就直接展示，不用再写其他的Adapter之类的。但是这样封装其实还是有一些局限性的。</p><ol><li>每个项目用的图片加载框架是不一样的，Picasso、Glide、ImageLoader等等各不相同，那么我们还需要在显示图片的时候换成自己用的图片加载框架才行。</li><li>并不是所有的Banner 都只是显示一张图片,还有各种个样的文案展示等等，因此不能个性化定制，这是比较致命的。</li></ol><blockquote><p>看看上面的局限性，是什么造成了这些局限性呢？<strong>答案是我们没有主动权，主动权在Adapter手中，他控制了布局，控制了数据绑定，所以它说怎样展示就怎样展示，它说展示什么就展示什么。</strong>那么现在问题的关键来了，我们又不想写Adapter,又想按照我们的指示展示布局和数据，怎么办呢？那就要从Adapter中夺回主动权，我们想ViewPager展示成什么样子我们自己说了算。Adapter只需要把我们提供给他的东西按照我们的指示展示就行了。具体的布局和数据绑定都我们自己控制。因此，<strong>有了主动权，展示什么布局我们能控制，用什么框架加载图片我们同样能控制。用什么方式来告诉Adapter 做页面展示呢？就用万能的接口啦。</strong></p></blockquote><h2 id="封装通用的ViewPager"><a href="#封装通用的ViewPager" class="headerlink" title="封装通用的ViewPager"></a>封装通用的ViewPager</h2><p>通过上面现状的分析，我们知道了，要封装一个比较通用的ViewPager,首先就是要从Adapter那里夺回主动权，因为它控制了布局和数据绑定。有了主动权之后，我们提供布局给Adapter，然后我们自己控制数据绑定。其中有2个关键的点：<strong>1，提供布局 。 2，数据绑定。</strong> 看到这两个点是不是觉得很熟悉？当然很熟悉，这不就是<code>RecyclerView</code>的<code>ViewHolder</code>干的事情嘛。既然是这样我们就借鉴一下 RecyclerView的ViewHolder呗。</p><h3 id="第一步：定义一个ViewHolder接口来提供布局和绑定数据：ViewPagerHolder代码如下："><a href="#第一步：定义一个ViewHolder接口来提供布局和绑定数据：ViewPagerHolder代码如下：" class="headerlink" title="第一步：定义一个ViewHolder接口来提供布局和绑定数据：ViewPagerHolder代码如下："></a>第一步：定义一个ViewHolder接口来提供布局和绑定数据：ViewPagerHolder代码如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface ViewPagerHolder&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     *  创建View</span><br><span class="line">     * @param context</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    View createView(Context context);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绑定数据</span><br><span class="line">     * @param context</span><br><span class="line">     * @param position</span><br><span class="line">     * @param data</span><br><span class="line">     */</span><br><span class="line">    void onBind(Context context,int position,T data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewPagerHolder</code>接收一个泛型T,这是绑定数据要用的实体类。其中有2个方法，一个提供给Adapter布局，另一个则用于绑定数据。</p><h3 id="第二步：-创建一个ViewHolder生成器，用来生成各种ViewHolder"><a href="#第二步：-创建一个ViewHolder生成器，用来生成各种ViewHolder" class="headerlink" title="第二步： 创建一个ViewHolder生成器，用来生成各种ViewHolder:"></a>第二步： 创建一个ViewHolder生成器，用来生成各种ViewHolder:</h3><p><code>ViewPagerHolderCreator</code> 代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ViewPagerHolderCreator&lt;VH extends ViewPagerHolder&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 创建ViewHolder</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public VH createViewHolder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该类接受一个 泛型，但是必须得是ViewPagerHolder 的子类，一个方法createViewHolder，返回ViewHolder实例。</p><h3 id="第三步：-重写-ViewPager-的Adapter："><a href="#第三步：-重写-ViewPager-的Adapter：" class="headerlink" title="第三步： 重写 ViewPager 的Adapter："></a>第三步： 重写 ViewPager 的Adapter：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class CommonViewPagerAdapter&lt;T&gt; extends PagerAdapter &#123;</span><br><span class="line">    private List&lt;T&gt; mDatas;</span><br><span class="line">    private ViewPagerHolderCreator mCreator;//ViewHolder生成器</span><br><span class="line"></span><br><span class="line">    public CommonViewPagerAdapter(List&lt;T&gt; datas, ViewPagerHolderCreator creator) &#123;</span><br><span class="line">        mDatas = datas;</span><br><span class="line">        mCreator = creator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return mDatas == null ? 0:mDatas.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isViewFromObject(View view, Object object) &#123;</span><br><span class="line">        return view == object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object instantiateItem(ViewGroup container, int position) &#123;</span><br><span class="line">        //重点就在这儿了，不再是把布局写死，而是用接口提供的布局</span><br><span class="line">        // 也不在这里绑定数据，数据绑定交给Api调用者。</span><br><span class="line">        View view = getView(position,null,container);</span><br><span class="line">        container.addView(view);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroyItem(ViewGroup container, int position, Object object) &#123;</span><br><span class="line">        container.removeView((View) object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取viewPager 页面展示View</span><br><span class="line">     * @param position</span><br><span class="line">     * @param view</span><br><span class="line">     * @param container</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private View getView(int position,View view ,ViewGroup container)&#123;</span><br><span class="line"></span><br><span class="line">        ViewPagerHolder holder =null;</span><br><span class="line">        if(view == null)&#123;</span><br><span class="line">            //创建Holder</span><br><span class="line">            holder = mCreator.createViewHolder();</span><br><span class="line">            view = holder.createView(container.getContext());</span><br><span class="line">            view.setTag(R.id.common_view_pager_item_tag,holder);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            holder = (ViewPagerHolder) view.getTag(R.id.common_view_pager_item_tag);</span><br><span class="line">        &#125;</span><br><span class="line">        if(holder!=null &amp;&amp; mDatas!=null &amp;&amp; mDatas.size()&gt;0)&#123;</span><br><span class="line">            // 数据绑定</span><br><span class="line">            holder.onBind(container.getContext(),position,mDatas.get(position));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个类比较重要，因为以前我们的布局提供和数据绑定都是在Adapter中的，因此现在我们就将这两项工作交给我们的ViewHolder。CommonViewPagerAdapter 的构造方法需要展示的数据集合和ViewPagerHolderCreator 生成器。其他代码都有注释一看便明白。</p></blockquote><h3 id="第四部：包装ViewPager"><a href="#第四部：包装ViewPager" class="headerlink" title="第四部：包装ViewPager"></a>第四部：包装ViewPager</h3><p>Adapter和ViewHolder都有了，现在我们只需要一个ViewPager 就大功告成了。我们采用自定义View 组合的方式来写这个ViewPager.<br>1 . 提供ViewPager 布局：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">                xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">                android:orientation=&quot;vertical&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">     &lt;!-- ViewPager--&gt;</span><br><span class="line"></span><br><span class="line">     &lt;android.support.v4.view.ViewPager</span><br><span class="line">         android:id=&quot;@+id/common_view_pager&quot;</span><br><span class="line">         android:layout_width=&quot;match_parent&quot;</span><br><span class="line">         android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- 指示器 indicatorView--&gt;</span><br><span class="line">     &lt;com.zhouwei.indicatorview.CircleIndicatorView</span><br><span class="line">         android:id=&quot;@+id/common_view_pager_indicator_view&quot;</span><br><span class="line">         android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">         android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">         android:layout_alignParentBottom=&quot;true&quot;</span><br><span class="line">         android:layout_marginBottom=&quot;10dp&quot;</span><br><span class="line">         app:indicatorSelectColor=&quot;@android:color/white&quot;</span><br><span class="line">         app:indicatorColor=&quot;@android:color/darker_gray&quot;</span><br><span class="line">         app:fill_mode=&quot;none&quot;</span><br><span class="line">         app:indicatorSpace=&quot;5dp&quot;</span><br><span class="line">         android:layout_centerHorizontal=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure></p><p>布局中一个ViewPager 和一个指示器View, IndicatorView 用的是前面分享的CircleIndicatorView 。博客地址：<a href="http://dinson.win/2017/06/02/17-06-02/">ViewPager系列—实现一个多功能的IndicatorView</a>。</p><p>2 . CommonViewPager ，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public class CommonViewPager&lt;T&gt; extends RelativeLayout &#123;</span><br><span class="line">    private ViewPager mViewPager;</span><br><span class="line">    private CommonViewPagerAdapter mAdapter;</span><br><span class="line">    private CircleIndicatorView mCircleIndicatorView;</span><br><span class="line">    public CommonViewPager(@NonNull Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CommonViewPager(@NonNull Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CommonViewPager(@NonNull Context context, @Nullable AttributeSet attrs, @AttrRes int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">    public CommonViewPager(@NonNull Context context, @Nullable AttributeSet attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init()&#123;</span><br><span class="line">        View view = LayoutInflater.from(getContext()).inflate(R.layout.common_view_pager_layout,this,true);</span><br><span class="line">        mViewPager = (ViewPager) view.findViewById(R.id.common_view_pager);</span><br><span class="line">        mCircleIndicatorView = (CircleIndicatorView) view.findViewById(R.id.common_view_pager_indicator_view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置数据</span><br><span class="line">     * @param data</span><br><span class="line">     * @param creator</span><br><span class="line">     */</span><br><span class="line">    public void setPages(List&lt;T&gt; data, ViewPagerHolderCreator creator)&#123;</span><br><span class="line">        mAdapter = new CommonViewPagerAdapter(data,creator);</span><br><span class="line">        mViewPager.setAdapter(mAdapter);</span><br><span class="line">        mAdapter.notifyDataSetChanged();</span><br><span class="line">        mCircleIndicatorView.setUpWithViewPager(mViewPager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCurrentItem(int currentItem)&#123;</span><br><span class="line">        mViewPager.setCurrentItem(currentItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCurrentItem()&#123;</span><br><span class="line">        return mViewPager.getCurrentItem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOffscreenPageLimit(int limit)&#123;</span><br><span class="line">        mViewPager.setOffscreenPageLimit(limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置切换动画，see &#123;@link ViewPager#setPageTransformer(boolean, ViewPager.PageTransformer)&#125;</span><br><span class="line">     * @param reverseDrawingOrder</span><br><span class="line">     * @param transformer</span><br><span class="line">     */</span><br><span class="line">    public void setPageTransformer(boolean reverseDrawingOrder, ViewPager.PageTransformer transformer)&#123;</span><br><span class="line">        mViewPager.setPageTransformer(reverseDrawingOrder,transformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * see &#123;@link ViewPager#setPageTransformer(boolean, ViewPager.PageTransformer)&#125;</span><br><span class="line">     * @param reverseDrawingOrder</span><br><span class="line">     * @param transformer</span><br><span class="line">     * @param pageLayerType</span><br><span class="line">     */</span><br><span class="line">    public void setPageTransformer(boolean reverseDrawingOrder, ViewPager.PageTransformer transformer,</span><br><span class="line">                                   int pageLayerType) &#123;</span><br><span class="line">        mViewPager.setPageTransformer(reverseDrawingOrder,transformer,pageLayerType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * see &#123;@link ViewPager#addOnPageChangeListener(ViewPager.OnPageChangeListener)&#125;</span><br><span class="line">     * @param listener</span><br><span class="line">     */</span><br><span class="line">    public void addOnPageChangeListener(ViewPager.OnPageChangeListener listener)&#123;</span><br><span class="line">        mViewPager.addOnPageChangeListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置是否显示Indicator</span><br><span class="line">     * @param visible</span><br><span class="line">     */</span><br><span class="line">    private void setIndicatorVisible(boolean visible)&#123;</span><br><span class="line">        if(visible)&#123;</span><br><span class="line">            mCircleIndicatorView.setVisibility(VISIBLE);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            mCircleIndicatorView.setVisibility(GONE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ViewPager getViewPager() &#123;</span><br><span class="line">        return mViewPager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>CommonViewPager 是对ViewPager的包装，提供了一些ViewPager的常用方法。 其中有一个非常重要的方法public void setPages(List<T> data, ViewPagerHolderCreator creator),提供数据和ViewHolder。其他的基本上都是ViewPager的方法。也可以通过getViewPager 获取到ViewPager 再调用ViewPager的方法。</p></blockquote><p>到此封装也就全部完成了。</p><h2 id="CommonViewPager-简便使用"><a href="#CommonViewPager-简便使用" class="headerlink" title="CommonViewPager 简便使用"></a>CommonViewPager 简便使用</h2><p>啰嗦了这么久的封装，那么用起来方便不呢？看一下就知道。<br>1.activity 布局文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;com.zhouwei.commonviewpager.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.zhouwei.viewpagerlib.CommonViewPager</span><br><span class="line">        android:id=&quot;@+id/activity_common_view_pager&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;200dp&quot;/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><br>ViewPager Item 的布局文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">              android:orientation=&quot;vertical&quot;</span><br><span class="line">              android:layout_width=&quot;match_parent&quot;</span><br><span class="line">              android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">   &lt;ImageView</span><br><span class="line">       android:id=&quot;@+id/viewPager_item_image&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;match_parent&quot;</span><br><span class="line">       android:scaleType=&quot;centerCrop&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:id=&quot;@+id/item_desc&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">       android:textSize=&quot;15sp&quot;</span><br><span class="line">       android:gravity=&quot;center&quot;</span><br><span class="line">       android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">       android:textColor=&quot;@android:color/white&quot;/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><br>Activity 代码:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private void initView() &#123;</span><br><span class="line">    mCommonViewPager = (CommonViewPager) findViewById(R.id.activity_common_view_pager);</span><br><span class="line">    // 设置数据</span><br><span class="line">    mCommonViewPager.setPages(mockData(), new ViewPagerHolderCreator&lt;ViewImageHolder&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public ViewImageHolder createViewHolder() &#123;</span><br><span class="line">            // 返回ViewPagerHolder</span><br><span class="line">            return new ViewImageHolder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 提供ViewPager展示的ViewHolder</span><br><span class="line"> * &lt;P&gt;用于提供布局和绑定数据&lt;/P&gt;</span><br><span class="line"> */</span><br><span class="line">public static class ViewImageHolder implements ViewPagerHolder&lt;DataEntry&gt;&#123;</span><br><span class="line">    private ImageView mImageView;</span><br><span class="line">    private TextView mTextView;</span><br><span class="line">    @Override</span><br><span class="line">    public View createView(Context context) &#123;</span><br><span class="line">        // 返回ViewPager 页面展示的布局</span><br><span class="line">        View view = LayoutInflater.from(context).inflate(R.layout.view_pager_item,null);</span><br><span class="line">        mImageView = (ImageView) view.findViewById(R.id.viewPager_item_image);</span><br><span class="line">        mTextView = (TextView) view.findViewById(R.id.item_desc);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onBind(Context context, int position, DataEntry data) &#123;</span><br><span class="line">       // 数据绑定</span><br><span class="line">       // 自己绑定数据，灵活度很大 </span><br><span class="line">       mImageView.setImageResource(data.imageResId);</span><br><span class="line">       mTextView.setText(data.desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码逻辑很清晰，也很简单，只需要提供一个ViewHolder,ViewHolder 自己实现，然后调用<code>setPages</code>方法绑定数据就好了。最后上一张效果图：<br><img src="http://dinson-blog.hdinson.cn/FtljxRS8tjZbq3ILOL39_xBwmt3s.gif" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章的这种封装思想不仅仅对于ViewPager,对于其他的展示集合数据的控件同样实用。其实整个封装还是蛮简单的，但是我觉得这种方法值得推广，以后像我们自己写一个扩展性比较强的控件时，就可以用这种方式。如果把这些一个个控件做成独立的通用的组件，那么我们开发的效率要提高很多。</p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ViewPager系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewPager系列--实现一个多功能的IndicatorView</title>
      <link href="/2017/06/02/17-06-02/"/>
      <url>/2017/06/02/17-06-02/</url>
      
        <content type="html"><![CDATA[<p><img src="http://dinson-blog.hdinson.cn/FjKXDufC34xZG2jcO9vhp-aIJPUH.png" alt=""></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Indicator (指示器) 可能大家都见的比较多了，在一个APP中，有很多场景都会用到Indicator，比如第一次安装APP 时的引导页，首页上面的广告Banner ，又或者是Tab下面的Indicator。Indicator 一般配合ViewPager 使用，它能很直观的反应出ViewPager 中一共有多少页，当前选中的是哪一页，用户能够很容易的看出是否还可以滑动，用户体验较好。那么本篇文章就讲一下如何通过自定义View来实现一个漂亮简洁的IndicatorView。</p></blockquote><span id="more"></span><!-- 这是　　缩进--><p>Indicator的展示形式</p><p>我们使用Indicator时,常见的有三种形式，第一种是根据ViewPager 的总页数展示一排小圆点，选中和未选中分别标为不同的颜色。这也是普遍的使用Indicator的效果，效果如下：</p><p><img src="http://dinson-blog.hdinson.cn/FqkeU8jK8cJlXCZ0XDU4nxFafKBE.png" alt=""></p><p>第二种形式是根据ViewPager 的总页数展示一排圆点，并且用数字标出其顺序（1，2，3，4 …），大概效果如下：</p><p><img src="http://dinson-blog.hdinson.cn/FrrcSoSWlXMrD2FZCbB7WTt51bjS.png" alt=""></p><p>image.png<br>第三种形式和第二种形式差不多，同样根据ViewPager总页数展示一片圆点，但是用字母标出顺序(A,B,C,D ….), 比如 ：魅族手机屏幕的切换的Indicator。效果如下：<br><img src="http://dinson-blog.hdinson.cn/FlpGT6-Tt0Piq7rZ2nPmbnCuAt1d.png" alt=""><br>本篇文章就通过自定义View来实现这三种IndicatorView。</p><h2 id="通过自定义View-实现多功能的CircleIndicatorView"><a href="#通过自定义View-实现多功能的CircleIndicatorView" class="headerlink" title="通过自定义View 实现多功能的CircleIndicatorView"></a>通过自定义View 实现多功能的CircleIndicatorView</h2><p>首先整理一下思路，CircleIndicatorView ,它是由一组圆 组成的，只不过圆有多种状态，选中、未选中、显示字母、显示数字等等。看着有这么多中状态，感觉挺复杂，但是其实不复杂，只是用不同的变量来控制不同的状态即可。其他的先不考虑，我们只要先把这一排圆画出来，剩下的就比较容易了。<strong>要确定一个圆的，需要知道圆的半径和圆心，半径是我们可以配置的,那么，其实核心就是计算这一排的圆点的圆心位置。圆心 y 的位置是固定的（View 高的一般），因此我们只需要计算每个圆的圆心x的位置，看下图，其实很容易就能找到规律，规律如下： 第一个圆的x 就等于圆的半径，从第二个圆开始，当前圆的圆心x 坐标为 上一个圆的x 坐标 + (radius * 2 + mSpace)。</strong> 其中mSpace 是圆之间的间距。<br><img src="http://dinson-blog.hdinson.cn/FvsVDtj-3Ylb6cE8_4aiVzHDdDVD.png" alt=""></p><p>有了上面的规律，我们只需要一个循环就能找出所有圆的圆心位置。代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测量每个圆点的位置</span><br><span class="line"> */</span><br><span class="line">private void measureIndicator()&#123;</span><br><span class="line">    mIndicators.clear();</span><br><span class="line">    float cx = 0;</span><br><span class="line">    for(int i=0;i&lt;mCount;i++)&#123;</span><br><span class="line">        Indicator indicator = new Indicator();</span><br><span class="line">        if( i== 0)&#123;</span><br><span class="line">            cx = mRadius + mStrokeWidth;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cx += (mRadius + mStrokeWidth) * 2 +mSpace;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        indicator.cx = cx;</span><br><span class="line">        indicator.cy = getMeasuredHeight() / 2;</span><br><span class="line"></span><br><span class="line">        mIndicators.add(indicator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们用Indicator类记录了每个圆的圆心位置，并且保存在一个列表里面，现在有了所有圆的数据，我们就可以绘制了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;mIndicators.size();i++)&#123;</span><br><span class="line"></span><br><span class="line">        Indicator indicator = mIndicators.get(i);</span><br><span class="line">        float x = indicator.cx;</span><br><span class="line"></span><br><span class="line">        float y = indicator.cy;</span><br><span class="line"></span><br><span class="line">        if(mSelectPosition == i)&#123;</span><br><span class="line">            mCirclePaint.setStyle(Paint.Style.FILL);</span><br><span class="line">            mCirclePaint.setColor(mSelectColor);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            mCirclePaint.setColor(mDotNormalColor);</span><br><span class="line">            if(mFillMode != FillMode.NONE)&#123;</span><br><span class="line">                mCirclePaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                mCirclePaint.setStyle(Paint.Style.FILL);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.drawCircle(x,y, mRadius, mCirclePaint);</span><br><span class="line"></span><br><span class="line">        // 绘制小圆点中的内容</span><br><span class="line">        if(mFillMode != FillMode.NONE)&#123;</span><br><span class="line">            String text = &quot;&quot;;</span><br><span class="line">            if(mFillMode == FillMode.LETTER)&#123;</span><br><span class="line">                if(i &gt;= 0 &amp;&amp; i&lt;LETTER.length)&#123;</span><br><span class="line">                    text = LETTER[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                text = String.valueOf(i+1);</span><br><span class="line">            &#125;</span><br><span class="line">            Rect bound = new Rect();</span><br><span class="line">            mTextPaint.getTextBounds(text,0,text.length(),bound);</span><br><span class="line">            int textWidth = bound.width();</span><br><span class="line">            int textHeight = bound.height();</span><br><span class="line"></span><br><span class="line">            float textStartX = x - textWidth / 2;</span><br><span class="line">            float textStartY = y + textHeight / 2;</span><br><span class="line">            canvas.drawText(text,textStartX,textStartY, mTextPaint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>绘制的代码很简单，无非就是循环我们保存的列表，拿出每一个Indicator，然后绘制圆就行了，除此之外就是一些状态的判断，比如，是否绘制数字、字母和选中状态等等 。</p><p>到此，我们的CircleIndicatorView 的绘制工作算是完成了，并且也能够显示在界面上了，但是它现在还是一个单独的View。我们前面说过，IndicatorView 一般是配合ViewPager使用的，它是随着Viewpager的切换而改变的，因此我们需要将IndicatorView 与ViewPager 进行关联。</p><p>要让CircleIndicatorView 与ViewPager 关联，首先需要 CircleIndicatorView 实现<code>ViewPager.OnPageChangeListener</code>接口。然后在<code>onPageSelected</code>方法中记录当前页的位置。代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onPageSelected(int position) &#123;</span><br><span class="line">    mSelectPosition = position;</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onPageScrollStateChanged(int state) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第二步，向外提供一个API ,设置CircleIndicatorView 与 ViewPager 关联。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  与ViewPager 关联</span><br><span class="line"> * @param viewPager</span><br><span class="line"> */</span><br><span class="line">public void setUpWithViewPager(ViewPager viewPager)&#123;</span><br><span class="line">    releaseViewPager();</span><br><span class="line">    if(viewPager == null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mViewPager = viewPager;</span><br><span class="line">    mViewPager.addOnPageChangeListener(this);</span><br><span class="line">    int count = mViewPager.getAdapter().getCount();</span><br><span class="line">    setCount(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过如上两步，就建立了CircleIndicatorView 与ViewPager的关联，只需要调用方法<code>setUpWithViewPager</code>就OK。</p><p>到此就完了吗？当然还没有完，<strong>其实还有一个小细节，那就是IndicatorView 因该是可以点击的，点击Indicator小圆点就能切换ViewPager 到对应的页面（如 Iphone 和 魅族手机的 屏幕切换，点击indicator小圆点就可以切换 ,以前没有注意的现在可以去试一下 ），那么我们也来实现这样一个功能，其实很简单,重写onTouchEvent方法 ，监听ACTION_DOWN 事件，然后获取点击屏幕的坐标，与所绘制的圆位置比较,如果点击区域在圆的范围内，就点击了该Indicator。点击之后，切换Viewpager到对应页面。</strong>代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    float xPoint = 0;</span><br><span class="line">    float yPoint = 0;</span><br><span class="line">    switch (event.getAction())&#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            xPoint = event.getX();</span><br><span class="line">            yPoint = event.getY();</span><br><span class="line">            handleActionDown(xPoint,yPoint);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return super.onTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleActionDown(float xDis,float yDis)&#123;</span><br><span class="line">    for(int i=0;i&lt;mIndicators.size();i++)&#123;</span><br><span class="line">        Indicator indicator = mIndicators.get(i);</span><br><span class="line">        if(xDis &lt; (indicator.cx + mRadius+mStrokeWidth)</span><br><span class="line">                &amp;&amp; xDis &gt;=(indicator.cx - (mRadius + mStrokeWidth))</span><br><span class="line">                &amp;&amp; yDis &gt;= (yDis - (indicator.cy+mStrokeWidth))</span><br><span class="line">                &amp;&amp; yDis &lt;(indicator.cy+mRadius+mStrokeWidth))&#123;</span><br><span class="line">             // 找到了点击的Indicator</span><br><span class="line">            // 切换ViewPager</span><br><span class="line">             mViewPager.setCurrentItem(i,false);</span><br><span class="line">             // 回调</span><br><span class="line">            if(mOnIndicatorClickListener!=null)&#123;</span><br><span class="line">                mOnIndicatorClickListener.onSelected(i);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此，我们自定义IndicatorView 的工作就差不多完成了，但是现在的IndicatorView 还不是很灵活，我们要让它的可配置性更强，就应该提供更多的API 来让IndicatorView 使用更加灵活方便，因此，最后一步，加上一些自定义属性来提高它的灵活性。自定义了如下一些属性：</p><div class="table-container"><table><thead><tr><th>属性名</th><th>属性意义</th><th>取值</th></tr></thead><tbody><tr><td>indicatorRadius</td><td>设置指示器圆点的半径</td><td>单位为 dp 的值</td></tr><tr><td>indicatorBorderWidth</td><td>设置指示器的border</td><td>单位为 dp 的值</td></tr><tr><td>indicatorSpace</td><td>设置指示器之间的距离</td><td>单位为 dp 的值</td></tr><tr><td>indicatorTextColor</td><td>设置指示器中间的文字颜色</td><td>颜色值，如：＃FFFFFF</td></tr><tr><td>indicatorColor</td><td>设置指示器圆点的颜色</td><td>颜色值</td></tr><tr><td>indicatorSelectColor</td><td>设置指示器选中的颜色</td><td>颜色值</td></tr><tr><td>fill_mode</td><td>设置指示器的模式</td><td>枚举值：有三种，分别是letter,number和none</td></tr></tbody></table></div><p>自定义属性文件如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;declare-styleable name=&quot;CircleIndicatorView&quot;&gt;</span><br><span class="line">    &lt;attr name=&quot;indicatorRadius&quot; format=&quot;dimension&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;indicatorBorderWidth&quot; format=&quot;dimension&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;indicatorSpace&quot; format=&quot;dimension&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;indicatorTextColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;indicatorColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;indicatorSelectColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;fill_mode&quot;&gt;</span><br><span class="line">        &lt;enum name=&quot;letter&quot; value=&quot;0&quot;/&gt;</span><br><span class="line">        &lt;enum name=&quot;number&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;enum name=&quot;none&quot; value=&quot;2&quot;/&gt;</span><br><span class="line">    &lt;/attr&gt;</span><br><span class="line">&lt;/declare-styleable&gt;</span><br></pre></td></tr></table></figure></p><p>通过上面这些属性，我们就可以很好的定制IndicaotorView 了，比如，自定义圆的大小，颜色，border，文字的颜色，选中的颜色和展示的模式等等。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=26069686&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ViewPager系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于python中如何导入pygame模块</title>
      <link href="/2017/05/31/17-05-31/"/>
      <url>/2017/05/31/17-05-31/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>在这里用python3.6和pygame (1.9.3)为例，请找自己相应匹配的版本。</p></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ol><li><p>下载python3.6.1<br><a href="https://www.Python.org/downloads/">https://www.Python.org/downloads/</a></p></li><li><p>下载pip的wheel包<br><a href="https://pypi.python.org/pypi/pip">https://pypi.python.org/pypi/pip</a></p></li><li><p>下载windows的easy installer<br><a href="https://pypi.python.org/pypi/setuptools">https://pypi.python.org/pypi/setuptools</a></p></li><li><p>下载Pygame所需的wheel安装包<br><a href="https://pypi.python.org/pypi/Pygame">https://pypi.python.org/pypi/Pygame</a><br><img src="http://dinson-blog.hdinson.cn/FkpaiiHZ3KdqJCsRs70Sal8r5N_C.png" alt=""></p><blockquote><p><strong>注意版本的选择</strong></p></blockquote></li></ol><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ol><li>安装python3.6.1</li><li>安装ez_setup.py 双击即可</li><li>安装pip的wheel安装包</li></ol><p>　　安装pip的wheel安装包需要进入DOS</p><p>　　　　（1）按win+R,输入cmd，进入DOS</p><p>　　　　（2）输入pip install wheel</p><p>　　　　（3）输入pip list，验证是否安装成功</p><p>4.安装pygame的wheel安装包<br>切换路径：切换到安装包所在的盘区，比如我的pygame的wheel是放到E盘去的</p><p>输入cd\<br>输入E：<br>现在我们进入我们要进的盘区了。<br>再输pip install pygame-1.9.2a0-cp35-none-win32.whl</p><p>至此我们已经安装成功。</p><p>最后就是import pygame</p>]]></content>
      
      
      <categories>
          
          <category> Python从入门到放弃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CoordinatorLayout 自定义Behavior并不难，由简到难手把手带你飞 (未完...)</title>
      <link href="/2017/05/29/17-05-29/"/>
      <url>/2017/05/29/17-05-29/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>其实Behavior就是一个应用于View的观察者模式，一个View跟随者另一个View的变化而变化，或者说一个View监听另一个View。<br>在Behavior中，被观察View 也就是事件源被称为denpendcy，而观察View，则被称为child。</p></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="难度1-Button与TextView"><a href="#难度1-Button与TextView" class="headerlink" title="难度1 Button与TextView"></a>难度1 Button与TextView</h2><p>首先在布局文件中跟布局设置为CoordinatorLayout，里面放一个Button和一个TextView。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.design.widget.CoordinatorLayout</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;TextView</span><br><span class="line">        app:layout_behavior=&quot;.EasyBehavior&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;观察者View child&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/btn&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity=&quot;center&quot;</span><br><span class="line">        android:text=&quot;被观察View dependency&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure><br>这里我们在Activity中做一些手脚，让Button动起来(不要在意坐标这些细节)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">findViewById(R.id.btn).setOnTouchListener(new View.OnTouchListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onTouch(View v, MotionEvent event) &#123;</span><br><span class="line">                switch (event.getAction()) &#123;</span><br><span class="line">                    case MotionEvent.ACTION_MOVE:</span><br><span class="line">                        v.setX(event.getRawX() - v.getWidth() / 2);</span><br><span class="line">                        v.setY(event.getRawY() - v.getHeight() / 2);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>此时，Button已经可以跟随手指移动了。</p><p>现在去自定义一个Behavior让TextView跟随Button一起动！</p><p>创建一个EasyBehavior类，继承于Behavior<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class EasyBehavior extends CoordinatorLayout.Behavior&lt;TextView&gt; &#123;//这里的泛型是child的类型，也就是观察者View</span><br><span class="line"></span><br><span class="line">    public EasyBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layoutDependsOn(CoordinatorLayout parent, TextView child, View dependency) &#123;</span><br><span class="line">        //告知监听的dependency是Button</span><br><span class="line">        return dependency instanceof Button;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    //当 dependency(Button)变化的时候，可以对child(TextView)进行操作</span><br><span class="line">    public boolean onDependentViewChanged(CoordinatorLayout parent, TextView child, View dependency) &#123;</span><br><span class="line">        child.setX(dependency.getX() + 200);</span><br><span class="line">        child.setY(dependency.getY() + 200);</span><br><span class="line">        child.setText(dependency.getX() + &quot;,&quot; + dependency.getY());</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意两个方法<br><code>layoutDependsOn()</code> 代表寻找被观察View<br><code>onDependentViewChanged()</code> 被观察View变化的时候回调用的方法</p><blockquote><p>在onDependentViewChanged中，我们让TextView跟随Button的移动而移动。代码比较简单，一看就懂。</p><p>必须重写带双参的构造器，因为从xml反射需要调用。</p></blockquote><p>接下来，在xml中，给TextView设置我们的Behavior。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">        app:layout_behavior=&quot;.EasyBehavior&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;观察者View child&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>运行效果如下：<br><img src="http://dinson-blog.hdinson.cn/Fhg96Q7qaGwhEwMXBh6NtL2IfZFz.gif" alt=""><br>这样一个最简单的behavior就做好了。</p><h2 id="难度2-仿UC折叠Behavior"><a href="#难度2-仿UC折叠Behavior" class="headerlink" title="难度2 仿UC折叠Behavior"></a>难度2 仿UC折叠Behavior</h2><p>这个效果布局嵌套比上一个例子些许复杂，如果看起来吃力，务必去补习CoordinatorLayout！！！！</p><p>先定义xml如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.design.widget.CoordinatorLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:ignore=&quot;RtlHardcoded&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.AppBarLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span><br><span class="line">        app:elevation=&quot;0dp&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;android.support.design.widget.CollapsingToolbarLayout</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;ImageView</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;300dp&quot;</span><br><span class="line">                android:scaleType=&quot;centerCrop&quot;</span><br><span class="line">                android:src=&quot;@drawable/bg_1920_1080&quot;</span><br><span class="line">                app:layout_collapseMode=&quot;parallax&quot;</span><br><span class="line">                app:layout_collapseParallaxMultiplier=&quot;0.9&quot;/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;FrameLayout</span><br><span class="line">                android:id=&quot;@+id/frameLayout&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;100dp&quot;</span><br><span class="line">                android:layout_gravity=&quot;bottom|center_horizontal&quot;</span><br><span class="line">                android:background=&quot;@color/colorPrimary&quot;</span><br><span class="line">                android:orientation=&quot;vertical&quot;</span><br><span class="line">                app:layout_collapseMode=&quot;parallax&quot;</span><br><span class="line">                app:layout_collapseParallaxMultiplier=&quot;0.3&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/FrameLayout&gt;</span><br><span class="line">        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;</span><br><span class="line">    &lt;/android.support.design.widget.AppBarLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v4.widget.NestedScrollView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:scrollbars=&quot;none&quot;</span><br><span class="line">        app:behavior_overlapTop=&quot;30dp&quot;</span><br><span class="line">        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;include layout=&quot;@layout/layout_uc_content&quot;/&gt;</span><br><span class="line">    &lt;/android.support.v4.widget.NestedScrollView&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/main.toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">        android:background=&quot;@color/colorPrimaryDark&quot;</span><br><span class="line">        app:layout_anchor=&quot;@id/frameLayout&quot;</span><br><span class="line">        app:theme=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;&gt;</span><br><span class="line">    &lt;/android.support.v7.widget.Toolbar&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tv_title&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;50dp&quot;</span><br><span class="line">        android:background=&quot;@color/colorPrimaryDark&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:text=&quot;头条&quot;</span><br><span class="line">        android:textColor=&quot;#fff&quot;</span><br><span class="line">        android:textSize=&quot;18sp&quot;</span><br><span class="line">        app:layout_behavior=&quot;.DrawerBehavior&quot;/&gt;</span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure><br>有一点值得注意的是，app:layout_anchor=”@id/frameLayout”这个属性，是附着的意思，这里我用作给了toolbar，代表toolbar附着在了frameLayout之上。会跟随frameLayout的scroll而变化Y的值。</p><p><strong>思路分析</strong><br>如何实现折叠呢，下半部分不用管了，AppBarLayout已经帮我们做好了，我们只要标注相应的scrollflags即可，所以，如上的布局，不做任何处理的话，作为标题的TextView是一直显示的，于是只要让TextView跟随Toolbar变化而变化就可以了。 接下来就创建一个Behavior类！<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class DrawerBehavior extends CoordinatorLayout.Behavior&lt;TextView&gt; &#123;</span><br><span class="line">    private int mFrameMaxHeight = 100;</span><br><span class="line">    private int mStartY;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layoutDependsOn(CoordinatorLayout parent, TextView child, View dependency) &#123;</span><br><span class="line">        return dependency instanceof Toolbar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DrawerBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onDependentViewChanged(CoordinatorLayout parent, TextView child, View dependency) &#123;</span><br><span class="line">        //记录开始的Y坐标  也就是toolbar起始Y坐标</span><br><span class="line">        if(mStartY == 0) &#123;</span><br><span class="line">            mStartY = (int) dependency.getY();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //计算toolbar从开始移动到最后的百分比</span><br><span class="line">        float percent = dependency.getY()/mStartY;</span><br><span class="line"></span><br><span class="line">        //改变child的坐标(从消失，到可见)</span><br><span class="line">        child.setY(child.getHeight()*(1-percent) - child.getHeight());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>里面监听了Toolbar的Y坐标变化，然后让TextView的Y坐标也跟着变化。达到如预览图效果。</p><p>22418581</p><p><a href="http://music.163.com/#/m/song?id=&amp;userid=472025302">http://music.163.com/#/m/song?id=&amp;userid=472025302</a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=18949977&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MaterialDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python从入门到放弃（8）-- Socket</title>
      <link href="/2017/05/28/17-05-28/"/>
      <url>/2017/05/28/17-05-28/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p><p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，对于文件用【打开】【读写】【关闭】模式来操作。socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）</p></blockquote><p>socket和file的区别：</p><ul><li>file模块是针对某个指定文件进行【打开】【读写】【关闭】</li><li>socket模块是针对 服务器端 和 客户端Socket 进行【打开】【读写】【关闭】</li></ul><span id="more"></span><!-- 这是　　缩进--><p><img src="http://dinson-blog.hdinson.cn/Fo5Iac4x_-S14ZoClUX1d6DJ8JOg.png" alt=""></p><p><img src="http://dinson-blog.hdinson.cn/FhHICNMLup6VgDnb1nJ6md2ktNOH.png" alt=""></p><p>socket server:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">ip_port = (&#x27;127.0.0.1&#x27;,9999)</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind(ip_port)</span><br><span class="line">sk.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    print &#x27;server waiting...&#x27;</span><br><span class="line">    conn,addr = sk.accept()</span><br><span class="line"></span><br><span class="line">    client_data = conn.recv(1024)</span><br><span class="line">    print client_data</span><br><span class="line">    conn.sendall(&#x27;不要回答,不要回答,不要回答&#x27;)</span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure></p><p>socket client:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">ip_port = (&#x27;127.0.0.1&#x27;,9999)</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect(ip_port)</span><br><span class="line"></span><br><span class="line">sk.sendall(&#x27;请求占领地球&#x27;)</span><br><span class="line"></span><br><span class="line">server_reply = sk.recv(1024)</span><br><span class="line">print server_reply</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><br>WEB服务应用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"> </span><br><span class="line">def handle_request(client):</span><br><span class="line">    buf = client.recv(1024)</span><br><span class="line">    client.send(&quot;HTTP/1.1 200 OK\r\n\r\n&quot;)</span><br><span class="line">    client.send(&quot;Hello, World&quot;)</span><br><span class="line"> </span><br><span class="line">def main():</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.bind((&#x27;localhost&#x27;,8080))</span><br><span class="line">    sock.listen(5)</span><br><span class="line"> </span><br><span class="line">    while True:</span><br><span class="line">        connection, address = sock.accept()</span><br><span class="line">        handle_request(connection)</span><br><span class="line">        connection.close()</span><br><span class="line"> </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure></p><h2 id="Socket-参数介绍"><a href="#Socket-参数介绍" class="headerlink" title="Socket 参数介绍"></a>Socket 参数介绍</h2><p><code>sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)</code></p><ul><li><p>参数一：地址簇<br>　　<code>socket.AF_INET</code> IPv4（默认）<br>　　<code>socket.AF_INET6</code> IPv6<br>　　<code>socket.AF_UNIX</code> 只能够用于单一的Unix系统进程间通信</p></li><li><p>参数二：类型<br>　　<code>socket.SOCK_STREAM</code>　　流式socket , for TCP （默认）<br>　　<code>socket.SOCK_DGRAM</code>　　 数据报式socket , for UDP<br>　　<code>socket.SOCK_RAW</code> 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。<br>　　<code>socket.SOCK_RDM</code> 是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。<br>　　<code>socket.SOCK_SEQPACKET</code> 可靠的连续数据包服务</p></li><li><p>参数三：协议<br>　　<code>0</code>　　（默认）与特定的地址家族相关的协议,如果是 0 ，则系统就会根据地址格式和套接类别,自动选择一个合适的协议</p></li></ul><p><code>sk.bind(address)</code><br>　　s.bind(address) 将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。</p><p><code>sk.listen(backlog)</code><br>　　开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。<br>　　backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5这个值不能无限大，因为要在内核中维护连接队列</p><p><code>sk.setblocking(bool)</code><br>　　是否阻塞（默认True），如果设置False，那么accept和recv时一旦无数据，则报错。</p><p><code>sk.accept()</code><br>　　接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。<br>　　接收TCP 客户的连接（阻塞式）等待连接的到来</p><p><code>sk.connect(address)</code><br>　　连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。</p><p><code>sk.connect_ex(address)</code><br>　　同上，只不过会有返回值，连接成功时返回 0 ，连接失败时候返回编码，例如：10061</p><p><code>sk.close()</code><br>　　关闭套接字</p><p><code>sk.recv(bufsize[,flag])</code><br>　　接受套接字的数据。数据以字符串形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。</p><p><code>sk.recvfrom(bufsize[.flag])</code><br>　　与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</p><p><code>sk.send(string[,flag])</code><br>　　将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。即：可能未将指定内容全部发送。</p><p><code>sk.sendall(string[,flag])</code><br>　　将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。<br>　　内部通过递归调用send，将所有内容发送出去。</p><p><code>sk.sendto(string[,flag],address)</code><br>　　将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。该函数主要用于UDP协议。</p><p><code>sk.settimeout(timeout)</code><br>　　设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 client 连接最多等待5s ）</p><p><code>sk.getpeername()</code><br>　　返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</p><p><code>sk.getsockname()</code><br>　　返回套接字自己的地址。通常是一个元组(ipaddr,port)</p><p><code>sk.fileno()</code><br>　　套接字的文件描述符</p><h2 id="实例：智能机器人"><a href="#实例：智能机器人" class="headerlink" title="实例：智能机器人"></a>实例：智能机器人</h2><p>服务端:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">ip_port = (&#x27;127.0.0.1&#x27;,8888)</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind(ip_port)</span><br><span class="line">sk.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    conn,address =  sk.accept()</span><br><span class="line">    conn.sendall(&#x27;欢迎致电 10086，请输入1xxx,0转人工服务.&#x27;)</span><br><span class="line">    Flag = True</span><br><span class="line">    while Flag:</span><br><span class="line">        data = conn.recv(1024)</span><br><span class="line">        if data == &#x27;exit&#x27;:</span><br><span class="line">            Flag = False</span><br><span class="line">        elif data == &#x27;0&#x27;:</span><br><span class="line">            conn.sendall(&#x27;通过可能会被录音.balabala一大推&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            conn.sendall(&#x27;请重新输入.&#x27;)</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><br>客户端:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">ip_port = (&#x27;127.0.0.1&#x27;,8005)</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect(ip_port)</span><br><span class="line">sk.settimeout(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    data = sk.recv(1024)</span><br><span class="line">    print &#x27;receive:&#x27;,data</span><br><span class="line">    inp = raw_input(&#x27;please input:&#x27;)</span><br><span class="line">    sk.sendall(inp)</span><br><span class="line">    if inp == &#x27;exit&#x27;:</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure></p><h2 id="SocketServer模块"><a href="#SocketServer模块" class="headerlink" title="SocketServer模块"></a>SocketServer模块</h2><blockquote><p>SocketServer内部使用 IO多路复用 以及 “多线程” 和 “多进程” ，从而实现并发处理多个客户端请求的Socket服务端。即：每个客户端请求连接到服务器时，Socket服务端都会在服务器是创建一个“线程”或者“进程” 专门负责处理当前客户端的所有请求。</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/FuemAEvM1JPr0JK8a8gAeeaXOdr8.png" alt=""></p><p>让你的socketserver并发起来， 必须选择使用以下一个多并发的类<br><strong>class socketserver.ForkingTCPServer</strong><br><strong>class socketserver.ForkingUDPServer</strong><br><strong>class socketserver.ThreadingTCPServer</strong><br><strong>class socketserver.ThreadingUDPServer</strong></p><h2 id="ThreadingTCPServer"><a href="#ThreadingTCPServer" class="headerlink" title="ThreadingTCPServer"></a>ThreadingTCPServer</h2><blockquote><p>ThreadingTCPServer实现的Soket服务器内部会为每个client创建一个 “<code>线程</code>”，该线程用来和客户端进行交互。</p></blockquote><h3 id="ThreadingTCPServer基础"><a href="#ThreadingTCPServer基础" class="headerlink" title="ThreadingTCPServer基础"></a>ThreadingTCPServer基础</h3><p>使用ThreadingTCPServer:</p><ul><li>创建一个继承自 SocketServer.BaseRequestHandler 的类</li><li>类中必须定义一个名称为 handle 的方法</li><li>启动ThreadingTCPServer</li></ul><h3 id="ThreadingTCPServer源码剖析"><a href="#ThreadingTCPServer源码剖析" class="headerlink" title="ThreadingTCPServer源码剖析"></a>ThreadingTCPServer源码剖析</h3><p>ThreadingTCPServer的类图关系如下：<br><img src="http://dinson-blog.hdinson.cn/Fmp-X1BHrn_A3vo68eGw6izBVHfs.png" alt=""></p><p>内部调用流程为：</p><ul><li>启动服务端程序</li><li>执行 TCPServer.<strong>init</strong> 方法，创建服务端Socket对象并绑定 IP 和 端口</li><li>执行 BaseServer.<strong>init</strong> 方法，将自定义的继承自SocketServer.BaseRequestHandler 的类 MyRequestHandle赋值给self.RequestHandlerClass</li><li>执行 BaseServer.server_forever 方法，While 循环一直监听是否有客户端请求到达 …<br>当客户端连接到达服务器</li><li>执行 ThreadingMixIn.process_request 方法，创建一个 “线程” 用来处理请求</li><li>执行 ThreadingMixIn.process_request_thread 方法</li><li>执行 BaseServer.finish_request 方法，执行 self.RequestHandlerClass()  即：执行 自定义 MyRequestHandler 的构造方法（自动调用基类BaseRequestHandler的构造方法，在该构造方法中又会调用 MyRequestHandler的handle方法）</li></ul><h3 id="精简代码"><a href="#精简代码" class="headerlink" title="精简代码"></a>精简代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import threading</span><br><span class="line">import select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def process(request, client_address):</span><br><span class="line">    print request,client_address</span><br><span class="line">    conn = request</span><br><span class="line">    conn.sendall(&#x27;欢迎致电 10086，请输入1xxx,0转人工服务.&#x27;)</span><br><span class="line">    flag = True</span><br><span class="line">    while flag:</span><br><span class="line">        data = conn.recv(1024)</span><br><span class="line">        if data == &#x27;exit&#x27;:</span><br><span class="line">            flag = False</span><br><span class="line">        elif data == &#x27;0&#x27;:</span><br><span class="line">            conn.sendall(&#x27;通过可能会被录音.balabala一大推&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            conn.sendall(&#x27;请重新输入.&#x27;)</span><br><span class="line"></span><br><span class="line">sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sk.bind((&#x27;127.0.0.1&#x27;,8002))</span><br><span class="line">sk.listen(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    r, w, e = select.select([sk,],[],[],1)</span><br><span class="line">    print &#x27;looping&#x27;</span><br><span class="line">    if sk in r:</span><br><span class="line">        print &#x27;get request&#x27;</span><br><span class="line">        request, client_address = sk.accept()</span><br><span class="line">        t = threading.Thread(target=process, args=(request, client_address))</span><br><span class="line">        t.daemon = False</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><p>如精简代码可以看出，SocketServer的ThreadingTCPServer之所以可以同时处理请求得益于 select 和 Threading 两个东西，其实本质上就是在服务器端为每一个客户端创建一个线程，当前线程用来处理对应客户端的请求，所以，可以支持同时n个客户端链接（长连接）。</p><h2 id="ForkingTCPServer"><a href="#ForkingTCPServer" class="headerlink" title="ForkingTCPServer"></a>ForkingTCPServer</h2><blockquote><p>ForkingTCPServer和ThreadingTCPServer的使用和执行流程基本一致，只不过在内部分别为请求者建立 “线程”  和 “进程”。</p></blockquote><p>服务端:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import SocketServer</span><br><span class="line"></span><br><span class="line">class MyServer(SocketServer.BaseRequestHandler):</span><br><span class="line"></span><br><span class="line">    def handle(self):</span><br><span class="line">        # print self.request,self.client_address,self.server</span><br><span class="line">        conn = self.request</span><br><span class="line">        conn.sendall(&#x27;欢迎致电 10086，请输入1xxx,0转人工服务.&#x27;)</span><br><span class="line">        Flag = True</span><br><span class="line">        while Flag:</span><br><span class="line">            data = conn.recv(1024)</span><br><span class="line">            if data == &#x27;exit&#x27;:</span><br><span class="line">                Flag = False</span><br><span class="line">            elif data == &#x27;0&#x27;:</span><br><span class="line">                conn.sendall(&#x27;通过可能会被录音.balabala一大推&#x27;)</span><br><span class="line">            else:</span><br><span class="line">                conn.sendall(&#x27;请重新输入.&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    server = SocketServer.ForkingTCPServer((&#x27;127.0.0.1&#x27;,8009),MyServer)</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure></p><p>客户端<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip_port = (&#x27;127.0.0.1&#x27;,8009)</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect(ip_port)</span><br><span class="line">sk.settimeout(5)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    data = sk.recv(1024)</span><br><span class="line">    print &#x27;receive:&#x27;,data</span><br><span class="line">    inp = raw_input(&#x27;please input:&#x27;)</span><br><span class="line">    sk.sendall(inp)</span><br><span class="line">    if inp == &#x27;exit&#x27;:</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><br>以上ForkingTCPServer只是将 ThreadingTCPServer 实例中的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server = SocketServer.ThreadingTCPServer((&#x27;127.0.0.1&#x27;,8009),MyRequestHandler)</span><br></pre></td></tr></table></figure><br>变更为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server = SocketServer.ForkingTCPServer((&#x27;127.0.0.1&#x27;,8009),MyRequestHandler)</span><br></pre></td></tr></table></figure><br>SocketServer的ThreadingTCPServer之所以可以同时处理请求得益于 select 和 os.fork 两个东西，其实本质上就是在服务器端为每一个客户端创建一个进程，当前新创建的进程用来处理对应客户端的请求，所以，可以支持同时n个客户端链接（长连接）。</p><h2 id="Twisted"><a href="#Twisted" class="headerlink" title="Twisted"></a>Twisted</h2><blockquote><p>Twisted是一个事件驱动的网络框架，其中包含了诸多功能，例如：网络协议、线程、数据库管理、网络操作、电子邮件等。</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/FiTgejJLUMWQUgOBhOrcmE9XBth0.png" alt=""></p><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>简而言之，事件驱动分为二个部分：第一，注册事件；第二，触发事件。</p><p>自定义事件驱动框架，命名为：“弑君者”：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># event_drive.py</span><br><span class="line"></span><br><span class="line">event_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    for event in event_list:</span><br><span class="line">        obj = event()</span><br><span class="line">        obj.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseHandler(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户必须继承该类，从而规范所有类的方法（类似于接口的功能）</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def execute(self):</span><br><span class="line">        raise Exception(&#x27;you must overwrite execute&#x27;)</span><br></pre></td></tr></table></figure><br>程序员使用“弑君者框架”：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from source import event_drive</span><br><span class="line"></span><br><span class="line">class MyHandler(event_drive.BaseHandler):</span><br><span class="line"></span><br><span class="line">    def execute(self):</span><br><span class="line">        print &#x27;event-drive execute MyHandler&#x27;</span><br><span class="line"></span><br><span class="line">event_drive.event_list.append(MyHandler)</span><br><span class="line">event_drive.run()</span><br></pre></td></tr></table></figure><br>如上述代码，事件驱动只不过是框架规定了执行顺序，程序员在使用框架时，可以向原执行顺序中注册“事件”，从而在框架执行时可以出发已注册的“事件”。</p><h3 id="基于事件驱动Socket"><a href="#基于事件驱动Socket" class="headerlink" title="基于事件驱动Socket"></a>基于事件驱动Socket</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from twisted.internet import protocol</span><br><span class="line">from twisted.internet import reactor</span><br><span class="line"> </span><br><span class="line">class Echo(protocol.Protocol):</span><br><span class="line">    def dataReceived(self, data):</span><br><span class="line">        self.transport.write(data)</span><br><span class="line"> </span><br><span class="line">def main():</span><br><span class="line">    factory = protocol.ServerFactory()</span><br><span class="line">    factory.protocol = Echo</span><br><span class="line"> </span><br><span class="line">    reactor.listenTCP(8000,factory)</span><br><span class="line">    reactor.run()</span><br><span class="line"> </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><img src="http://dinson-blog.hdinson.cn/FnxqehwDO753xD7SpFAFZwDgdIyM.png" alt=""></p><p>程序执行流程：</p><ul><li>运行服务端程序</li><li>创建Protocol的派生类Echo</li><li>创建ServerFactory对象，并将Echo类封装到其protocol字段中</li><li>执行reactor的 listenTCP 方法，内部使用 tcp.Port 创建socket server对象，并将该对象添加到了 reactor的set类型的字段 _read 中</li><li>执行reactor的 run 方法，内部执行 while 循环，并通过 select 来监视 _read 中文件描述符是否有变化，循环中…</li><li>客户端请求到达</li><li>执行reactor的 _doReadOrWrite 方法，其内部通过反射调用 tcp.Port 类的 doRead 方法，内部 accept 客户端连接并创建Server对象实例（用于封装客户端socket信息）和 创建 Echo 对象实例（用于处理请求） ，然后调用 Echo 对象实例的 makeConnection 方法，创建连接。</li><li>执行 tcp.Server 类的 doRead 方法，读取数据，</li><li>执行 tcp.Server 类的 _dataReceived 方法，如果读取数据内容为空（关闭链接），否则，出发 Echo 的 dataReceived 方法</li><li>执行 Echo 的 dataReceived 方法 </li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=18836229&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Python从入门到放弃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python从入门到放弃（7）-- 面向对象编程进阶</title>
      <link href="/2017/05/27/17-05-27/"/>
      <url>/2017/05/27/17-05-27/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><ul><li>面向对象高级语法部分<br>　- 经典类vs新式类　　<br>　- 静态方法、类方法、属性方法<br>　- 类的特殊方法<br>　- 反射</li><li>异常处理</li></ul></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="经典类vs新式类"><a href="#经典类vs新式类" class="headerlink" title="经典类vs新式类"></a>经典类vs新式类</h2><p>把下面代码用python2 和python3都执行一下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.n = &#x27;A&#x27;</span><br><span class="line"> </span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.n = &#x27;B&#x27;</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">class C(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.n = &#x27;C&#x27;</span><br><span class="line"> </span><br><span class="line">class D(B,C):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.n = &#x27;D&#x27;</span><br><span class="line">    pass</span><br><span class="line"> </span><br><span class="line">obj = D()</span><br><span class="line"> </span><br><span class="line">print(obj.n)</span><br></pre></td></tr></table></figure></p><p>小结:<br>经典类：深度优先<br>新式类：广度优先<br>super()用法</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>通过<strong>@staticmethod</strong>装饰器即可把其装饰的方法变为一个静态方法，什么是静态方法呢？其实不难理解，普通的方法，可以在实例化后直接调用，并且在方法里可以通过self.调用实例变量或类变量，但静态方法是不可以访问实例变量或类变量的，一个不能访问实例变量和类变量的方法，其实相当于跟类本身已经没什么关系了，它与类唯一的关联就是需要通过类名来调用这个方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line"> </span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line">    @staticmethod #把eat方法变为静态方法</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;%s is eating&quot; % self.name)</span><br><span class="line"> </span><br><span class="line">d = Dog(&quot;ChenRonghua&quot;)</span><br><span class="line">d.eat()</span><br></pre></td></tr></table></figure></p><p>上面的调用会出以下错误，说是eat需要一个self参数，但调用时却没有传递，没错，当eat变成静态方法后，再通过实例调用时就不会自动把实例本身当作一个参数传给self了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: eat() missing 1 required positional argument: &#x27;self&#x27;</span><br></pre></td></tr></table></figure><br>想让上面的代码可以正常工作有两种办法</p><ol><li>调用时主动传递实例本身给eat方法，即d.eat(d) </li><li>在eat方法中去掉self参数，但这也意味着，在eat中不能通过self.调用实例中的其它变量了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def eat():</span><br><span class="line">        print(&quot; is eating&quot;)</span><br><span class="line"></span><br><span class="line">d = Dog(&quot;ChenRonghua&quot;)</span><br><span class="line">d.eat()</span><br></pre></td></tr></table></figure></li></ol><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法　"></a>类方法　</h2><p>类方法通过<strong>@classmethod</strong>装饰器实现，类方法和普通方法的区别是， 类方法只能访问类变量，不能访问实例变量<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line">    @classmethod</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;%s is eating&quot; % self.name)</span><br><span class="line"> </span><br><span class="line">d = Dog(&quot;ChenRonghua&quot;)</span><br><span class="line">d.eat()</span><br></pre></td></tr></table></figure></p><p>执行报错如下，说Dog没有name属性，因为name是个实例变量，类方法是不能访问实例变量的<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: type object &#x27;Dog&#x27; has no attribute &#x27;name&#x27;</span><br></pre></td></tr></table></figure></p><p>此时可以定义一个类变量，也叫name,看下执行效果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    name = &quot;我是类变量&quot;</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line">    @classmethod</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;%s is eating&quot; % self.name)</span><br><span class="line"> </span><br><span class="line">d = Dog(&quot;ChenRonghua&quot;)</span><br><span class="line">d.eat()</span><br><span class="line"> </span><br><span class="line">#执行结果</span><br><span class="line"> </span><br><span class="line">我是类变量 is eating</span><br></pre></td></tr></table></figure></p><h2 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法　　"></a>属性方法　　</h2><p>属性方法的作用就是通过<strong>@property</strong>把一个方法变成一个静态属性<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line"> </span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line">    @property</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot; %s is eating&quot; %self.name)</span><br><span class="line"> </span><br><span class="line">d = Dog(&quot;ChenRonghua&quot;)</span><br><span class="line">d.eat()</span><br></pre></td></tr></table></figure></p><p>调用会出以下错误， 说NoneType is not callable, 因为eat此时已经变成一个静态属性了， 不是方法了， 想调用已经不需要加()号了，直接d.eat就可以了<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: &#x27;NoneType&#x27; object is not callable</span><br></pre></td></tr></table></figure><br>正常调用如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = Dog(&quot;nick&quot;)</span><br><span class="line">d.eat</span><br><span class="line"> </span><br><span class="line">输出</span><br><span class="line">nick is eating</span><br></pre></td></tr></table></figure></p><p>好吧，把一个方法变成静态属性有什么卵用呢？既然想要静态变量，那直接定义成一个静态变量不就得了么？well, 以后你会需到很多场景是不能简单通过 定义 静态属性来实现的， 比如 ，你想知道一个航班当前的状态，是到达了、延迟了、取消了、还是已经飞走了， 想知道这种状态你必须经历以下几步:</p><ol><li>连接航空公司API查询</li><li>对查询结果进行解析 </li><li>返回结果给你的用户</li></ol><p>因此这个status属性的值是一系列动作后才得到的结果，所以你每次调用时，其实它都要经过一系列的动作才返回你结果，但这些动作过程不需要用户关心， 用户只需要调用这个属性就可以，明白了么？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Flight(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.flight_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def checking_status(self):</span><br><span class="line">        print(&quot;checking flight %s status &quot; % self.flight_name)</span><br><span class="line">        return  1</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def flight_status(self):</span><br><span class="line">        status = self.checking_status()</span><br><span class="line">        if status == 0 :</span><br><span class="line">            print(&quot;flight got canceled...&quot;)</span><br><span class="line">        elif status == 1 :</span><br><span class="line">            print(&quot;flight is arrived...&quot;)</span><br><span class="line">        elif status == 2:</span><br><span class="line">            print(&quot;flight has departured already...&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;cannot confirm the flight status...,please check later&quot;)</span><br><span class="line"></span><br><span class="line">f = Flight(&quot;CA980&quot;)</span><br><span class="line">f.flight_status</span><br></pre></td></tr></table></figure></p><p>cool , 那现在我只能查询航班状态， 既然这个flight_status已经是个属性了， 那我能否给它赋值呢？试试吧<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = Flight(&quot;CA980&quot;)</span><br><span class="line">f.flight_status</span><br><span class="line">f.flight_status = 2</span><br></pre></td></tr></table></figure><br>输出， 说不能更改这个属性，我擦。。。。，怎么办怎么办。。。 </p><p>当然可以改， 不过需要通过@proerty.setter装饰器再装饰一下，此时 你需要写一个新方法， 对这个flight_status进行更改。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Flight(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.flight_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def checking_status(self):</span><br><span class="line">        print(&quot;checking flight %s status &quot; % self.flight_name)</span><br><span class="line">        return  1</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def flight_status(self):</span><br><span class="line">        status = self.checking_status()</span><br><span class="line">        if status == 0 :</span><br><span class="line">            print(&quot;flight got canceled...&quot;)</span><br><span class="line">        elif status == 1 :</span><br><span class="line">            print(&quot;flight is arrived...&quot;)</span><br><span class="line">        elif status == 2:</span><br><span class="line">            print(&quot;flight has departured already...&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;cannot confirm the flight status...,please check later&quot;)</span><br><span class="line">    </span><br><span class="line">    @flight_status.setter #修改</span><br><span class="line">    def flight_status(self,status):</span><br><span class="line">        status_dic = &#123;</span><br><span class="line">            0 : &quot;canceled&quot;,</span><br><span class="line">            1 :&quot;arrived&quot;,</span><br><span class="line">            2 : &quot;departured&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;\033[31;1mHas changed the flight status to \033[0m&quot;,status_dic.get(status) )</span><br><span class="line"></span><br><span class="line">    @flight_status.deleter  #删除</span><br><span class="line">    def flight_status(self):</span><br><span class="line">        print(&quot;status got removed...&quot;)</span><br><span class="line"></span><br><span class="line">f = Flight(&quot;CA980&quot;)</span><br><span class="line">f.flight_status</span><br><span class="line">f.flight_status =  2 #触发@flight_status.setter </span><br><span class="line">del f.flight_status #触发@flight_status.deleter </span><br></pre></td></tr></table></figure></p><p>注意以上代码里还写了一个@flight_status.deleter, 是允许可以将这个属性删除 </p><h2 id="类的特殊成员方法"><a href="#类的特殊成员方法" class="headerlink" title="类的特殊成员方法"></a>类的特殊成员方法</h2><ul><li><p><strong>doc</strong>　　表示类的描述信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    &quot;&quot;&quot; 描述类信息，这是用于看片的神奇 &quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">    def func(self):</span><br><span class="line">        pass</span><br><span class="line"> </span><br><span class="line">print Foo.__doc__</span><br><span class="line">#输出：描述类信息，这是用于看片的神奇</span><br></pre></td></tr></table></figure></li><li><p><code>__module__</code>    表示当前操作的对象在那个模块</p></li><li><code>__class__</code>     表示当前操作的对象的类是什么</li><li><code>__init__</code>        构造方法，通过类创建对象时，自动触发执行。</li><li><code>__del__</code>        析构方法，当对象在内存中被释放时，自动触发执行。<br>注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的</li><li><code>__call__</code> 对象后面加括号，触发执行。<br>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <strong>call</strong> 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</li><li><code>__dict__</code> 查看类或对象中的所有成员</li><li><code>__str__</code> 如果一个类中定义了<strong>str</strong>方法，那么在打印 对象 时，默认输出该方法的返回值。</li><li><code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>    用于索引操作，如字典。以上分别表示获取、设置、删除数据</li><li><code>__new__</code> \ <code>__metaclass__</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line"> </span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line">f = Foo(&quot;alex&quot;)</span><br><span class="line"></span><br><span class="line">print type(f) # 输出：&lt;class &#x27;__main__.Foo&#x27;&gt;     表示，obj 对象由Foo类创建</span><br><span class="line">print type(Foo) # 输出：&lt;type &#x27;type&#x27;&gt;              表示，Foo类对象由 type 类创建</span><br></pre></td></tr></table></figure>　　上述代码中，obj 是通过 Foo 类实例化的对象，其实，不仅 obj 是一个对象，Foo类本身也是一个对象，因为在Python中一切事物都是对象。</li></ul><p>　　如果按照一切事物都是对象的理论：obj对象是通过执行Foo类的构造方法创建，那么Foo类对象应该也是通过执行某个类的 构造方法 创建。</p><p>　　所以，<strong>f对象是Foo类的一个实例，Foo类对象是 type 类的一个实例</strong>，即：Foo类对象 是通过type类的构造方法创建。<br>　　那么，创建类就可以有两种方式：</p><ul><li>普通方式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">  </span><br><span class="line">    def func(self):</span><br><span class="line">        print &#x27;hello dinson&#x27;</span><br></pre></td></tr></table></figure></li><li><p>特殊方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func(self):</span><br><span class="line">    print &#x27;hello dinson&#x27;</span><br><span class="line">  </span><br><span class="line">Foo = type(&#x27;Foo&#x27;,(object,), &#123;&#x27;func&#x27;: func &#125;)</span><br><span class="line">#type第一个参数：类名</span><br><span class="line">#type第二个参数：当前类的基类</span><br><span class="line">#type第三个参数：类的成员</span><br></pre></td></tr></table></figure></li><li><p>加上构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def func(self):</span><br><span class="line">    print(&quot;hello %s&quot;%self.name)</span><br><span class="line"></span><br><span class="line">def __init__(self,name,age):</span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br><span class="line">Foo = type(&#x27;Foo&#x27;,(object,),&#123;&#x27;func&#x27;:func,&#x27;__init__&#x27;:__init__&#125;)</span><br><span class="line"></span><br><span class="line">f = Foo(&quot;jack&quot;,22)</span><br><span class="line">f.func()</span><br></pre></td></tr></table></figure><p>So记住，类是由 type 类实例化产生</p></li></ul><p>那么问题来了，类默认是由 type 类实例化产生，type类中如何实现的创建类？类又是如何创建对象？</p><p>答：类中有一个属性 <strong>metaclass</strong>，其用来表示该类由 谁 来实例化创建，所以，我们可以为 <strong>metaclass</strong> 设置一个type类的派生类，从而查看 类 创建的过程。<br><img src="http://dinson-blog.hdinson.cn/FnZLN1spIQxHZFs_1qzkIXwmpw7w.png" alt=""></p><p>类的生成 调用 顺序依次是 <strong>new</strong> —&gt; <strong>init</strong> —&gt; <strong>call</strong></p><p>metaclass 详解文章：<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a> 得票最高那个答案写的非常好</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>通过字符串映射或修改程序运行时的状态、属性、方法, 有以下4个方法</p><ul><li>getattr(object, name, default=None)</li><li>hasattr(object,name)</li><li>setattr(x, y, v)</li><li>delattr(x, y)</li></ul><p>反射代码示例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line"> </span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &#x27;wupeiqi&#x27;</span><br><span class="line"> </span><br><span class="line">    def func(self):</span><br><span class="line">        return &#x27;func&#x27;</span><br><span class="line"> </span><br><span class="line">obj = Foo()</span><br><span class="line"> </span><br><span class="line"># #### 检查是否含有成员 ####</span><br><span class="line">hasattr(obj, &#x27;name&#x27;)</span><br><span class="line">hasattr(obj, &#x27;func&#x27;)</span><br><span class="line"> </span><br><span class="line"># #### 获取成员 ####</span><br><span class="line">getattr(obj, &#x27;name&#x27;)</span><br><span class="line">getattr(obj, &#x27;func&#x27;)</span><br><span class="line"> </span><br><span class="line"># #### 设置成员 ####</span><br><span class="line">setattr(obj, &#x27;age&#x27;, 18)</span><br><span class="line">setattr(obj, &#x27;show&#x27;, lambda num: num + 1)</span><br><span class="line"> </span><br><span class="line"># #### 删除成员 ####</span><br><span class="line">delattr(obj, &#x27;name&#x27;)</span><br><span class="line">delattr(obj, &#x27;func&#x27;)</span><br></pre></td></tr></table></figure></p><p>动态导入模块<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line"> </span><br><span class="line">__import__(&#x27;import_lib.metaclass&#x27;) #这是解释器自己内部用的</span><br><span class="line">#importlib.import_module(&#x27;import_lib.metaclass&#x27;) #与上面这句效果一样，官方建议用这个</span><br></pre></td></tr></table></figure></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="常用异常"><a href="#常用异常" class="headerlink" title="常用异常"></a>常用异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x</span><br><span class="line">IOError 输入/输出异常；基本上是无法打开文件</span><br><span class="line">ImportError 无法引入模块或包；基本上是路径问题或名称错误</span><br><span class="line">IndentationError 语法错误（的子类） ；代码没有正确对齐</span><br><span class="line">IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]</span><br><span class="line">KeyError 试图访问字典里不存在的键</span><br><span class="line">KeyboardInterrupt Ctrl+C被按下</span><br><span class="line">NameError 使用一个还未被赋予对象的变量</span><br><span class="line">SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）</span><br><span class="line">TypeError 传入对象类型与要求的不符合</span><br><span class="line">UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，</span><br><span class="line">导致你以为正在访问它</span><br><span class="line">ValueError 传入一个调用者不期望的值，即使值的类型是正确的</span><br></pre></td></tr></table></figure><h3 id="更多异常"><a href="#更多异常" class="headerlink" title="更多异常"></a>更多异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ArithmeticError</span><br><span class="line">AssertionError</span><br><span class="line">AttributeError</span><br><span class="line">BaseException</span><br><span class="line">BufferError</span><br><span class="line">BytesWarning</span><br><span class="line">DeprecationWarning</span><br><span class="line">EnvironmentError</span><br><span class="line">EOFError</span><br><span class="line">Exception</span><br><span class="line">FloatingPointError</span><br><span class="line">FutureWarning</span><br><span class="line">GeneratorExit</span><br><span class="line">ImportError</span><br><span class="line">ImportWarning</span><br><span class="line">IndentationError</span><br><span class="line">IndexError</span><br><span class="line">IOError</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">KeyError</span><br><span class="line">LookupError</span><br><span class="line">MemoryError</span><br><span class="line">NameError</span><br><span class="line">NotImplementedError</span><br><span class="line">OSError</span><br><span class="line">OverflowError</span><br><span class="line">PendingDeprecationWarning</span><br><span class="line">ReferenceError</span><br><span class="line">RuntimeError</span><br><span class="line">RuntimeWarning</span><br><span class="line">StandardError</span><br><span class="line">StopIteration</span><br><span class="line">SyntaxError</span><br><span class="line">SyntaxWarning</span><br><span class="line">SystemError</span><br><span class="line">SystemExit</span><br><span class="line">TabError</span><br><span class="line">TypeError</span><br><span class="line">UnboundLocalError</span><br><span class="line">UnicodeDecodeError</span><br><span class="line">UnicodeEncodeError</span><br><span class="line">UnicodeError</span><br><span class="line">UnicodeTranslateError</span><br><span class="line">UnicodeWarning</span><br><span class="line">UserWarning</span><br><span class="line">ValueError</span><br><span class="line">Warning</span><br><span class="line">ZeroDivisionError</span><br></pre></td></tr></table></figure><h3 id="异常其他结构"><a href="#异常其他结构" class="headerlink" title="异常其他结构"></a>异常其他结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    # 主代码块</span><br><span class="line">    pass</span><br><span class="line">except KeyError,e:</span><br><span class="line">    # 异常时，执行该块</span><br><span class="line">    pass</span><br><span class="line">else:</span><br><span class="line">    # 主代码块执行完，执行该块</span><br><span class="line">    pass</span><br><span class="line">finally:</span><br><span class="line">    # 无论异常与否，最终执行该块</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h3 id="主动触发异常"><a href="#主动触发异常" class="headerlink" title="主动触发异常"></a>主动触发异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    raise Exception(&#x27;错误了。。。&#x27;)</span><br><span class="line">except Exception,e:</span><br><span class="line">    print e</span><br></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class WupeiqiException(Exception):</span><br><span class="line"> </span><br><span class="line">    def __init__(self, msg):</span><br><span class="line">        self.message = msg</span><br><span class="line"> </span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.message</span><br><span class="line"> </span><br><span class="line">try:</span><br><span class="line">    raise WupeiqiException(&#x27;我的异常&#x27;)</span><br><span class="line">except WupeiqiException,e:</span><br><span class="line">    print e</span><br></pre></td></tr></table></figure><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># assert 条件</span><br><span class="line">assert 1 == 1</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=26402531&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Python从入门到放弃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python从入门到放弃（6）-- 常用模块学习</title>
      <link href="/2017/05/26/17-05-26/"/>
      <url>/2017/05/26/17-05-26/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><ol><li>模块介绍</li><li>time &amp;datetime模块</li><li>random模块</li><li>os模块</li><li>sys模块</li><li>shutil模块</li><li>json &amp; picle模块</li><li>shelve模块</li><li>xml处理模块</li><li>yaml处理模块</li><li>configparser模块</li><li>hashlib模块</li><li>subprocess模块</li><li>logging模块</li><li>re正则表达式模块</li></ol></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p><strong>模块，用一砣代码实现了某个功能的代码集合。</strong> </p><p>类似于函数式编程和面向过程编程，函数式编程则完成一个功能，其他代码用来调用即可，提供了代码的重用性和代码间的耦合。而对于一个复杂的功能来，可能需要多个函数才能完成（函数又可以在不同的.py文件中），n个 .py 文件组成的代码集合就称为模块。</p><p>如：os 是系统相关的模块；file是文件操作相关的模块</p><p>模块分为三种：</p><ol><li>自定义模块</li><li>开源模块</li><li>内置标准模块（又称标准库）</li></ol><h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><ol><li>定义模块<br>　　情景一：<br>　　<img src="http://dinson-blog.hdinson.cn/FhjkC7doWKqBzRjAiQ0iL61BEas0.png" alt=""><br>　　情景二：<br>　　<img src="http://dinson-blog.hdinson.cn/Fg9-5hbS_Pz62AYrHGReSSEnvcvB.png" alt=""><br>　　情景三：<br>　　<img src="http://dinson-blog.hdinson.cn/Fhf-jo1LpUbK65vKh3LWJW-LJ0AY.png" alt=""></li><li>导入模块<br>Python之所以应用越来越广泛，在一定程度上也依赖于其为程序员提供了大量的模块以供使用，如果想要使用模块，则需要导入。导入模块有一下几种方法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import module</span><br><span class="line">from module.xx.xx import xx</span><br><span class="line">from module.xx.xx import xx as rename  </span><br><span class="line">from module.xx.xx import *</span><br></pre></td></tr></table></figure>导入模块其实就是告诉Python解释器去解释那个py文件</li></ol><ul><li>导入一个py文件，解释器解释该py文件</li><li>导入一个包，解释器解释该包下的 <strong>init</strong>.py 文件<br>那么问题来了，导入模块时是根据那个路径作为基准来进行的呢？即：sys.path</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">print(sys.path)</span><br></pre></td></tr></table></figure><p>如果sys.path路径列表没有你想要的路径，可以通过 sys.path.append(‘路径’) 添加。<br>通过os模块可以获取各种目录，例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">pre_path = os.path.abspath(&#x27;../&#x27;)</span><br><span class="line">sys.path.append(pre_path)</span><br></pre></td></tr></table></figure></p><h3 id="开源模块"><a href="#开源模块" class="headerlink" title="开源模块"></a>开源模块</h3><p><strong>下载安装</strong>有两种方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum </span><br><span class="line">pip</span><br><span class="line">apt-get</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下载源码</span><br><span class="line">解压源码</span><br><span class="line">进入目录</span><br><span class="line">编译源码    python setup.py build</span><br><span class="line">安装源码    python setup.py install</span><br></pre></td></tr></table></figure><br>注：在使用源码安装时，需要使用到gcc编译和python开发环境，所以，需要先执行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc</span><br><span class="line">yum install python-devel</span><br><span class="line">或</span><br><span class="line">apt-get python-dev</span><br></pre></td></tr></table></figure><br>安装成功后，模块会自动安装到 sys.path 中的某个目录中，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/python2.7/site-packages/</span><br></pre></td></tr></table></figure></p><p><strong>导入模块</strong><br>　　同自定义模块中导入的方式</p><p><strong>模块 paramiko</strong><br>paramiko是一个用于做远程控制的模块，使用该模块可以对远程服务器进行命令或文件操作，值得一说的是，fabric和ansible内部的远程管理就是使用的paramiko来现实</p><ol><li>下载安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install paramiko</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># pycrypto，由于 paramiko 模块内部依赖pycrypto，所以先下载安装pycrypto</span><br><span class="line"> </span><br><span class="line"># 下载安装 pycrypto</span><br><span class="line">wget http://files.cnblogs.com/files/wupeiqi/pycrypto-2.6.1.tar.gz</span><br><span class="line">tar -xvf pycrypto-2.6.1.tar.gz</span><br><span class="line">cd pycrypto-2.6.1</span><br><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br><span class="line"> </span><br><span class="line"># 进入python环境，导入Crypto检查是否安装成功</span><br><span class="line"> </span><br><span class="line"># 下载安装 paramiko</span><br><span class="line">wget http://files.cnblogs.com/files/wupeiqi/paramiko-1.10.1.tar.gz</span><br><span class="line">tar -xvf paramiko-1.10.1.tar.gz</span><br><span class="line">cd paramiko-1.10.1</span><br><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br><span class="line"> </span><br><span class="line"># 进入python环境，导入paramiko检查是否安装成功</span><br></pre></td></tr></table></figure></p><h2 id="time-amp-datetime模块"><a href="#time-amp-datetime模块" class="headerlink" title="time &amp; datetime模块"></a>time &amp; datetime模块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"># print(time.clock()) #返回处理器时间,3.3开始已废弃 , 改成了time.process_time()测量处理器运算时间,不包括sleep时间,不稳定,mac上测不出来</span><br><span class="line"># print(time.altzone)  #返回与utc时间的时间差,以秒计算\</span><br><span class="line"># print(time.asctime()) #返回时间格式&quot;Tue May 26 15:09:27 2017&quot;,</span><br><span class="line"># print(time.localtime()) #返回本地时间 的struct time对象格式</span><br><span class="line"># print(time.gmtime(time.time()-800000)) #返回utc时间的struc时间对象格式</span><br><span class="line"></span><br><span class="line"># print(time.asctime(time.localtime())) #返回时间格式&quot;Tue May 26 15:10:33 2017&quot;,</span><br><span class="line">#print(time.ctime()) #返回Tue May 26 15:10:33 2017格式, 同上</span><br><span class="line"></span><br><span class="line"># 日期字符串 转成 时间戳</span><br><span class="line"># string_2_struct = time.strptime(&quot;2017/05/26&quot;,&quot;%Y/%m/%d&quot;) #将 日期字符串 转成 struct时间对象格式</span><br><span class="line"># print(string_2_struct)</span><br><span class="line"></span><br><span class="line"># struct_2_stamp = time.mktime(string_2_struct) #将struct时间对象转成时间戳</span><br><span class="line"># print(struct_2_stamp)</span><br><span class="line"></span><br><span class="line">#将时间戳转为字符串格式</span><br><span class="line"># print(time.gmtime(time.time()-86640)) #将utc时间戳转换成struct_time格式</span><br><span class="line"># print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.gmtime()) ) #将utc struct_time格式转成指定的字符串格式</span><br><span class="line"></span><br><span class="line">#时间加减</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"># print(datetime.datetime.now()) #返回 2017-05-26 15:11:59.775367</span><br><span class="line">#print(datetime.date.fromtimestamp(time.time()) )  # 时间戳直接转成日期格式 2017-05-26</span><br><span class="line"># print(datetime.datetime.now() )</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(3)) #当前时间+3天</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(-3)) #当前时间-3天</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(hours=3)) #当前时间+3小时</span><br><span class="line"># print(datetime.datetime.now() + datetime.timedelta(minutes=30)) #当前时间+30分</span><br><span class="line"></span><br><span class="line"># c_time  = datetime.datetime.now()</span><br><span class="line"># print(c_time.replace(minute=3,hour=2)) #时间替换</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Directive</th><th>Meaning</th></tr></thead><tbody><tr><td>%A</td><td>Locale’s full weekday name.</td></tr><tr><td>%b</td><td>Locale’s abbreviated month name.</td></tr><tr><td>%a</td><td>Locale’s abbreviated weekday name.</td></tr><tr><td>%B</td><td>Locale’s full month name.</td></tr><tr><td>%c</td><td>Locale’s appropriate date and time representation.</td></tr><tr><td>%d</td><td>Day of the month as a decimal number [01,31].</td></tr><tr><td>%H</td><td>Hour (24-hour clock) as a decimal number [00,23].</td></tr><tr><td>%I</td><td>Hour (12-hour clock) as a decimal number [01,12].</td></tr><tr><td>%j</td><td>Day of the year as a decimal number [001,366].</td></tr><tr><td>%m</td><td>Month as a decimal number [01,12].</td></tr><tr><td>%M</td><td>Minute as a decimal number [00,59].</td></tr><tr><td>%p</td><td>Locale’s equivalent of either AM or PM.</td></tr><tr><td>%S</td><td>Second as a decimal number [00,61].</td></tr><tr><td>%U</td><td>Week number of the year (Sunday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Sunday are considered to be in week 0.</td></tr><tr><td>%w</td><td>Weekday as a decimal number [0(Sunday),6].</td></tr><tr><td>%W</td><td>Week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0.</td></tr><tr><td>%x</td><td>Locale’s appropriate date representation.</td></tr><tr><td>%X</td><td>Locale’s appropriate time representation.</td></tr><tr><td>%y</td><td>Year without century as a decimal number [00,99].</td></tr><tr><td>%Y</td><td>Year with century as a decimal number.</td></tr><tr><td>%z</td><td>Time zone offset indicating a positive or negative time difference from UTC/GMT of the form +HHMM or -HHMM, where H represents decimal hour digits and M represents decimal minute digits [-23:59, +23:59].</td></tr><tr><td>%Z</td><td>Time zone name (no characters if no time zone exists).</td></tr><tr><td>%%</td><td>A literal ‘%’ character.</td></tr></tbody></table></div><h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h2><p><strong>随机数</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mport random</span><br><span class="line">print random.random()</span><br><span class="line">print random.randint(1,2)</span><br><span class="line">print random.randrange(1,10)</span><br></pre></td></tr></table></figure><br><strong>生成随机验证码</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">checkcode = &#x27;&#x27;</span><br><span class="line">for i in range(4):</span><br><span class="line">    current = random.randrange(0,4)</span><br><span class="line">    if current != i:</span><br><span class="line">        temp = chr(random.randint(65,90))</span><br><span class="line">    else:</span><br><span class="line">        temp = random.randint(0,9)</span><br><span class="line">    checkcode += str(temp)</span><br><span class="line">print checkcode</span><br></pre></td></tr></table></figure></p><h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块　"></a>OS模块　</h2><p>提供对操作系统进行调用的接口<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</span><br><span class="line">os.chdir(&quot;dirname&quot;)  改变当前脚本工作目录；相当于shell下cd</span><br><span class="line">os.curdir  返回当前目录: (&#x27;.&#x27;)</span><br><span class="line">os.pardir  获取当前目录的父目录字符串名：(&#x27;..&#x27;)</span><br><span class="line">os.makedirs(&#x27;dirname1/dirname2&#x27;)    可生成多层递归目录</span><br><span class="line">os.removedirs(&#x27;dirname1&#x27;)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</span><br><span class="line">os.mkdir(&#x27;dirname&#x27;)    生成单级目录；相当于shell中mkdir dirname</span><br><span class="line">os.rmdir(&#x27;dirname&#x27;)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</span><br><span class="line">os.listdir(&#x27;dirname&#x27;)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</span><br><span class="line">os.remove()  删除一个文件</span><br><span class="line">os.rename(&quot;oldname&quot;,&quot;newname&quot;)  重命名文件/目录</span><br><span class="line">os.stat(&#x27;path/filename&#x27;)  获取文件/目录信息</span><br><span class="line">os.sep    输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;</span><br><span class="line">os.linesep    输出当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot;</span><br><span class="line">os.pathsep    输出用于分割文件路径的字符串</span><br><span class="line">os.name    输出字符串指示当前使用平台。win-&gt;&#x27;nt&#x27;; Linux-&gt;&#x27;posix&#x27;</span><br><span class="line">os.system(&quot;bash command&quot;)  运行shell命令，直接显示</span><br><span class="line">os.environ  获取系统环境变量</span><br><span class="line">os.path.abspath(path)  返回path规范化的绝对路径</span><br><span class="line">os.path.split(path)  将path分割成目录和文件名二元组返回</span><br><span class="line">os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素</span><br><span class="line">os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span><br><span class="line">os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False</span><br><span class="line">os.path.isabs(path)  如果path是绝对路径，返回True</span><br><span class="line">os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False</span><br><span class="line">os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False</span><br><span class="line">os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span><br><span class="line">os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间</span><br><span class="line">os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</span><br></pre></td></tr></table></figure></p><h2 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h2><p><strong>高级的 文件、文件夹、压缩包 处理模块</strong></p><p><code>shutil.copyfileobj(fsrc, fdst, length)</code>将文件内容拷贝到另一个文件中，可以<br><code>shutil.copyfile(src, dst)</code>拷贝文件<br><code>shutil.copymode(src, dst)</code>仅拷贝权限。内容、组、用户均不变<br><code>shutil.copystat(src, dst)</code>拷贝状态的信息，包括：mode bits, atime, mtime, flags<br><code>shutil.copy(src, dst)</code>拷贝文件和权限<br><code>shutil.copy2(src, dst)</code>拷贝文件和状态信息<br><code>shutil.ignore_patterns(*patterns)</code><br><code>shutil.copytree(src, dst, symlinks=False, ignore=None)</code>递归的去拷贝文件<br>　　例如：copytree(source, destination, ignore=ignore_patterns(‘<em>.pyc’, ‘tmp</em>‘))<br><code>shutil.rmtree(path, ignore_errors, onerror)</code>递归的去删除文件<br><code>shutil.move(src, dst)</code>递归的去移动文件</p><p><code>shutil.make_archive(base_name, format,...)</code>创建压缩包并返回文件路径，例如：zip、tar</p><ul><li>base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，<br>　　如：www                        =&gt;保存至当前路径<br>　　如：/Users/dinson/www =&gt;保存至/Users/dinson/</li><li>format：    压缩包种类，“zip”, “tar”, “bztar”，“gztar”</li><li>root_dir：    要压缩的文件夹路径（默认当前目录）</li><li>owner：    用户，默认当前用户</li><li>group：    组，默认当前组</li><li>logger：    用于记录日志，通常是logging.Logger对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#将 /Users/dinson/Downloads/test 下的文件打包放置当前程序目录</span><br><span class="line">import shutil</span><br><span class="line">ret = shutil.make_archive(&quot;wwwwwwwwww&quot;, &#x27;gztar&#x27;, root_dir=&#x27;/Users/dinson/Downloads/test&#x27;)</span><br><span class="line"> </span><br><span class="line">#将 /Users/dinson/Downloads/test 下的文件打包放置 /Users/dinson/目录</span><br><span class="line">import shutil</span><br><span class="line">ret = shutil.make_archive(&quot;/Users/dinson/wwwwwwwwww&quot;, &#x27;gztar&#x27;, root_dir=&#x27;/Users/dinson/Downloads/test&#x27;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="shutil-对压缩包的处理是调用-ZipFile-和-TarFile-两个模块来进行的，详细："><a href="#shutil-对压缩包的处理是调用-ZipFile-和-TarFile-两个模块来进行的，详细：" class="headerlink" title="shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细："></a>shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细：</h3><p>ZipFile:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import zipfile</span><br><span class="line"></span><br><span class="line"># 压缩</span><br><span class="line">z = zipfile.ZipFile(&#x27;laxi.zip&#x27;, &#x27;w&#x27;)</span><br><span class="line">z.write(&#x27;a.log&#x27;)</span><br><span class="line">z.write(&#x27;data.data&#x27;)</span><br><span class="line">z.close()</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">z = zipfile.ZipFile(&#x27;laxi.zip&#x27;, &#x27;r&#x27;)</span><br><span class="line">z.extractall()</span><br><span class="line">z.close()</span><br></pre></td></tr></table></figure><br>TarFile:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import tarfile</span><br><span class="line"></span><br><span class="line"># 压缩</span><br><span class="line">tar = tarfile.open(&#x27;your.tar&#x27;,&#x27;w&#x27;)</span><br><span class="line">tar.add(&#x27;/Users/wupeiqi/PycharmProjects/bbs2.zip&#x27;, arcname=&#x27;bbs2.zip&#x27;)</span><br><span class="line">tar.add(&#x27;/Users/wupeiqi/PycharmProjects/cmdb.zip&#x27;, arcname=&#x27;cmdb.zip&#x27;)</span><br><span class="line">tar.close()</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar = tarfile.open(&#x27;your.tar&#x27;,&#x27;r&#x27;)</span><br><span class="line">tar.extractall()  # 可设置解压地址</span><br><span class="line">tar.close()</span><br></pre></td></tr></table></figure></p><h2 id="json-amp-pickle-模块"><a href="#json-amp-pickle-模块" class="headerlink" title="json &amp; pickle 模块"></a>json &amp; pickle 模块</h2><p><strong>用于序列化的两个模块</strong></p><ul><li>json，用于字符串 和 python数据类型间进行转换</li><li>pickle，用于python特有的类型 和 python的数据类型间进行转换</li></ul><p>Json模块提供了四个功能：dumps、dump、loads、load<br>pickle模块提供了四个功能：dumps、dump、loads、load<br><img src="http://dinson-blog.hdinson.cn/FjXduLvXyf_mWqwvIBl0ms6M932P.png" alt=""></p><h2 id="shelve-模块"><a href="#shelve-模块" class="headerlink" title="shelve 模块"></a>shelve 模块</h2><p><strong>shelve模块是一个简单的k,v将内存数据通过文件持久化的模块，可以持久化任何pickle可支持的python数据格式</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import shelve</span><br><span class="line"> </span><br><span class="line">d = shelve.open(&#x27;shelve_test&#x27;) #打开一个文件</span><br><span class="line"> </span><br><span class="line">class Test(object):</span><br><span class="line">    def __init__(self,n):</span><br><span class="line">        self.n = n</span><br><span class="line"> </span><br><span class="line">t = Test(123) </span><br><span class="line">t2 = Test(123334)</span><br><span class="line"> </span><br><span class="line">name = [&quot;alex&quot;,&quot;rain&quot;,&quot;test&quot;]</span><br><span class="line">d[&quot;test&quot;] = name #持久化列表</span><br><span class="line">d[&quot;t1&quot;] = t      #持久化类</span><br><span class="line">d[&quot;t2&quot;] = t2</span><br><span class="line"> </span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure></p><h2 id="xml处理模块"><a href="#xml处理模块" class="headerlink" title="xml处理模块"></a>xml处理模块</h2><blockquote><p>xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，古时候，在json还没诞生的黑暗年代，大家只能选择用xml呀，至今很多传统公司如金融行业的很多系统的接口还主要是xml。</p><p>xml的格式如下，就是通过&lt;&gt;节点来区别数据结构的:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;country name=&quot;Liechtenstein&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;2&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2008&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;141100&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Austria&quot; direction=&quot;E&quot;/&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Switzerland&quot; direction=&quot;W&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=&quot;Singapore&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;5&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;59900&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Malaysia&quot; direction=&quot;N&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=&quot;Panama&quot;&gt;</span><br><span class="line">        &lt;rank updated=&quot;yes&quot;&gt;69&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2011&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;13600&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Costa Rica&quot; direction=&quot;W&quot;/&gt;</span><br><span class="line">        &lt;neighbor name=&quot;Colombia&quot; direction=&quot;E&quot;/&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>xml协议在各个语言里的都 是支持的，在python中可以用以下模块操作xml 　</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root = tree.getroot()</span><br><span class="line">print(root.tag)</span><br><span class="line"> </span><br><span class="line">#遍历xml文档</span><br><span class="line">for child in root:</span><br><span class="line">    print(child.tag, child.attrib)</span><br><span class="line">    for i in child:</span><br><span class="line">        print(i.tag,i.text)</span><br><span class="line"> </span><br><span class="line">#只遍历year 节点</span><br><span class="line">for node in root.iter(&#x27;year&#x27;):</span><br><span class="line">    print(node.tag,node.text)</span><br></pre></td></tr></table></figure><h3 id="修改和删除xml文档内容"><a href="#修改和删除xml文档内容" class="headerlink" title="修改和删除xml文档内容"></a>修改和删除xml文档内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line">tree = ET.parse(&quot;xmltest.xml&quot;)</span><br><span class="line">root = tree.getroot()</span><br><span class="line"> </span><br><span class="line">#修改</span><br><span class="line">for node in root.iter(&#x27;year&#x27;):</span><br><span class="line">    new_year = int(node.text) + 1</span><br><span class="line">    node.text = str(new_year)</span><br><span class="line">    node.set(&quot;updated&quot;,&quot;yes&quot;)</span><br><span class="line"> </span><br><span class="line">tree.write(&quot;xmltest.xml&quot;)</span><br><span class="line"> </span><br><span class="line">#删除node</span><br><span class="line">for country in root.findall(&#x27;country&#x27;):</span><br><span class="line">   rank = int(country.find(&#x27;rank&#x27;).text)</span><br><span class="line">   if rank &gt; 50:</span><br><span class="line">     root.remove(country)</span><br><span class="line"> </span><br><span class="line">tree.write(&#x27;output.xml&#x27;)</span><br></pre></td></tr></table></figure><h3 id="自己创建xml文档"><a href="#自己创建xml文档" class="headerlink" title="自己创建xml文档"></a>自己创建xml文档</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import xml.etree.ElementTree as ET</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">new_xml = ET.Element(&quot;namelist&quot;)</span><br><span class="line">name = ET.SubElement(new_xml,&quot;name&quot;,attrib=&#123;&quot;enrolled&quot;:&quot;yes&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name,&quot;age&quot;,attrib=&#123;&quot;checked&quot;:&quot;no&quot;&#125;)</span><br><span class="line">sex = ET.SubElement(name,&quot;sex&quot;)</span><br><span class="line">sex.text = &#x27;33&#x27;</span><br><span class="line">name2 = ET.SubElement(new_xml,&quot;name&quot;,attrib=&#123;&quot;enrolled&quot;:&quot;no&quot;&#125;)</span><br><span class="line">age = ET.SubElement(name2,&quot;age&quot;)</span><br><span class="line">age.text = &#x27;19&#x27;</span><br><span class="line"> </span><br><span class="line">et = ET.ElementTree(new_xml) #生成文档对象</span><br><span class="line">et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;,xml_declaration=True)</span><br><span class="line"> </span><br><span class="line">ET.dump(new_xml) #打印生成的格式</span><br></pre></td></tr></table></figure><h2 id="PyYAML模块"><a href="#PyYAML模块" class="headerlink" title="PyYAML模块"></a>PyYAML模块</h2><p>Python也可以很容易的处理ymal文档格式，只不过需要安装一个模块，参考文档：<a href="http://pyyaml.org/wiki/PyYAMLDocumentation">http://pyyaml.org/wiki/PyYAMLDocumentation</a> </p><h2 id="ConfigParser模块"><a href="#ConfigParser模块" class="headerlink" title="ConfigParser模块"></a>ConfigParser模块</h2><p><strong>用于生成和修改常见配置文档，当前模块的名称在 python 3.x 版本中变更为 configparser。</strong></p><p>来看一个好多软件的常见文档格式如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">ServerAliveInterval = 45</span><br><span class="line">Compression = yes</span><br><span class="line">CompressionLevel = 9</span><br><span class="line">ForwardX11 = yes</span><br><span class="line"> </span><br><span class="line">[bitbucket.org]</span><br><span class="line">User = hg</span><br><span class="line"> </span><br><span class="line">[topsecret.server.com]</span><br><span class="line">Port = 50022</span><br><span class="line">ForwardX11 = no</span><br></pre></td></tr></table></figure></p><h3 id="生成配置文档"><a href="#生成配置文档" class="headerlink" title="生成配置文档"></a>生成配置文档</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import configparser</span><br><span class="line"> </span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config[&quot;DEFAULT&quot;] = &#123;&#x27;ServerAliveInterval&#x27;: &#x27;45&#x27;,</span><br><span class="line">                      &#x27;Compression&#x27;: &#x27;yes&#x27;,</span><br><span class="line">                     &#x27;CompressionLevel&#x27;: &#x27;9&#x27;&#125;</span><br><span class="line"> </span><br><span class="line">config[&#x27;bitbucket.org&#x27;] = &#123;&#125;</span><br><span class="line">config[&#x27;bitbucket.org&#x27;][&#x27;User&#x27;] = &#x27;hg&#x27;</span><br><span class="line">config[&#x27;topsecret.server.com&#x27;] = &#123;&#125;</span><br><span class="line">topsecret = config[&#x27;topsecret.server.com&#x27;]</span><br><span class="line">topsecret[&#x27;Host Port&#x27;] = &#x27;50022&#x27;     # mutates the parser</span><br><span class="line">topsecret[&#x27;ForwardX11&#x27;] = &#x27;no&#x27;  # same here</span><br><span class="line">config[&#x27;DEFAULT&#x27;][&#x27;ForwardX11&#x27;] = &#x27;yes&#x27;</span><br><span class="line">with open(&#x27;example.ini&#x27;, &#x27;w&#x27;) as configfile:</span><br><span class="line">   config.write(configfile)</span><br></pre></td></tr></table></figure><h3 id="读取配置文档"><a href="#读取配置文档" class="headerlink" title="读取配置文档"></a>读取配置文档</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import configparser</span><br><span class="line">&gt;&gt;&gt; config = configparser.ConfigParser()</span><br><span class="line">&gt;&gt;&gt; config.sections()</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; config.read(&#x27;example.ini&#x27;)</span><br><span class="line">[&#x27;example.ini&#x27;]</span><br><span class="line">&gt;&gt;&gt; config.sections()</span><br><span class="line">[&#x27;bitbucket.org&#x27;, &#x27;topsecret.server.com&#x27;]</span><br><span class="line">&gt;&gt;&gt; &#x27;bitbucket.org&#x27; in config</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#x27;bytebong.com&#x27; in config</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; config[&#x27;bitbucket.org&#x27;][&#x27;User&#x27;]</span><br><span class="line">&#x27;hg&#x27;</span><br><span class="line">&gt;&gt;&gt; config[&#x27;DEFAULT&#x27;][&#x27;Compression&#x27;]</span><br><span class="line">&#x27;yes&#x27;</span><br><span class="line">&gt;&gt;&gt; topsecret = config[&#x27;topsecret.server.com&#x27;]</span><br><span class="line">&gt;&gt;&gt; topsecret[&#x27;ForwardX11&#x27;]</span><br><span class="line">&#x27;no&#x27;</span><br><span class="line">&gt;&gt;&gt; topsecret[&#x27;Port&#x27;]</span><br><span class="line">&#x27;50022&#x27;</span><br><span class="line">&gt;&gt;&gt; for key in config[&#x27;bitbucket.org&#x27;]: print(key)</span><br><span class="line">...</span><br><span class="line">user</span><br><span class="line">compressionlevel</span><br><span class="line">serveraliveinterval</span><br><span class="line">compression</span><br><span class="line">forwardx11</span><br><span class="line">&gt;&gt;&gt; config[&#x27;bitbucket.org&#x27;][&#x27;ForwardX11&#x27;]</span><br><span class="line">&#x27;yes&#x27;</span><br></pre></td></tr></table></figure><h3 id="configparser增删改查语法"><a href="#configparser增删改查语法" class="headerlink" title="configparser增删改查语法"></a>configparser增删改查语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[section1]</span><br><span class="line">k1 = v1</span><br><span class="line">k2:v2</span><br><span class="line">  </span><br><span class="line">[section2]</span><br><span class="line">k1 = v1</span><br><span class="line"> </span><br><span class="line">import ConfigParser</span><br><span class="line">  </span><br><span class="line">config = ConfigParser.ConfigParser()</span><br><span class="line">config.read(&#x27;i.cfg&#x27;)</span><br><span class="line">  </span><br><span class="line"># ########## 读 ##########</span><br><span class="line">#secs = config.sections()</span><br><span class="line">#print secs</span><br><span class="line">#options = config.options(&#x27;group2&#x27;)</span><br><span class="line">#print options</span><br><span class="line">  </span><br><span class="line">#item_list = config.items(&#x27;group2&#x27;)</span><br><span class="line">#print item_list</span><br><span class="line">  </span><br><span class="line">#val = config.get(&#x27;group1&#x27;,&#x27;key&#x27;)</span><br><span class="line">#val = config.getint(&#x27;group1&#x27;,&#x27;key&#x27;)</span><br><span class="line">  </span><br><span class="line"># ########## 改写 ##########</span><br><span class="line">#sec = config.remove_section(&#x27;group1&#x27;)</span><br><span class="line">#config.write(open(&#x27;i.cfg&#x27;, &quot;w&quot;))</span><br><span class="line">  </span><br><span class="line">#sec = config.has_section(&#x27;wupeiqi&#x27;)</span><br><span class="line">#sec = config.add_section(&#x27;wupeiqi&#x27;)</span><br><span class="line">#config.write(open(&#x27;i.cfg&#x27;, &quot;w&quot;))</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">#config.set(&#x27;group2&#x27;,&#x27;k1&#x27;,11111)</span><br><span class="line">#config.write(open(&#x27;i.cfg&#x27;, &quot;w&quot;))</span><br><span class="line">  </span><br><span class="line">#config.remove_option(&#x27;group2&#x27;,&#x27;age&#x27;)</span><br><span class="line">#config.write(open(&#x27;i.cfg&#x27;, &quot;w&quot;))</span><br></pre></td></tr></table></figure><h2 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块　"></a>hashlib模块　</h2><p><strong>用于加密相关的操作，3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"> </span><br><span class="line">m = hashlib.md5()</span><br><span class="line">m.update(b&quot;Hello&quot;)</span><br><span class="line">m.update(b&quot;It&#x27;s me&quot;)</span><br><span class="line">print(m.digest())</span><br><span class="line">m.update(b&quot;It&#x27;s been a long time since last time we ...&quot;)</span><br><span class="line"> </span><br><span class="line">print(m.digest()) #2进制格式hash</span><br><span class="line">print(len(m.hexdigest())) #16进制格式hash</span><br><span class="line"></span><br><span class="line"># ######## md5 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.md5()</span><br><span class="line">hash.update(&#x27;admin&#x27;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha1 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha1()</span><br><span class="line">hash.update(&#x27;admin&#x27;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha256 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha256()</span><br><span class="line">hash.update(&#x27;admin&#x27;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># ######## sha384 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha384()</span><br><span class="line">hash.update(&#x27;admin&#x27;)</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"> </span><br><span class="line"># ######## sha512 ########</span><br><span class="line"> </span><br><span class="line">hash = hashlib.sha512()</span><br><span class="line">hash.update(&#x27;admin&#x27;)</span><br><span class="line">print(hash.hexdigest())</span><br></pre></td></tr></table></figure><p>还不够吊？python 还有一个 hmac 模块，它内部对我们创建 key 和 内容 再进行处理然后再加密</p><p>散列消息鉴别码，简称HMAC，是一种基于消息鉴别码MAC（Message Authentication Code）的鉴别机制。使用HMAC时,消息通讯的双方，通过验证消息中加入的鉴别密钥K来鉴别消息的真伪；</p><p>一般用于网络通信中消息加密，前提是双方先要约定好key,就像接头暗号一样，然后消息发送把用key把消息加密，接收方用key ＋ 消息明文再加密，拿加密后的值 跟 发送者的相对比是否相等，这样就能验证消息的真实性，及发送者的合法性了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import hmac</span><br><span class="line">h = hmac.new(b&#x27;天王盖地虎&#x27;, b&#x27;宝塔镇河妖&#x27;)</span><br><span class="line">print h.hexdigest()</span><br></pre></td></tr></table></figure><br>更多关于md5,sha1,sha256等介绍的文章看这里<a href="https://www.tbs-certificates.co.uk/FAQ/en/sha256.html">https://www.tbs-certificates.co.uk/FAQ/en/sha256.html</a> </p><h2 id="Subprocess模块"><a href="#Subprocess模块" class="headerlink" title="Subprocess模块"></a>Subprocess模块</h2><p>常用subprocess方法示例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#执行命令，返回命令执行状态 ， 0 or 非0</span><br><span class="line">&gt;&gt;&gt; retcode = subprocess.call([&quot;ls&quot;, &quot;-l&quot;])</span><br><span class="line"></span><br><span class="line">#执行命令，如果命令结果为0，就正常返回，否则抛异常</span><br><span class="line">&gt;&gt;&gt; subprocess.check_call([&quot;ls&quot;, &quot;-l&quot;])</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">#接收字符串格式命令，返回元组形式，第1个元素是执行状态，第2个是命令结果 </span><br><span class="line">&gt;&gt;&gt; subprocess.getstatusoutput(&#x27;ls /bin/ls&#x27;)</span><br><span class="line">(0, &#x27;/bin/ls&#x27;)</span><br><span class="line"></span><br><span class="line">#接收字符串格式命令，并返回结果</span><br><span class="line">&gt;&gt;&gt; subprocess.getoutput(&#x27;ls /bin/ls&#x27;)</span><br><span class="line">&#x27;/bin/ls&#x27;</span><br><span class="line"></span><br><span class="line">#执行命令，并返回结果，注意是返回结果，不是打印，下例结果返回给res</span><br><span class="line">&gt;&gt;&gt; res=subprocess.check_output([&#x27;ls&#x27;,&#x27;-l&#x27;])</span><br><span class="line">&gt;&gt;&gt; res</span><br><span class="line">b&#x27;total 0\ndrwxr-xr-x 12 alex staff 408 Nov 2 11:05 OldBoyCRM\n&#x27;</span><br><span class="line"></span><br><span class="line">#上面那些方法，底层都是封装的subprocess.Popen</span><br><span class="line">poll()</span><br><span class="line">Check if child process has terminated. Returns returncode</span><br><span class="line"></span><br><span class="line">wait()</span><br><span class="line">Wait for child process to terminate. Returns returncode attribute.</span><br><span class="line"></span><br><span class="line">terminate() 杀掉所启动进程</span><br><span class="line">communicate() 等待任务结束</span><br><span class="line"></span><br><span class="line">stdin 标准输入</span><br><span class="line"></span><br><span class="line">stdout 标准输出</span><br><span class="line"></span><br><span class="line">stderr 标准错误</span><br><span class="line"></span><br><span class="line">pid</span><br><span class="line">The process ID of the child process.</span><br><span class="line"></span><br><span class="line">#例子</span><br><span class="line">&gt;&gt;&gt; p = subprocess.Popen(&quot;df -h|grep disk&quot;,stdin=subprocess.PIPE,stdout=subprocess.PIPE,shell=True)</span><br><span class="line">&gt;&gt;&gt; p.stdout.read()</span><br><span class="line">b&#x27;/dev/disk1 465Gi 64Gi 400Gi 14% 16901472 104938142 14% /\n</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; subprocess.run([&quot;ls&quot;, &quot;-l&quot;])  # doesn&#x27;t capture output</span><br><span class="line">CompletedProcess(args=[&#x27;ls&#x27;, &#x27;-l&#x27;], returncode=0)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; subprocess.run(&quot;exit 1&quot;, shell=True, check=True)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">subprocess.CalledProcessError: Command &#x27;exit 1&#x27; returned non-zero exit status 1</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; subprocess.run([&quot;ls&quot;, &quot;-l&quot;, &quot;/dev/null&quot;], stdout=subprocess.PIPE)</span><br><span class="line">CompletedProcess(args=[&#x27;ls&#x27;, &#x27;-l&#x27;, &#x27;/dev/null&#x27;], returncode=0,</span><br><span class="line">stdout=b&#x27;crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\n&#x27;)&#x27;</span><br></pre></td></tr></table></figure></p><p>调用subprocess.run(…)是推荐的常用方法，在大多数情况下能满足需求，但如果你可能需要进行一些复杂的与系统的交互的话，你还可以用subprocess.Popen(),语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = subprocess.Popen(&quot;find / -size +1000000 -exec ls -shl &#123;&#125; \;&quot;,shell=True,stdout=subprocess.PIPE)</span><br><span class="line">print(p.stdout.read())</span><br></pre></td></tr></table></figure><br>可用参数：</p><ul><li>args：shell命令，可以是字符串或者序列类型（如：list，元组）</li><li>bufsize：指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲</li><li>stdin, stdout, stderr：分别表示程序的标准输入、输出、错误句柄</li><li>preexec_fn：只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用</li><li>close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。所以不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。</li><li>shell：同上</li><li>cwd：用于设置子进程的当前目录</li><li>env：用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。</li><li>universal_newlines：不同系统的换行符不同，True -&gt; 同意使用 \n</li><li>startupinfo与createionflags只在windows下有效<br>将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等</li></ul><p>终端输入的命令分为两种：</p><ul><li>输入即可得到输出，如：ifconfig</li><li>输入进行某环境，依赖再输入，如：python</li></ul><p>需要交互的命令示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"> </span><br><span class="line">obj = subprocess.Popen([&quot;python&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">obj.stdin.write(&#x27;print 1 \n &#x27;)</span><br><span class="line">obj.stdin.write(&#x27;print 2 \n &#x27;)</span><br><span class="line">obj.stdin.write(&#x27;print 3 \n &#x27;)</span><br><span class="line">obj.stdin.write(&#x27;print 4 \n &#x27;)</span><br><span class="line"> </span><br><span class="line">out_error_list = obj.communicate(timeout=10)</span><br><span class="line">print out_error_list</span><br></pre></td></tr></table></figure><p><strong>subprocess实现sudo 自动输入密码</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"> </span><br><span class="line">def mypass():</span><br><span class="line">    mypass = &#x27;123&#x27; #or get the password from anywhere</span><br><span class="line">    return mypass</span><br><span class="line"> </span><br><span class="line">echo = subprocess.Popen([&#x27;echo&#x27;,mypass()],</span><br><span class="line">                        stdout=subprocess.PIPE,</span><br><span class="line">                        )</span><br><span class="line"> </span><br><span class="line">sudo = subprocess.Popen([&#x27;sudo&#x27;,&#x27;-S&#x27;,&#x27;iptables&#x27;,&#x27;-L&#x27;],</span><br><span class="line">                        stdin=echo.stdout,</span><br><span class="line">                        stdout=subprocess.PIPE,</span><br><span class="line">                        )</span><br><span class="line"> </span><br><span class="line">end_of_pipe = sudo.stdout</span><br><span class="line"> </span><br><span class="line">print &quot;Password ok \n Iptables Chains %s&quot; % end_of_pipe.read()</span><br></pre></td></tr></table></figure></p><h2 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h2><blockquote><p>很多程序都有记录日志的需求，并且日志中包含的信息即有正常的程序访问日志，还可能有错误、警告等信息输出，python的logging模块提供了标准的日志接口，你可以通过它存储各种格式的日志，logging的日志可以分为 debug(), info(), warning(), error() and critical() 5个级别，下面我们看一下怎么用。</p></blockquote><p>最简单用法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"> </span><br><span class="line">logging.warning(&quot;user [alex] attempted wrong password more than 3 times&quot;)</span><br><span class="line">logging.critical(&quot;server is down&quot;)</span><br><span class="line"> </span><br><span class="line">#输出</span><br><span class="line">WARNING:root:user [alex] attempted wrong password more than 3 times</span><br><span class="line">CRITICAL:root:server is down</span><br></pre></td></tr></table></figure></p><p>看一下这几个日志级别分别代表什么意思</p><div class="table-container"><table><thead><tr><th>Level</th><th>When it’s used</th></tr></thead><tbody><tr><td>DEBUG</td><td>Detailed information, typically of interest only when diagnosing problems.</td></tr><tr><td>INFO</td><td>Confirmation that things are working as expected.</td></tr><tr><td>WARNING</td><td>An indication that something unexpected happened, or indicative of some problem in the near future (e.g. ‘disk space low’). The software is still working as expected.</td></tr><tr><td>ERROR</td><td>Due to a more serious problem, the software has not been able to perform some function.</td></tr><tr><td>CRITICAL</td><td>A serious error, indicating that the program itself may be unable to continue running.</td></tr></tbody></table></div><p>如果想把日志写到文件里，也很简单<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"> </span><br><span class="line">logging.basicConfig(filename=&#x27;example.log&#x27;,level=logging.INFO)</span><br><span class="line">logging.debug(&#x27;This message should go to the log file&#x27;)</span><br><span class="line">logging.info(&#x27;So should this&#x27;)</span><br><span class="line">logging.warning(&#x27;And this, too&#x27;)</span><br></pre></td></tr></table></figure><br>其中下面这句中的level=loggin.INFO意思是，把日志纪录级别设置为INFO，也就是说，只有比日志是INFO或比INFO级别更高的日志才会被纪录到文件里，在这个例子， 第一条日志是不会被纪录的，如果希望纪录debug的日志，那把日志级别改成DEBUG就行了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(filename=&#x27;example.log&#x27;,level=logging.INFO)</span><br></pre></td></tr></table></figure><br>感觉上面的日志格式忘记加上时间啦，日志不知道时间怎么行呢，下面就来加上!<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(format=&#x27;%(asctime)s %(message)s&#x27;, datefmt=&#x27;%m/%d/%Y %I:%M:%S %p&#x27;)</span><br><span class="line">logging.warning(&#x27;is when this event was logged.&#x27;)</span><br><span class="line"> </span><br><span class="line">#输出</span><br><span class="line">12/12/2010 11:46:36 AM is when this event was logged.</span><br></pre></td></tr></table></figure></p><h3 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h3><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>%(name)s</td><td>Logger的名字</td></tr><tr><td>%(levelno)s</td><td>数字形式的日志级别</td></tr><tr><td>%(levelname)s</td><td>文本形式的日志级别</td></tr><tr><td>%(pathname)s</td><td>调用日志输出函数的模块的完整路径名，可能没有</td></tr><tr><td>%(filename)s</td><td>调用日志输出函数的模块的文件名</td></tr><tr><td>%(module)s</td><td>调用日志输出函数的模块名</td></tr><tr><td>%(funcName)s</td><td>调用日志输出函数的函数名</td></tr><tr><td>%(lineno)d</td><td>调用日志输出函数的语句所在的代码行</td></tr><tr><td>%(created)f</td><td>当前时间，用UNIX标准的表示时间的浮 点数表示</td></tr><tr><td>%(relativeCreated)d</td><td>输出日志信息时的，自Logger创建以 来的毫秒数</td></tr><tr><td>%(asctime)s</td><td>字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒</td></tr><tr><td>%(thread)d</td><td>线程ID。可能没有</td></tr><tr><td>%(threadName)s</td><td>线程名。可能没有</td></tr><tr><td>%(process)d</td><td>进程ID。可能没有</td></tr><tr><td>%(message)s</td><td>用户输出的消息</td></tr></tbody></table></div><p>如果想同时把log打印在屏幕和文件日志里，就需要了解一点复杂的知识 了</p><p>Python 使用logging模块记录日志涉及四个主要类，使用官方文档中的概括最为合适：<br><strong>logger提供了应用程序可以直接使用的接口；</strong><br><strong>handler将(logger创建的)日志记录发送到合适的目的输出；</strong><br><strong>filter提供了细度设备来决定输出哪条日志记录；</strong><br><strong>formatter决定日志记录的最终输出格式</strong>。<br><code>logger</code><br>每个程序在输出信息之前都要获得一个Logger。Logger通常对应了程序的模块名，比如聊天工具的图形界面模块可以这样获得它的Logger：<br>LOG=logging.getLogger(”chat.gui”)<br>而核心模块可以这样：<br>LOG=logging.getLogger(”chat.kernel”)</p><p>Logger.setLevel(lel):指定最低的日志级别，低于lel的级别将被忽略。debug是最低的内置级别，critical为最高<br>Logger.addFilter(filt)、Logger.removeFilter(filt):添加或删除指定的filter<br>Logger.addHandler(hdlr)、Logger.removeHandler(hdlr)：增加或删除指定的handler<br>Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()：可以设置的日志级别</p><p><code>handler</code><br>handler对象负责发送相关的信息到指定目的地。Python的日志系统有多种Handler可以使用。有些Handler可以把信息输出到控制台，有些Logger可以把信息输出到文件，还有些 Handler可以把信息发送到网络上。如果觉得不够用，还可以编写自己的Handler。可以通过addHandler()方法添加多个多handler<br>Handler.setLevel(lel):指定被处理的信息级别，低于lel级别的信息将被忽略<br>Handler.setFormatter()：给这个handler选择一个格式<br>Handler.addFilter(filt)、Handler.removeFilter(filt)：新增或删除一个filter对象</p><p>每个Logger可以附加多个Handler。接下来我们就来介绍一些常用的Handler：<br>1) <code>logging.StreamHandler</code><br>使用这个Handler可以向类似与sys.stdout或者sys.stderr的任何文件对象(file object)输出信息。它的构造函数是：<br>StreamHandler([strm])<br>其中strm参数是一个文件对象。默认是sys.stderr</p><p>2) <code>logging.FileHandler</code><br>和StreamHandler类似，用于向一个文件输出日志信息。不过FileHandler会帮你打开这个文件。它的构造函数是：<br>FileHandler(filename[,mode])<br>filename是文件名，必须指定一个文件名。<br>mode是文件的打开方式。参见Python内置函数open()的用法。默认是’a’，即添加到文件末尾。</p><p>3) <code>logging.handlers.RotatingFileHandler</code><br>这个Handler类似于上面的FileHandler，但是它可以管理文件大小。当文件达到一定大小之后，它会自动将当前日志文件改名，然后创建 一个新的同名日志文件继续输出。比如日志文件是chat.log。当chat.log达到指定的大小之后，RotatingFileHandler自动把 文件改名为chat.log.1。不过，如果chat.log.1已经存在，会先把chat.log.1重命名为chat.log.2。。。最后重新创建 chat.log，继续输出日志信息。它的构造函数是：<br>RotatingFileHandler( filename[, mode[, maxBytes[, backupCount]]])<br>其中filename和mode两个参数和FileHandler一样。<br>maxBytes用于指定日志文件的最大文件大小。如果maxBytes为0，意味着日志文件可以无限大，这时上面描述的重命名过程就不会发生。<br>backupCount用于指定保留的备份文件的个数。比如，如果指定为2，当上面描述的重命名过程发生时，原有的chat.log.2并不会被更名，而是被删除。</p><p>4) <code>logging.handlers.TimedRotatingFileHandler</code><br>这个Handler和RotatingFileHandler类似，不过，它没有通过判断文件大小来决定何时重新创建日志文件，而是间隔一定时间就 自动创建新的日志文件。重命名的过程与RotatingFileHandler类似，不过新的文件不是附加数字，而是当前时间。它的构造函数是：<br>TimedRotatingFileHandler( filename [,when [,interval [,backupCount]]])<br>其中filename参数和backupCount参数和RotatingFileHandler具有相同的意义。<br>interval是时间间隔。<br>when参数是一个字符串。表示时间间隔的单位，不区分大小写。它有以下取值：<br>S 秒<br>M 分<br>H 小时<br>D 天<br>W 每星期（interval==0时代表星期一）<br>midnight 每天凌晨</p><p>示例<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"> </span><br><span class="line">#create logger</span><br><span class="line">logger = logging.getLogger(&#x27;TEST-LOG&#x27;)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"> </span><br><span class="line"># create console handler and set level to debug</span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">ch.setLevel(logging.DEBUG)</span><br><span class="line"> </span><br><span class="line"># create file handler and set level to warning</span><br><span class="line">fh = logging.FileHandler(&quot;access.log&quot;)</span><br><span class="line">fh.setLevel(logging.WARNING)</span><br><span class="line"># create formatter</span><br><span class="line">formatter = logging.Formatter(&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;)</span><br><span class="line"> </span><br><span class="line"># add formatter to ch and fh</span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line"> </span><br><span class="line"># add ch and fh to logger</span><br><span class="line">logger.addHandler(ch)</span><br><span class="line">logger.addHandler(fh)</span><br><span class="line"> </span><br><span class="line"># &#x27;application&#x27; code</span><br><span class="line">logger.debug(&#x27;debug message&#x27;)</span><br><span class="line">logger.info(&#x27;info message&#x27;)</span><br><span class="line">logger.warn(&#x27;warn message&#x27;)</span><br><span class="line">logger.error(&#x27;error message&#x27;)</span><br><span class="line">logger.critical(&#x27;critical message&#x27;)</span><br></pre></td></tr></table></figure></p><p>文件自动截断例子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">from logging import handlers</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">log_file = &quot;timelog.log&quot;</span><br><span class="line">#fh = handlers.RotatingFileHandler(filename=log_file,maxBytes=10,backupCount=3)</span><br><span class="line">fh = handlers.TimedRotatingFileHandler(filename=log_file,when=&quot;S&quot;,interval=5,backupCount=3)</span><br><span class="line"></span><br><span class="line">formatter = logging.Formatter(&#x27;%(asctime)s %(module)s:%(lineno)d %(message)s&#x27;)</span><br><span class="line"></span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">logger.addHandler(fh)</span><br><span class="line"></span><br><span class="line">logger.warning(&quot;test1&quot;)</span><br><span class="line">logger.warning(&quot;test12&quot;)</span><br><span class="line">logger.warning(&quot;test13&quot;)</span><br><span class="line">logger.warning(&quot;test14&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x27;.&#x27;     默认匹配除\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行</span><br><span class="line">&#x27;^&#x27;     匹配字符开头，若指定flags MULTILINE,这种也可以匹配上(r&quot;^a&quot;,&quot;\nabc\neee&quot;,flags=re.MULTILINE)</span><br><span class="line">&#x27;$&#x27;     匹配字符结尾，或e.search(&quot;foo$&quot;,&quot;bfoo\nsdfsf&quot;,flags=re.MULTILINE).group()也可以</span><br><span class="line">&#x27;*&#x27;     匹配*号前的字符0次或多次，re.findall(&quot;ab*&quot;,&quot;cabb3abcbbac&quot;)  结果为[&#x27;abb&#x27;, &#x27;ab&#x27;, &#x27;a&#x27;]</span><br><span class="line">&#x27;+&#x27;     匹配前一个字符1次或多次，re.findall(&quot;ab+&quot;,&quot;ab+cd+abb+bba&quot;) 结果[&#x27;ab&#x27;, &#x27;abb&#x27;]</span><br><span class="line">&#x27;?&#x27;     匹配前一个字符1次或0次</span><br><span class="line">&#x27;&#123;m&#125;&#x27;   匹配前一个字符m次</span><br><span class="line">&#x27;&#123;n,m&#125;&#x27; 匹配前一个字符n到m次，re.findall(&quot;ab&#123;1,3&#125;&quot;,&quot;abb abc abbcbbb&quot;) 结果&#x27;abb&#x27;, &#x27;ab&#x27;, &#x27;abb&#x27;]</span><br><span class="line">&#x27;|&#x27;     匹配|左或|右的字符，re.search(&quot;abc|ABC&quot;,&quot;ABCBabcCD&quot;).group() 结果&#x27;ABC&#x27;</span><br><span class="line">&#x27;(...)&#x27; 分组匹配，re.search(&quot;(abc)&#123;2&#125;a(123|456)c&quot;, &quot;abcabca456c&quot;).group() 结果 abcabca456c</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x27;\A&#x27;    只从字符开头匹配，re.search(&quot;\Aabc&quot;,&quot;alexabc&quot;) 是匹配不到的</span><br><span class="line">&#x27;\Z&#x27;    匹配字符结尾，同$</span><br><span class="line">&#x27;\d&#x27;    匹配数字0-9</span><br><span class="line">&#x27;\D&#x27;    匹配非数字</span><br><span class="line">&#x27;\w&#x27;    匹配[A-Za-z0-9]</span><br><span class="line">&#x27;\W&#x27;    匹配非[A-Za-z0-9]</span><br><span class="line">&#x27;s&#x27;     匹配空白字符、\t、\n、\r , re.search(&quot;\s+&quot;,&quot;ab\tc1\n3&quot;).group() 结果 &#x27;\t&#x27;</span><br><span class="line">&#x27;(?P&lt;name&gt;...)&#x27; 分组匹配</span><br></pre></td></tr></table></figure><blockquote><p>re.search(“(?P<province>[0-9]{4})(?P<city>[0-9]{2})(?P<birthday>[0-9]{4})”,”371481199306143242”).groupdict(“city”) </p><p>结果{‘province’: ‘3714’, ‘city’: ‘81’, ‘birthday’: ‘1993’}</p></blockquote><p>最常用的匹配语法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">re.match 从头开始匹配</span><br><span class="line">re.search 匹配包含</span><br><span class="line">re.findall 把所有匹配到的字符放到以列表中的元素返回</span><br><span class="line">re.splitall 以匹配到的字符当做列表分隔符</span><br><span class="line">re.sub      匹配字符并替换</span><br></pre></td></tr></table></figure></p><h3 id="反斜杠的困扰"><a href="#反斜杠的困扰" class="headerlink" title="反斜杠的困扰"></a>反斜杠的困扰</h3><p>与大多数编程语言相同，正则表达式里使用”\”作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\”，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\“表示。同样，匹配一个数字的”\d”可以写成r”\d”。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。</p><p>仅需轻轻知道的几个匹配模式<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）</span><br><span class="line">re.M(MULTILINE): 多行模式，改变&#x27;^&#x27;和&#x27;$&#x27;的行为（参见上图）</span><br><span class="line">re.S(DOTALL): 点任意匹配模式，改变&#x27;.&#x27;的行为</span><br></pre></td></tr></table></figure></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=28190709&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Python从入门到放弃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python从入门到放弃（5）-- Python基础5</title>
      <link href="/2017/05/25/17-05-25/"/>
      <url>/2017/05/25/17-05-25/</url>
      
        <content type="html"><![CDATA[<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p><strong>列表生成式</strong></p><p>现在有个需求，看列表[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],我要求你把列表里的每个值加1，你怎么实现？你可能会想到3种方式</p><p>原值修改<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">for index,i in enumerate(a):</span><br><span class="line">    a[index] +=1</span><br></pre></td></tr></table></figure><br>列表生成<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; a = map(lambda x:x+1, a)</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [i+1 for i in range(10)]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><p><strong>生成器</strong><br>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span><br></pre></td></tr></table></figure><p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。<br>我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？<br>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">36</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">49</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">81</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>我们讲过，generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p><p>当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; for n in g:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">49</span><br><span class="line">64</span><br><span class="line">81</span><br></pre></td></tr></table></figure><p>所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。</p><p>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。</p><p>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p><p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p><p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &#x27;done&#x27;</span><br></pre></td></tr></table></figure><br>注意，赋值语句：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = b, a + b</span><br></pre></td></tr></table></figure><br>相当于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (b, a + b) # t是一个tuple</span><br><span class="line">a = t[0]</span><br><span class="line">b = t[1]</span><br></pre></td></tr></table></figure><br>但不必显式写出临时变量t就可以赋值。</p><p>上面的函数可以输出斐波那契数列的前N个数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fib(10)</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">55</span><br><span class="line">done</span><br></pre></td></tr></table></figure><br>仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。</p><p>也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield b就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n,a,b = 0,0,1</span><br><span class="line"></span><br><span class="line">    while n &lt; max:</span><br><span class="line">        #print(b)</span><br><span class="line">        yield  b</span><br><span class="line">        a,b = b,a+b</span><br><span class="line"></span><br><span class="line">        n += 1</span><br><span class="line"></span><br><span class="line">    return &#x27;done&#x27;</span><br></pre></td></tr></table></figure><p>这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = fib(6)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;generator object fib at 0x104feaaa0&gt;</span><br></pre></td></tr></table></figure><p>这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">data = fib(10)</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">print(data.__next__())</span><br><span class="line">print(data.__next__())</span><br><span class="line">print(&quot;干点别的事&quot;)</span><br><span class="line">print(data.__next__())</span><br><span class="line">print(data.__next__())</span><br><span class="line">print(data.__next__())</span><br><span class="line">print(data.__next__())</span><br><span class="line">print(data.__next__())</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">&lt;generator object fib at 0x101be02b0&gt;</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">干点别的事</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br></pre></td></tr></table></figure><br>在上面fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</p><p>同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in fib(6):</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br></pre></td></tr></table></figure><br>但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = fib(6)</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     try:</span><br><span class="line">...         x = next(g)</span><br><span class="line">...         print(&#x27;g:&#x27;, x)</span><br><span class="line">...     except StopIteration as e:</span><br><span class="line">...         print(&#x27;Generator return value:&#x27;, e.value)</span><br><span class="line">...         break</span><br><span class="line">...</span><br><span class="line">g: 1</span><br><span class="line">g: 1</span><br><span class="line">g: 2</span><br><span class="line">g: 3</span><br><span class="line">g: 5</span><br><span class="line">g: 8</span><br><span class="line">Generator return value: done</span><br></pre></td></tr></table></figure><br>关于如何捕获错误，后面的错误处理还会详细讲解。</p><p><strong>还可通过yield实现在单线程的情况下实现并发运算的效果</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">def consumer(name):</span><br><span class="line">    print(&quot;%s 准备吃包子啦!&quot; %name)</span><br><span class="line">    while True:</span><br><span class="line">       baozi = yield</span><br><span class="line"></span><br><span class="line">       print(&quot;包子[%s]来了,被[%s]吃了!&quot; %(baozi,name))</span><br><span class="line"></span><br><span class="line">def producer(name):</span><br><span class="line">    c = consumer(&#x27;A&#x27;)</span><br><span class="line">    c2 = consumer(&#x27;B&#x27;)</span><br><span class="line">    c.__next__()</span><br><span class="line">    c2.__next__()</span><br><span class="line">    print(&quot;老子开始准备做包子啦!&quot;)</span><br><span class="line">    for i in range(10):</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print(&quot;做了2个包子!&quot;)</span><br><span class="line">        c.send(i)</span><br><span class="line">        c2.send(i)</span><br><span class="line"></span><br><span class="line">producer(&quot;alex&quot;)</span><br></pre></td></tr></table></figure><br>通过生成器实现协程并行运算</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>我们已经知道，可以直接作用于for循环的数据类型有以下几种：<br>　　一类是集合数据类型，如list、tuple、dict、set、str等；<br>　　一类是generator，包括生成器和带yield的generator function。</p><p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。<br>可以使用isinstance()判断一个对象是否是Iterable对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(100, Iterable)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><br>而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p><p><strong>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。</strong></p><p>可以使用isinstance()判断一个对象是否是Iterator对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterator</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterator)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><br>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</p><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(iter([]), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(iter(&#x27;abc&#x27;), Iterator)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>你可能会问，为什么list、dict、str等数据类型不是Iterator？</p><p>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>凡是可作用于for循环的对象都是Iterable类型；</li><li>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</li><li>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</li><li>Python的for循环本质上就是通过不断调用next()函数实现的，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in [1, 2, 3, 4, 5]:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></li></ul><p>实际上完全等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 首先获得Iterator对象:</span><br><span class="line">it = iter([1, 2, 3, 4, 5])</span><br><span class="line"># 循环:</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        # 获得下一个值:</span><br><span class="line">        x = next(it)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        # 遇到StopIteration就退出循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p><strong>定义</strong>：本质是函数，（装饰其他函数）几十为了其他函数添加附加功能<br><strong>原则</strong>：</p><ol><li>不能修改被装饰的函数的源代码</li><li>不能修改被装饰的函数的调用方式</li></ol><p><strong>场景</strong><br>你是一家视频网站的后端开发工程师，你们网站有以下几个版块<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def home():</span><br><span class="line">    print(&quot;---首页----&quot;)</span><br><span class="line"> </span><br><span class="line">def america():</span><br><span class="line">    print(&quot;----欧美专区----&quot;)</span><br><span class="line"> </span><br><span class="line">def japan():</span><br><span class="line">    print(&quot;----日韩专区----&quot;)</span><br><span class="line"> </span><br><span class="line">def asia():</span><br><span class="line">    print(&quot;----亚洲专区----&quot;)</span><br></pre></td></tr></table></figure></p><p>视频刚上线初期，为了吸引用户，你们采取了免费政策，所有视频免费观看，迅速吸引了一大批用户，免费一段时间后，每天巨大的带宽费用公司承受不了了，所以准备对比较受欢迎的几个版块收费，其中包括“欧美” 和 “亚洲”专区，你拿到这个需求后，想了想，想收费得先让其进行用户认证，认证通过后，再判定这个用户是否是VIP付费会员就可以了，是VIP就让看，不是VIP就不让看就行了呗。 你觉得这个需求很是简单，因为要对多个版块进行认证，那应该把认证功能提取出来单独写个模块，然后每个版块里调用 就可以了，与是你轻轻的就实现了下面的功能 。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">user_status = False #用户登录了就把这个改成True</span><br><span class="line"> </span><br><span class="line">def login():</span><br><span class="line">    _username = &quot;dinson&quot; #假装这是DB里存的用户信息</span><br><span class="line">    _password = &quot;abc!23&quot; #假装这是DB里存的用户信息</span><br><span class="line">    global user_status</span><br><span class="line"> </span><br><span class="line">    if user_status == False:</span><br><span class="line">        username = input(&quot;user:&quot;)</span><br><span class="line">        password = input(&quot;pasword:&quot;)</span><br><span class="line"> </span><br><span class="line">        if username == _username and password == _password:</span><br><span class="line">            print(&quot;welcome login....&quot;)</span><br><span class="line">            user_status = True</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;wrong username or password!&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;用户已登录，验证通过...&quot;)</span><br><span class="line"> </span><br><span class="line">def home():</span><br><span class="line">    print(&quot;---首页----&quot;)</span><br><span class="line"> </span><br><span class="line">def america():</span><br><span class="line">    login() #执行前加上验证</span><br><span class="line">    print(&quot;----欧美专区----&quot;)</span><br><span class="line"> </span><br><span class="line">def japan():</span><br><span class="line">    print(&quot;----日韩专区----&quot;)</span><br><span class="line"> </span><br><span class="line">def asia():</span><br><span class="line">    login() #执行前加上验证</span><br><span class="line">    print(&quot;----亚洲专区----&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">home()</span><br><span class="line">america()</span><br><span class="line">asia()</span><br></pre></td></tr></table></figure><br>此时你信心满满的把这个代码提交给你的TEAM LEADER审核，没成想，没过5分钟，代码就被打回来了， TEAM LEADER给你反馈是，我现在有很多模块需要加认证模块，你的代码虽然实现了功能，但是需要更改需要加认证的各个模块的代码，这直接违反了软件开发中的一个原则“开放-封闭”原则，简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即：</p><ul><li>封闭：已实现的功能代码块</li><li>开放：对扩展开发</li></ul><p>这个原则你还是第一次听说，我擦，再次感受了自己这个野生程序员与正规军的差距，BUT ANYWAY,老大要求的这个怎么实现呢？如何在不改原有功能代码的情况下加上认证功能呢？你一时想不出思路，只好带着这个问题回家继续憋，媳妇不在家，去隔壁老王家串门了，你正好落的清静，一不小心就想到了解决方案，不改源代码可以呀，高阶函数，就是把一个函数当做一个参数传给另外一个函数，我只需要写个认证方法，每次调用 需要验证的功能 时，直接 把这个功能 的函数名当做一个参数 传给 我的验证模块不就行了么，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">user_status = False #用户登录了就把这个改成True</span><br><span class="line"> </span><br><span class="line">def login(func): #把要执行的模块从这里传进来</span><br><span class="line">    _username = &quot;dinson&quot; #假装这是DB里存的用户信息</span><br><span class="line">    _password = &quot;abc!23&quot; #假装这是DB里存的用户信息</span><br><span class="line">    global user_status</span><br><span class="line"> </span><br><span class="line">    if user_status == False:</span><br><span class="line">        username = input(&quot;user:&quot;)</span><br><span class="line">        password = input(&quot;pasword:&quot;)</span><br><span class="line"> </span><br><span class="line">        if username == _username and password == _password:</span><br><span class="line">            print(&quot;welcome login....&quot;)</span><br><span class="line">            user_status = True</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;wrong username or password!&quot;)</span><br><span class="line"> </span><br><span class="line">    if user_status == True:</span><br><span class="line">        func() # 看这里看这里，只要验证通过了，就调用相应功能</span><br><span class="line"> </span><br><span class="line">def home():</span><br><span class="line">    print(&quot;---首页----&quot;)</span><br><span class="line"> </span><br><span class="line">def america():</span><br><span class="line">    #login() #执行前加上验证</span><br><span class="line">    print(&quot;----欧美专区----&quot;)</span><br><span class="line"> </span><br><span class="line">def japan():</span><br><span class="line">    print(&quot;----日韩专区----&quot;)</span><br><span class="line"> </span><br><span class="line">def asia():</span><br><span class="line">    #login() #执行前加上验证</span><br><span class="line">    print(&quot;----亚洲专区----&quot;)</span><br><span class="line"> </span><br><span class="line">home()</span><br><span class="line">login(america) #需要验证就调用 login，把需要验证的功能 当做一个参数传给login</span><br><span class="line"># home()</span><br><span class="line"># america()</span><br><span class="line">login(asia)</span><br></pre></td></tr></table></figure><br>你很开心，终于实现了老板的要求，不改变原功能代码的前提下，给功能加上了验证，此时，媳妇回来了，后面还跟着老王，你两家关系 非常 好，老王经常来串门，老王也是码农，你跟他分享了你写的代码，兴奋的等他看完 夸奖你NB,没成想，老王看后，并没有夸你，抱起你的儿子，笑笑说，你这个代码还是改改吧， 要不然会被开除的，WHAT? 会开除，明明实现了功能 呀， 老王讲，没错，你功能 是实现了，但是你又犯了一个大忌，什么大忌？ </p><p>你改变了调用方式呀， 想一想，现在没每个需要认证的模块，都必须调用你的login()方法，并把自己的函数名传给你，人家之前可不是这么调用 的， 试想，如果 有100个模块需要认证，那这100个模块都得更改调用方式，这么多模块肯定不止是一个人写的，让每个人再去修改调用方式 才能加上认证，你会被骂死的。。。。</p><p>你觉得老王说的对，但问题是，如何即不改变原功能代码，又不改变原有调用方式，还能加上认证呢？ 你苦思了一会，还是想不出，老王在逗你的儿子玩，你说，老王呀，快给我点思路 ，实在想不出来，老王背对着你问，</p><p>老王：学过匿名函数没有？<br>你：学过学过，就是lambda嘛<br>老王：那lambda与正常函数的区别是什么？<br>你：最直接的区别是，正常函数定义时需要写名字，但lambda不需要<br>老王：没错，那lambda定好后，为了多次调用 ，可否也给它命个名？<br>你：可以呀，可以写成plus = lambda x:x+1类似这样，以后再调用plus就可以了，但这样不就失去了lambda的意义了，明明人家叫匿名函数呀，你起了名字有什么用呢？<br>老王：我不是要跟你讨论它的意义 ，我想通过这个让你明白一个事实<br>说着，老王拿起你儿子的画板，在上面写了以下代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def plus(n):</span><br><span class="line">    return n+1</span><br><span class="line">plus2 = lambda x:x+1</span><br></pre></td></tr></table></figure><br>老王： 上面这两种写法是不是代表 同样的意思？<br>你：是的<br>老王：我给lambda x:x+1 起了个名字叫plus2，是不是相当于def plus2(x) ?<br>你：我擦，你别说，还真是，但老王呀，你想说明什么呢？<br>老王： 没啥，只想告诉你，给函数赋值变量名就像def func_name　是一样的效果，如下面的plus(n)函数，你调用时可以用plus名，还可以再起个其它名字，如<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calc = plus</span><br><span class="line"> </span><br><span class="line">calc(n)</span><br></pre></td></tr></table></figure><br>你明白我想传达什么意思了么？<br>你：。。。。。。。。。。。这。。。。。。嗯 。。。。。不太。。。。明白 。。<br>老王：。。。。这。。。。。呵呵。。。。。。好吧。。。。，那我在给你点一下，你之前写的下面这段调用 认证的代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">home()</span><br><span class="line">login(america) #需要验证就调用 login，把需要验证的功能 当做一个参数传给login</span><br><span class="line"># home()</span><br><span class="line"># america()</span><br><span class="line">login(asia)</span><br></pre></td></tr></table></figure><br>你之所改变了调用方式，是因为用户每次调用时需要执行login(asia)，类似的。其实稍一改就可以了呀<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">home()</span><br><span class="line">america = login(america)</span><br><span class="line">asia = login(asia)</span><br></pre></td></tr></table></figure><br>这样你，其它人调用asia时，其实相当于调用了login(asia), 通过login里的验证后，就会自动调用asia功能。 </p><p>你：我擦，还真是唉。。。，老王，还是你nb。。。不过，等等， 我这样写了好，那用户调用时，应该是下面这个样子<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">home()</span><br><span class="line">america = login(america) #你在这里相当于把america这个函数替换了</span><br><span class="line">asia = login(asia)</span><br><span class="line"> </span><br><span class="line">#那用户调用时依然写</span><br><span class="line">america()</span><br></pre></td></tr></table></figure><br>但问题在于，还不等用户调用 ，你的america = login(america)就会先自己把america执行了呀。。。。，你应该等我用户调用 的时候 再执行才对呀，不信我试给你看。。。</p><p>老王：哈哈，你说的没错，这样搞会出现这个问题？ 但你想想有没有解决办法 呢？<br>你：我擦，你指的思路呀，大哥。。。我哪知道 下一步怎么走。。。<br>老王：算了，估计你也想不出来。。。 学过嵌套函数没有？<br>你：yes,然后呢？<br>老王：想实现一开始你写的america = login(america)不触发你函数的执行，只需要在这个login里面再定义一层函数，第一次调用america = login(america)只调用到外层login，这个login虽然会执行，但不会触发认证了，因为认证的所有代码被封装在login里层的新定义 的函数里了，login只返回 里层函数的函数名，这样下次再执行america()时， 就会调用里层函数啦。。。<br>你：。。。。。。什么？ 什么个意思，我蒙逼了。。。<br>c老王：还是给你看代码吧。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def login(func): #把要执行的模块从这里传进来</span><br><span class="line"> </span><br><span class="line">    def inner():#再定义一层函数</span><br><span class="line">        _username = &quot;alex&quot; #假装这是DB里存的用户信息</span><br><span class="line">        _password = &quot;abc!23&quot; #假装这是DB里存的用户信息</span><br><span class="line">        global user_status</span><br><span class="line"> </span><br><span class="line">        if user_status == False:</span><br><span class="line">            username = input(&quot;user:&quot;)</span><br><span class="line">            password = input(&quot;pasword:&quot;)</span><br><span class="line"> </span><br><span class="line">            if username == _username and password == _password:</span><br><span class="line">                print(&quot;welcome login....&quot;)</span><br><span class="line">                user_status = True</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;wrong username or password!&quot;)</span><br><span class="line"> </span><br><span class="line">        if user_status == True:</span><br><span class="line">            func() # 看这里看这里，只要验证通过了，就调用相应功能</span><br><span class="line"> </span><br><span class="line">    return inner #用户调用login时，只会返回inner的内存地址，下次再调用时加上()才会执行inner函数</span><br></pre></td></tr></table></figure><p>此时你仔细着了老王写的代码　，感觉老王真不是一般人呀，连这种奇淫巧技都能想出来。。。，心中默默感谢上天赐你一个大牛邻居。<br>你: 老王呀，你这个姿势很nb呀，你独创的？<br>此时你媳妇噗嗤的笑出声来，你也不知道 她笑个球。。。<br>老王：呵呵， 这不是我独创的呀当然 ，这是开发中一个常用的玩法，叫语法糖，官方名称“装饰器”，其实上面的写法，还可以更简单<br>可以把下面代码去掉<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">america = login(america) #你在这里相当于把america这个函数替换了</span><br></pre></td></tr></table></figure><br>只在你要装饰的函数上面加上下面代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@login</span><br><span class="line">def america():</span><br><span class="line">    #login() #执行前加上验证</span><br><span class="line">    print(&quot;----欧美专区----&quot;)</span><br><span class="line"> </span><br><span class="line">def japan():</span><br><span class="line">    print(&quot;----日韩专区----&quot;)</span><br><span class="line"> </span><br><span class="line">@login</span><br><span class="line">def asia():</span><br><span class="line">    #login() #执行前加上验证</span><br><span class="line">    print(&quot;----亚洲专区----&quot;)</span><br></pre></td></tr></table></figure></p><p>效果是一样的。</p><p>你开心的玩着老王教你的新姿势 ，玩着玩着就手贱给你的“亚洲专区”版块 加了个参数，然后，结果 出错了。。。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TpyeError: inner() takes 0 positional arguments but 1 was given</span><br></pre></td></tr></table></figure><br>你：老王，老王，怎么传个参数就不行了呢？<br>老王：那必然呀，你调用asia时，其实是相当于调用的login，你的asia第一次调用时asia = login(asia)， login就返回了inner的内存地址，第2次用户自己调用asia(“3p”),实际上相当于调用的时inner,但你的inner定义时并没有设置参数，但你给他传了个参数，所以自然就报错了呀<br>你：但是我的 版块需要传参数呀，你不让我传不行呀。。。<br>老王：没说不让你传，稍做改动便可。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">user_status = False  # 用户登录了就把这个改成True</span><br><span class="line"></span><br><span class="line">def login(func):  # 把要执行的模块从这里传进来</span><br><span class="line"></span><br><span class="line">    def inner(arg1):</span><br><span class="line"></span><br><span class="line">        _username = &quot;dinson&quot;  # 假装这是DB里存的用户信息</span><br><span class="line">        _password = &quot;abc!23&quot;  # 假装这是DB里存的用户信息</span><br><span class="line">        global user_status</span><br><span class="line"></span><br><span class="line">        if user_status == False:</span><br><span class="line">            username = input(&quot;user:&quot;)</span><br><span class="line">            password = input(&quot;pasword:&quot;)</span><br><span class="line"></span><br><span class="line">            if username == _username and password == _password:</span><br><span class="line">                print(&quot;welcome login....&quot;)</span><br><span class="line">                user_status = True</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;wrong username or password!&quot;)</span><br><span class="line"></span><br><span class="line">        if user_status == True:</span><br><span class="line">            func(arg1)  # 看这里看这里，只要验证通过了，就调用相应功能</span><br><span class="line"></span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">def home():...</span><br></pre></td></tr></table></figure><p>老王：你再试试就好了 。<br>你： 果然好使，大神就是大神呀。 。。 不过，如果有多个参数呢？<br>老王：。。。。老弟，你不要什么都让我教你吧，非固定参数你没学过么？ <em>args,*</em>kwargs…<br>你：噢 。。。还能这么搞?,nb,我再试试。</p><p>你身陷这种新玩法中无法自拔，竟没注意到老王已经离开，你媳妇告诉你说为了不打扰你加班，今晚带孩子去跟她姐妹住 ，你觉得媳妇真体贴，最终，你终于搞定了所有需求，完全遵循开放-封闭原则，最终代码如下 。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">user_status = False #用户登录了就把这个改成True</span><br><span class="line"> </span><br><span class="line">def login(func): #把要执行的模块从这里传进来</span><br><span class="line"> </span><br><span class="line">    def inner(*args,**kwargs):#再定义一层函数</span><br><span class="line">        _username = &quot;dinson&quot; #假装这是DB里存的用户信息</span><br><span class="line">        _password = &quot;abc!23&quot; #假装这是DB里存的用户信息</span><br><span class="line">        global user_status</span><br><span class="line"> </span><br><span class="line">        if user_status == False:</span><br><span class="line">            username = input(&quot;user:&quot;)</span><br><span class="line">            password = input(&quot;pasword:&quot;)</span><br><span class="line"> </span><br><span class="line">            if username == _username and password == _password:</span><br><span class="line">                print(&quot;welcome login....&quot;)</span><br><span class="line">                user_status = True</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;wrong username or password!&quot;)</span><br><span class="line"> </span><br><span class="line">        if user_status == True:</span><br><span class="line">            func(*args,**kwargs) # 看这里看这里，只要验证通过了，就调用相应功能</span><br><span class="line"> </span><br><span class="line">    return inner #用户调用login时，只会返回inner的内存地址，下次再调用时加上()才会执行inner函数</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def home():</span><br><span class="line">    print(&quot;---首页----&quot;)</span><br><span class="line"> </span><br><span class="line">@login</span><br><span class="line">def america():</span><br><span class="line">    #login() #执行前加上验证</span><br><span class="line">    print(&quot;----欧美专区----&quot;)</span><br><span class="line"> </span><br><span class="line">def japan():</span><br><span class="line">    print(&quot;----日韩专区----&quot;)</span><br><span class="line"> </span><br><span class="line"># @login</span><br><span class="line">def asia(style):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    :param style: 喜欢看什么类型的，就传进来</span><br><span class="line">    :return:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    #login() #执行前加上验证</span><br><span class="line">    print(&quot;----亚洲专区----&quot;)</span><br><span class="line"> </span><br><span class="line">home()</span><br><span class="line"># america = login(america) #你在这里相当于把america这个函数替换了</span><br><span class="line">asia = login(asia)</span><br><span class="line"> </span><br><span class="line"># #那用户调用时依然写</span><br><span class="line">america()</span><br><span class="line"> </span><br><span class="line">asia(&quot;3p&quot;)</span><br></pre></td></tr></table></figure><br>此时，你已累的不行了，洗洗就抓紧睡了，半夜，上厕所，隐隐听到隔壁老王家有微弱的女人的声音传来，你会心一笑，老王这家伙，不声不响找了女朋友也不带给我看看，改天一定要见下真人。。。。</p><p>第二天早上，产品经理又提了新的需求，要允许用户选择用qq\weibo\weixin认证，此时的你，已深谙装饰器各种装逼技巧，轻松的就实现了新的需求。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">user_status = False #用户登录了就把这个改成True</span><br><span class="line"></span><br><span class="line">def login(auth_type): #把要执行的模块从这里传进来</span><br><span class="line">    def auth(func):</span><br><span class="line">        def inner(*args,**kwargs):#再定义一层函数</span><br><span class="line">            if auth_type == &quot;qq&quot;:</span><br><span class="line">                _username = &quot;dinson&quot; #假装这是DB里存的用户信息</span><br><span class="line">                _password = &quot;abc!23&quot; #假装这是DB里存的用户信息</span><br><span class="line">                global user_status</span><br><span class="line"></span><br><span class="line">                if user_status == False:</span><br><span class="line">                    username = input(&quot;user:&quot;)</span><br><span class="line">                    password = input(&quot;pasword:&quot;)</span><br><span class="line"></span><br><span class="line">                    if username == _username and password == _password:</span><br><span class="line">                        print(&quot;welcome login....&quot;)</span><br><span class="line">                        user_status = True</span><br><span class="line">                    else:</span><br><span class="line">                        print(&quot;wrong username or password!&quot;)</span><br><span class="line"></span><br><span class="line">                if user_status == True:</span><br><span class="line">                    return func(*args,**kwargs) # 看这里看这里，只要验证通过了，就调用相应功能</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;only support qq &quot;)</span><br><span class="line">        return inner #用户调用login时，只会返回inner的内存地址，下次再调用时加上()才会执行inner函数</span><br><span class="line"></span><br><span class="line">    return auth</span><br><span class="line"></span><br><span class="line">def home():</span><br><span class="line">    print(&quot;---首页----&quot;)</span><br><span class="line"></span><br><span class="line">@login(&#x27;qq&#x27;)</span><br><span class="line">def america():</span><br><span class="line">    #login() #执行前加上验证</span><br><span class="line">    print(&quot;----欧美专区----&quot;)</span><br><span class="line"></span><br><span class="line">def japan():</span><br><span class="line">    print(&quot;----日韩专区----&quot;)</span><br><span class="line"></span><br><span class="line">@login(&#x27;weibo&#x27;)</span><br><span class="line">def asia(style):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    :param style: 喜欢看什么类型的，就传进来</span><br><span class="line">    :return:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    #login() #执行前加上验证</span><br><span class="line">    print(&quot;----亚洲专区----&quot;)</span><br><span class="line"></span><br><span class="line">home()</span><br><span class="line"># america = login(america) #你在这里相当于把america这个函数替换了</span><br><span class="line">#asia = login(asia)</span><br><span class="line"></span><br><span class="line"># #那用户调用时依然写</span><br><span class="line">america()</span><br><span class="line"></span><br><span class="line"># asia(&quot;3p&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="软件目录结构规范"><a href="#软件目录结构规范" class="headerlink" title="软件目录结构规范"></a>软件目录结构规范</h2><p><strong>为什么要设计好目录结构?</strong></p><p>“设计项目目录结构”，就和”代码编码风格”一样，属于个人风格问题。对于这种风格上的规范，一直都存在两种态度:</p><ol><li>一类同学认为，这种个人风格问题”无关紧要”。理由是能让程序work就好，风格问题根本不是问题。</li><li>另一类同学认为，规范化能更好的控制程序结构，让程序具有更高的可读性。</li></ol><p>我是比较偏向于后者的，因为我是前一类同学思想行为下的直接受害者。我曾经维护过一个非常不好读的项目，其实现的逻辑并不复杂，但是却耗费了我非常长的时间去理解它想表达的意思。从此我个人对于提高项目可读性、可维护性的要求就很高了。”项目目录结构”其实也是属于”可读性和可维护性”的范畴，我们设计一个层次清晰的目录结构，就是为了达到以下两点:</p><ol><li>可读性高: 不熟悉这个项目的代码的人，一眼就能看懂目录结构，知道程序启动脚本是哪个，测试目录在哪儿，配置文件在哪儿等等。从而非常快速的了解这个项目。</li><li>可维护性高: 定义好组织规则后，维护者就能很明确地知道，新增的哪个文件和代码应该放在什么目录之下。这个好处是，随着时间的推移，代码/配置的规模增加，项目结构不会混乱，仍然能够组织良好。</li></ol><p>所以，我认为，保持一个层次清晰的目录结构是有必要的。更何况组织一个良好的工程目录，其实是一件很简单的事儿。</p><p><strong>目录组织方式</strong><br>关于如何组织一个较好的Python工程目录结构，已经有一些得到了共识的目录结构。在Stackoverflow的这个问题上，能看到大家对Python目录结构的讨论。</p><p>这里面说的已经很好了，我也不打算重新造轮子列举各种不同的方式，这里面我说一下我的理解和体会。</p><p>假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Foo/</span><br><span class="line">|-- bin/</span><br><span class="line">|   |-- foo</span><br><span class="line">|</span><br><span class="line">|-- foo/</span><br><span class="line">|   |-- tests/</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- test_main.py</span><br><span class="line">|   |</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- main.py</span><br><span class="line">|</span><br><span class="line">|-- docs/</span><br><span class="line">|   |-- conf.py</span><br><span class="line">|   |-- abc.rst</span><br><span class="line">|</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- requirements.txt</span><br><span class="line">|-- README</span><br></pre></td></tr></table></figure><br>简要解释一下:</p><ol><li>bin/: 存放项目的一些可执行文件，当然你可以起名script/之类的也行。</li><li>foo/: 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录tests/存放单元测试代码； (3) 程序的入口最好命名main.py。</li><li>docs/: 存放一些文档。</li><li>setup.py: 安装、部署、打包的脚本。</li><li>requirements.txt: 存放软件依赖的外部Python包列表。</li><li>README: 项目说明文件。</li></ol><p>除此之外，有一些方案给出了更加多的内容。比如LICENSE.txt,ChangeLog.txt文件等，我没有列在这里，因为这些东西主要是项目开源的时候需要用到。如果你想写一个开源软件，目录该如何组织，可以参考<a href="https://jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/">这篇文章</a>。</p><p>下面，再简单讲一下我对这些目录的理解和个人要求吧。</p><p><strong>关于README的内容</strong><br><strong>这个我觉得是每个项目都应该有的一个文件</strong>，目的是能简要描述该项目的信息，让读者快速了解这个项目。</p><p>它需要说明以下几个事项:</p><ol><li>软件定位，软件的基本功能。</li><li>运行代码的方法: 安装环境、启动命令等。</li><li>简要的使用说明。</li><li>代码目录结构说明，更详细点可以说明软件的基本原理。</li><li>常见问题说明。<br>我觉得有以上几点是比较好的一个README。在软件开发初期，由于开发过程中以上内容可能不明确或者发生变化，并不是一定要在一开始就将所有信息都补全。但是在项目完结的时候，是需要撰写这样的一个文档的。</li></ol><p>可以参考Redis源码中<a href="https://github.com/antirez/redis#what-is-redis">Readme</a>的写法，这里面简洁但是清晰的描述了Redis功能和源码结构。</p><p><strong>关于requirements.txt和setup.py</strong></p><p><strong>setup.py</strong></p><p>一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情。这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，<strong>一个项目一定要有一个安装部署工具</strong>，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</p><p>这个我是踩过坑的。</p><p>我刚开始接触Python写项目的时候，安装环境、部署代码、运行程序这个过程全是手动完成，遇到过以下问题:</p><ol><li>安装环境时经常忘了最近又添加了一个新的Python包，结果一到线上运行，程序就出错了。</li><li>Python包的版本依赖问题，有时候我们程序中使用的是一个版本的Python包，但是官方的已经是最新的包了，通过手动安装就可能装错了。</li><li>如果依赖的包很多的话，一个一个安装这些依赖是很费时的事情。</li><li>新同学开始写项目的时候，将程序跑起来非常麻烦，因为可能经常忘了要怎么安装各种依赖。</li></ol><p>setup.py可以将这些事情自动化起来，提高效率、减少出错的概率。”复杂的东西自动化，能自动化的东西一定要自动化。”是一个非常好的习惯。</p><p>setuptools的文档比较庞大，刚接触的话，可能不太好找到切入点。学习技术的方式就是看他人是怎么用的，可以参考一下Python的一个Web框架，flask是如何写的: setup.py</p><p>当然，简单点自己写个安装脚本（deploy.sh）替代setup.py也未尝不可。</p><p><strong>requirements.txt</strong></p><p>这个文件存在的目的是:</p><ol><li>方便开发者维护软件的包依赖。将开发过程中新增的包添加进这个列表中，避免在setup.py安装依赖时漏掉软件包。</li><li>方便读者明确项目使用了哪些Python包。<br>这个文件的格式是每一行包含一个包依赖的说明，通常是flask&gt;=0.10这种格式，要求是这个格式能被pip识别，这样就可以简单的通过 pip install -r requirements.txt来把所有Python包依赖都装好了。具体格式说明： <a href="https://pip.readthedocs.io/en/1.1/requirements.html">点这里</a>。</li></ol><p><strong>关于配置文件的使用方法</strong></p><p><strong>注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在docs/目录下。</strong></p><p>很多项目对配置文件的使用做法是:</p><ol><li>配置文件写在一个或多个python文件中，比如此处的conf.py。</li><li>项目中哪个模块用到这个配置文件就直接通过import conf这种形式来在代码中使用配置。</li></ol><p>这种做法我不太赞同:</p><ol><li>这让单元测试变得困难（因为模块内部依赖了外部配置）</li><li>另一方面配置文件作为用户控制程序的接口，应当可以由用户自由指定该文件的路径。</li><li>程序组件可复用性太差，因为这种贯穿所有模块的代码硬编码方式，使得大部分模块都依赖conf.py这个文件。</li></ol><p>所以，我认为配置的使用，更好的方式是，</p><ol><li>模块的配置都是可以灵活配置的，不受外部配置文件的影响。</li><li>程序的配置也是可以灵活控制的。</li></ol><p>能够佐证这个思想的是，用过nginx和mysql的同学都知道，nginx、mysql这些程序都可以自由的指定用户配置。</p><p>所以，不应当在代码中直接import conf来使用配置文件。上面目录结构中的conf.py，是给出的一个配置样例，不是在写死在程序中直接引用的配置文件。可以通过给main.py启动参数指定配置路径的方式来让程序读取配置内容。当然，这里的conf.py你可以换个类似的名字，比如settings.py。或者你也可以使用其他格式的内容来编写配置文件，比如settings.yaml之类的。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=29950497&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Python从入门到放弃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python从入门到放弃（4）-- Python基础4</title>
      <link href="/2017/05/24/17-05-24/"/>
      <url>/2017/05/24/17-05-24/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><ol><li>函数基本语法及特性</li><li>参数与局部变量</li><li>返回值</li><li>嵌套函数</li><li>递归</li><li>匿名函数</li><li>函数式编程介绍</li><li>高阶函数</li><li>内置函数</li></ol></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="函数基本语法及特性"><a href="#函数基本语法及特性" class="headerlink" title="函数基本语法及特性"></a>函数基本语法及特性</h2><p><strong>背景提要</strong><br>现在老板让你写一个监控程序，监控服务器的系统状况，当cpu＼memory＼disk等指标的使用量超过阀值时即发邮件报警，你掏空了所有的知识量，写出了以下代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">while True：</span><br><span class="line">    if cpu利用率 &gt; 90%:</span><br><span class="line">        #发送邮件提醒</span><br><span class="line">        连接邮箱服务器</span><br><span class="line">        发送邮件</span><br><span class="line">        关闭连接</span><br><span class="line">     </span><br><span class="line">    if 硬盘使用空间 &gt; 90%:</span><br><span class="line">        #发送邮件提醒</span><br><span class="line">        连接邮箱服务器</span><br><span class="line">        发送邮件</span><br><span class="line">        关闭连接</span><br><span class="line">     </span><br><span class="line">    if 内存占用 &gt; 80%:</span><br><span class="line">        #发送邮件提醒</span><br><span class="line">        连接邮箱服务器</span><br><span class="line">        发送邮件</span><br><span class="line">        关闭连接</span><br></pre></td></tr></table></figure><br>上面的代码实现了功能，但即使是邻居老王也看出了端倪，老王亲切的摸了下你家儿子的脸蛋，说，你这个重复代码太多了，每次报警都要重写一段发邮件的代码，太low了，这样干存在2个问题：</p><ul><li>代码重复过多，一个劲的copy and paste不符合高端程序员的气质</li><li>如果日后需要修改发邮件的这段代码，比如加入群发功能，那你就需要在所有用到这段代码的地方都修改一遍</li></ul><p>你觉得老王说的对，你也不想写重复代码，但又不知道怎么搞，老王好像看出了你的心思，此时他抱起你儿子，笑着说，其实很简单，只需要把重复的代码提取出来，放在一个公共的地方，起个名字，以后谁想用这段代码，就通过这个名字调用就行了，如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def 发送邮件(内容)</span><br><span class="line">    #发送邮件提醒</span><br><span class="line">    连接邮箱服务器</span><br><span class="line">    发送邮件</span><br><span class="line">    关闭连接</span><br><span class="line">     </span><br><span class="line">while True：</span><br><span class="line">     </span><br><span class="line">    if cpu利用率 &gt; 90%:</span><br><span class="line">        发送邮件(&#x27;CPU报警&#x27;)</span><br><span class="line">     </span><br><span class="line">    if 硬盘使用空间 &gt; 90%:</span><br><span class="line">        发送邮件(&#x27;硬盘报警&#x27;)</span><br><span class="line">     </span><br><span class="line">    if 内存占用 &gt; 80%:</span><br><span class="line">        发送邮件(&#x27;内存报警&#x27;)</span><br></pre></td></tr></table></figure></p><p><strong>函数是什么?</strong></p><p>函数一词来源于数学，但编程中的「函数」概念，与数学中的函数是有很大不同的，具体区别，我们后面会讲，编程中的函数在英文中也有很多不同的叫法。在BASIC中叫做subroutine(子过程或子程序)，在Pascal中叫做procedure(过程)和function，在C中只有function，在Java里面叫做method。</p><p><strong>定义: 函数是指将一组语句的集合通过一个名字(函数名)封装起来，要想执行这个函数，只需调用其函数名即可</strong><br><strong>特性:</strong></p><ul><li>减少重复代码</li><li>使程序变的可扩展</li><li>使程序变得易维护</li><li>语法定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def sayhi():#函数名</span><br><span class="line">    print(&quot;Hello, I&#x27;m nobody!&quot;)</span><br><span class="line"> </span><br><span class="line">sayhi() #调用函数</span><br></pre></td></tr></table></figure><p>可以带参数<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#下面这段代码</span><br><span class="line">a,b = 5,8</span><br><span class="line">c = a**b</span><br><span class="line">print(c)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#改成用函数写</span><br><span class="line">def calc(x,y):</span><br><span class="line">    res = x**y</span><br><span class="line">    return res #返回函数执行结果</span><br><span class="line"> </span><br><span class="line">c = calc(a,b) ＃结果赋值给c变量</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure></p><h2 id="函数参数与局部变量"><a href="#函数参数与局部变量" class="headerlink" title="函数参数与局部变量"></a>函数参数与局部变量</h2><p><strong>形参变量</strong>只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效。函数调用结束返回主调用函数后则不能再使用该形参变量</p><p><strong>实参</strong>可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使参数获得确定值</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>看下面代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def stu_register(name,age,country,course):</span><br><span class="line">    print(&quot;----注册学生信息------&quot;)</span><br><span class="line">    print(&quot;姓名:&quot;,name)</span><br><span class="line">    print(&quot;age:&quot;,age)</span><br><span class="line">    print(&quot;国籍:&quot;,country)</span><br><span class="line">    print(&quot;课程:&quot;,course)</span><br><span class="line"> </span><br><span class="line">stu_register(&quot;王山炮&quot;,22,&quot;CN&quot;,&quot;python_devops&quot;)</span><br><span class="line">stu_register(&quot;张叫春&quot;,21,&quot;CN&quot;,&quot;linux&quot;)</span><br><span class="line">stu_register(&quot;刘老根&quot;,25,&quot;CN&quot;,&quot;linux&quot;)</span><br></pre></td></tr></table></figure><br>发现 country 这个参数 基本都 是”CN”, 就像我们在网站上注册用户，像国籍这种信息，你不填写，默认就会是 中国， 这就是通过默认参数实现的，把country变成默认参数非常简单<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def stu_register(name,age,course,country=&quot;CN&quot;):</span><br></pre></td></tr></table></figure><br>这样，这个参数在调用时不指定，那默认就是CN，指定了的话，就用你指定的值。</p><blockquote><p>另外，你可能注意到了，在把country变成默认参数后，我同时把它的位置移到了最后面，为什么呢？　</p></blockquote><h3 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h3><p>正常情况下，给函数传参数要按顺序，不想按顺序就可以用关键参数，只需指定参数名即可，<strong>但记住一个要求就是，关键参数必须放在位置参数之后。</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu_register(age=22,name=&#x27;alex&#x27;,course=&quot;python&quot;,)</span><br></pre></td></tr></table></figure></p><h3 id="非固定参数"><a href="#非固定参数" class="headerlink" title="非固定参数"></a>非固定参数</h3><p>若你的函数在定义时不确定用户想传入多少个参数，就可以使用非固定参数<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def stu_register(name,age,*args): # *args 会把多传入的参数变成一个元组形式</span><br><span class="line">    print(name,age,args)</span><br><span class="line"> </span><br><span class="line">stu_register(&quot;Alex&quot;,22)</span><br><span class="line">#输出</span><br><span class="line">#Alex 22 () #后面这个()就是args,只是因为没传值,所以为空</span><br><span class="line"> </span><br><span class="line">stu_register(&quot;Jack&quot;,32,&quot;CN&quot;,&quot;Python&quot;)</span><br><span class="line">#输出</span><br><span class="line"># Jack 32 (&#x27;CN&#x27;, &#x27;Python&#x27;)</span><br></pre></td></tr></table></figure><br>还可以有一个**kwargs<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def stu_register(name,age,*args,**kwargs): # *kwargs 会把多传入的参数变成一个dict形式</span><br><span class="line">    print(name,age,args,kwargs)</span><br><span class="line"> </span><br><span class="line">stu_register(&quot;Alex&quot;,22)</span><br><span class="line">#输出</span><br><span class="line">#Alex 22 () &#123;&#125;#后面这个&#123;&#125;就是kwargs,只是因为没传值,所以为空</span><br><span class="line"> </span><br><span class="line">stu_register(&quot;Jack&quot;,32,&quot;CN&quot;,&quot;Python&quot;,sex=&quot;Male&quot;,province=&quot;ShanDong&quot;)</span><br><span class="line">#输出</span><br><span class="line"># Jack 32 (&#x27;CN&#x27;, &#x27;Python&#x27;) &#123;&#x27;province&#x27;: &#x27;ShanDong&#x27;, &#x27;sex&#x27;: &#x27;Male&#x27;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;Disnon&quot;</span><br><span class="line"> </span><br><span class="line">def change_name(name):</span><br><span class="line">    print(&quot;before change:&quot;,name)</span><br><span class="line">    name = &quot;Mike&quot;</span><br><span class="line">    print(&quot;after change&quot;, name)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">change_name(name)</span><br><span class="line"> </span><br><span class="line">print(&quot;在外面看看name改了么?&quot;,name)</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before change: Disnon</span><br><span class="line">after change Mike</span><br><span class="line">在外面看看name改了么? Disnon</span><br></pre></td></tr></table></figure></p><h3 id="全局与局部变量"><a href="#全局与局部变量" class="headerlink" title="全局与局部变量"></a>全局与局部变量</h3><p>在子程序中定义的变量称为局部变量，在程序的一开始定义的变量称为全局变量。<br>全局变量作用域是整个程序，局部变量作用域是定义该变量的子程序。<br>当全局变量与局部变量同名时：<br>在定义局部变量的子程序内，局部变量起作用；在其它地方全局变量起作用。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>要想获取函数的执行结果，就可以用return语句把结果返回<br>注意:</p><ol><li>函数在执行过程中只要遇到return语句，就会停止执行并返回结果，so 也可以理解为 return 语句代表着函数的结束</li><li>如果未在函数中指定return,那这个函数的返回值为None </li></ol><h2 id="嵌套函数-函数套函数"><a href="#嵌套函数-函数套函数" class="headerlink" title="嵌套函数(函数套函数)　"></a>嵌套函数(函数套函数)　</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;Dinson&quot;</span><br><span class="line"></span><br><span class="line">def change_name():</span><br><span class="line">    name = &quot;Dinson2&quot;</span><br><span class="line"></span><br><span class="line">    def change_name2():</span><br><span class="line">        name = &quot;Dinson3&quot;</span><br><span class="line">        print(&quot;第3层打印&quot;, name)</span><br><span class="line"></span><br><span class="line">    change_name2()  # 调用内层函数</span><br><span class="line">    print(&quot;第2层打印&quot;, name)</span><br><span class="line"></span><br><span class="line">change_name()</span><br><span class="line">print(&quot;最外层打印&quot;, name)</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第3层打印 Dinson3</span><br><span class="line">第2层打印 Dinson2</span><br><span class="line">最外层打印 Dinson</span><br></pre></td></tr></table></figure></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def calc(n):</span><br><span class="line">    print(n)</span><br><span class="line">    if int(n / 2) == 0:</span><br><span class="line">        return n</span><br><span class="line">    return calc(int(n / 2))</span><br><span class="line"></span><br><span class="line">calc(10)</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br>递归特性:</p><ol><li>必须有一个明确的结束条件</li><li>每次进入更深一层递归时，问题规模相比上次递归都应有所减少</li><li>递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）</li></ol><p><strong>递归函数实际应用案例，二分查找(要二分查找必须先排序)</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">data = [1, 3, 6, 7, 9, 12, 14, 16, 17, 18, 20, 21, 22, 23, 30, 32, 33, 35]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def binary_search(dataset, find_num):</span><br><span class="line">    print(dataset)</span><br><span class="line"></span><br><span class="line">    if len(dataset) &gt; 1:</span><br><span class="line">        mid = int(len(dataset) / 2)</span><br><span class="line">        if dataset[mid] == find_num:  # find it</span><br><span class="line">            print(&quot;找到数字&quot;, dataset[mid])</span><br><span class="line">        elif dataset[mid] &gt; find_num:  # 找的数在mid左面</span><br><span class="line">            print(&quot;\033[31;1m找的数在mid[%s]左面\033[0m&quot; % dataset[mid])</span><br><span class="line">            return binary_search(dataset[0:mid], find_num)</span><br><span class="line">        else:  # 找的数在mid右面</span><br><span class="line">            print(&quot;\033[32;1m找的数在mid[%s]右面\033[0m&quot; % dataset[mid])</span><br><span class="line">            return binary_search(dataset[mid + 1:], find_num)</span><br><span class="line">    else:</span><br><span class="line">        if dataset[0] == find_num:  # find it</span><br><span class="line">            print(&quot;找到数字啦&quot;, dataset[0])</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;没的分了,要找的数字[%s]不在列表里&quot; % find_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binary_search(data, 66)</span><br></pre></td></tr></table></figure></p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数就是不需要显式的指定函数<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#这段代码</span><br><span class="line">def calc(n):</span><br><span class="line">    return n**n</span><br><span class="line">print(calc(10))</span><br><span class="line"> </span><br><span class="line">#换成匿名函数</span><br><span class="line">calc = lambda n:n**n</span><br><span class="line">print(calc(10))</span><br></pre></td></tr></table></figure></p><blockquote><p>你也许会说，用上这个东西没感觉有毛方便呀， 。。。。呵呵，如果是这么用，确实没毛线改进，不过匿名函数主要是和其它函数搭配使用的呢，如下</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = map(lambda x:x**2,[1,5,7,4,8])</span><br><span class="line">for i in res:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">25</span><br><span class="line">49</span><br><span class="line">16</span><br><span class="line">64</span><br></pre></td></tr></table></figure></p><h2 id="函数式编程介绍"><a href="#函数式编程介绍" class="headerlink" title="函数式编程介绍　　"></a>函数式编程介绍　　</h2><p>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p><p><strong>函数式编程中的函数这个术语不是指计算机中的函数（实际上是Subroutine），而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。</strong></p><p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单说，”函数式编程”是一种”<a href="https://en.wikipedia.org/wiki/Programming_paradigm">编程范式</a>“（programming paradigm），也就是如何编写程序的方法论。</p><p>主要思想是把运算过程尽量写成一系列嵌套的函数调用。举例来说，现在有这样一个数学表达式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 + 2) * 3 - 4</span><br></pre></td></tr></table></figure><br>传统的过程式编程，可能这样写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1 + 2;</span><br><span class="line">var b = a * 3;</span><br><span class="line">var c = b - 4;</span><br></pre></td></tr></table></figure><br>函数式编程要求使用函数，我们可以把运算过程定义为不同的函数，然后写成下面这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result = subtract(multiply(add(1,2), 3), 4);</span><br></pre></td></tr></table></figure><br>这段代码再演进以下，可以变成这样<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(1,2).multiply(3).subtract(4)</span><br></pre></td></tr></table></figure><br>这基本就是自然语言的表达了。再看下面的代码，大家应该一眼就能明白它的意思吧：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">merge([1,2],[3,4]).sort().search(&quot;2&quot;)</span><br></pre></td></tr></table></figure><br>因此，函数式编程的代码更容易理解。<br>要想学好函数式编程，不要玩py,玩Erlang,Haskell, 好了，我只会这么多了。。。</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def add(x,y,f):</span><br><span class="line">    return f(x) + f(y)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">res = add(3,-6,abs)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure></p><h2 id="内置参数"><a href="#内置参数" class="headerlink" title="内置参数"></a>内置参数</h2><p><img src="http://dinson-blog.hdinson.cn/FoVID96Zc78HEbXOBomVPQ1yTYGN.png" alt=""><br>内置参数详解：<a href="https://docs.python.org/3/library/functions.html?highlight=built#ascii">https://docs.python.org/3/library/functions.html?highlight=built#ascii </a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#compile</span><br><span class="line">f = open(&quot;函数递归.py&quot;)</span><br><span class="line">data =compile(f.read(),&#x27;&#x27;,&#x27;exec&#x27;)</span><br><span class="line">exec(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#print</span><br><span class="line">msg = &quot;又回到最初的起点&quot;</span><br><span class="line">f = open(&quot;tofile&quot;,&quot;w&quot;)</span><br><span class="line">print(msg,&quot;记忆中你青涩的脸&quot;,sep=&quot;|&quot;,end=&quot;&quot;,file=f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># #slice</span><br><span class="line"># a = range(20)</span><br><span class="line"># pattern = slice(3,8,2)</span><br><span class="line"># for i in a[pattern]: #等于a[3:8:2]</span><br><span class="line">#     print(i)</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#memoryview</span><br><span class="line">#usage:</span><br><span class="line">#&gt;&gt;&gt; memoryview(b&#x27;abcd&#x27;)</span><br><span class="line">#&lt;memory at 0x104069648&gt;</span><br><span class="line">#在进行切片并赋值数据时，不需要重新copy原列表数据，可以直接映射原数据内存，</span><br><span class="line">import time</span><br><span class="line">for n in (100000, 200000, 300000, 400000):</span><br><span class="line">    data = b&#x27;x&#x27;*n</span><br><span class="line">    start = time.time()</span><br><span class="line">    b = data</span><br><span class="line">    while b:</span><br><span class="line">        b = b[1:]</span><br><span class="line">    print(&#x27;bytes&#x27;, n, time.time()-start)</span><br><span class="line"></span><br><span class="line">for n in (100000, 200000, 300000, 400000):</span><br><span class="line">    data = b&#x27;x&#x27;*n</span><br><span class="line">    start = time.time()</span><br><span class="line">    b = memoryview(data)</span><br><span class="line">    while b:</span><br><span class="line">        b = b[1:]</span><br><span class="line">    print(&#x27;memoryview&#x27;, n, time.time()-start)</span><br><span class="line"></span><br><span class="line">几个内置方法用法提醒</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=1559072&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Python从入门到放弃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2017 年最流行的 15 个数据科学 Python 库</title>
      <link href="/2017/05/23/17-05-23/"/>
      <url>/2017/05/23/17-05-23/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Python 近几年在数据科学行业获得了人们的极大青睐，各种资源也层出不穷。数据科学解决方案公司 ActiveWizards 近日根据他们自己的应用开发经验，总结了数据科学家和工程师将在 2017 年最常使用的 Python 库。</p></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="核心库"><a href="#核心库" class="headerlink" title="核心库"></a>核心库</h2><h3 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h3><p>地址：<a href="http://www.numpy.org">http://www.numpy.org</a></p><p>当使用 Python 开始处理科学任务时，不可避免地需要求助 Python 的 SciPy Stack，它是专门为 Python 中的科学计算而设计的软件的集合（不要与 SciPy 混淆，它只是这个 stack 的一部分，以及围绕这个 stack 的社区）。这个 stack 相当庞大，其中有十几个库，所以我们想聚焦在核心包上（特别是最重要的）。</p><p>NumPy（代表 Numerical Python）是构建科学计算 stack 的最基础的包。它为 Python 中的 n 维数组和矩阵的操作提供了大量有用的功能。该库还提供了 NumPy 数组类型的数学运算向量化，可以提升性能，从而加快执行速度。</p><h3 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h3><p>地址：<a href="https://www.scipy.org">https://www.scipy.org</a></p><p>SciPy 是一个工程和科学软件库。除此以外，你还要了解 SciPy Stack 和 SciPy 库之间的区别。SciPy 包含线性代数、优化、集成和统计的模块。SciPy 库的主要功能建立在 NumPy 的基础之上，因此它的数组大量使用了 NumPy。它通过其特定的子模块提供高效的数值例程操作，比如数值积分、优化和许多其他例程。SciPy 的所有子模块中的函数都有详细的文档，这也是一个优势。</p><h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h3><p>地址：<a href="http://pandas.pydata.org">http://pandas.pydata.org</a></p><p>Pandas 是一个 Python 包，旨在通过「标记（labeled）」和「关系（relational）」数据进行工作，简单直观。Pandas 是 data wrangling 的完美工具。它设计用于快速简单的数据操作、聚合和可视化。库中有两个主要的数据结构：</p><ul><li><p>Series：一维<br><img src="http://dinson-blog.hdinson.cn/FjqLL2zH_K3jEIDhObj_ZaKAnHFi.png" alt=""></p></li><li><p>Data Frames：二维<br><img src="http://dinson-blog.hdinson.cn/Fl-HvXsnXx8_txPMebEW0T5FVjXv.png" alt=""></p></li></ul><p>例如，当你要从这两种类型的结构中接收到一个新的「Dataframe」类型的数据时，你将通过传递一个「Series」来将一行添加到「Dataframe」中来接收这样的 Dataframe：<br><img src="http://dinson-blog.hdinson.cn/Fl-HvXsnXx8_txPMebEW0T5FVjXv.png" alt=""><br>这里只是一小撮你可以用 Pandas 做的事情：</p><ul><li>轻松删除并添加「Dataframe」中的列</li><li>将数据结构转换为「Dataframe」对象</li><li>处理丢失数据，表示为 NaN（Not a Number）</li><li>功能强大的分组</li></ul><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>地址：<a href="https://matplotlib.org">https://matplotlib.org</a></p><p>Matplotlib 是另一个 SciPy Stack 核心软件包和另一个 Python 库，专为轻松生成简单而强大的可视化而量身定制。它是一个顶尖的软件，使得 Python（在 NumPy、SciPy 和 Pandas 的帮助下）成为 MatLab 或 Mathematica 等科学工具的显著竞争对手。然而，这个库比较底层，这意味着你需要编写更多的代码才能达到高级的可视化效果，通常会比使用更高级工具付出更多努力，但总的来说值得一试。花一点力气，你就可以做到任何可视化：</p><ul><li>线图</li><li>散点图</li><li>条形图和直方图</li><li>饼状图</li><li>茎图</li><li>轮廓图</li><li>场图</li><li>频谱图<br>还有使用 Matplotlib 创建标签、网格、图例和许多其他格式化实体的功能。基本上，一切都是可定制的。</li></ul><p>该库支持不同的平台，并可使用不同的 GUI 工具套件来描述所得到的可视化。许多不同的 IDE（如 IPython）都支持 Matplotlib 的功能。</p><p>还有一些额外的库可以使可视化变得更加容易。<br><img src="http://dinson-blog.hdinson.cn/FgdV3nNPrPgsu2WSKIpYS452haom.png" alt=""></p><h3 id="Seaborn"><a href="#Seaborn" class="headerlink" title="Seaborn"></a>Seaborn</h3><p>地址：<a href="https://seaborn.pydata.org">https://seaborn.pydata.org</a></p><p>Seaborn 主要关注统计模型的可视化；这种可视化包括热度图（heat map），可以总结数据但也描绘总体分布。Seaborn 基于 Matplotlib，并高度依赖于它。<br><img src="http://dinson-blog.hdinson.cn/FqdaBaaD9bBZwQdlBAwPRJbyhC0c.png" alt=""></p><h3 id="Bokeh"><a href="#Bokeh" class="headerlink" title="Bokeh"></a>Bokeh</h3><p>地址：<a href="http://bokeh.pydata.org">http://bokeh.pydata.org</a></p><p>Bokeh 也是一个很好的可视化库，其目的是交互式可视化。与之前的库相反，这个库独立于 Matplotlib。正如我们已经提到的那样，Bokeh 的重点是交互性，它通过现代浏览器以数据驱动文档（D3.js）的风格呈现。<br><img src="http://dinson-blog.hdinson.cn/FiLhaLNjLyyHox6iCyYgqpKYiMTi.png" alt=""></p><h3 id="Plotly"><a href="#Plotly" class="headerlink" title="Plotly"></a>Plotly</h3><p>地址：<a href="https://plot.ly">https://plot.ly</a></p><p>最后谈谈 Plotly。它是一个基于 Web 的工具箱，用于构建可视化，将 API 呈现给某些编程语言（其中包括 Python）。在 plot.ly 网站上有一些强大的、开箱即用的图形。为了使用 Plotly，你需要设置你的 API 密钥。图形处理会放在服务器端，并在互联网上发布，但也有一种方法可以避免这么做。<br><img src="http://dinson-blog.hdinson.cn/Fi0NOy4lxMmqhhEPDLTJuANRMude.png" alt=""></p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="SciKit-Learn"><a href="#SciKit-Learn" class="headerlink" title="SciKit-Learn"></a>SciKit-Learn</h3><p>地址：<a href="http://scikit-learn.org">http://scikit-learn.org</a><br>Scikits 是 SciPy Stack 的附加软件包，专为特定功能（如图像处理和辅助机器学习）而设计。在后者方面，其中最突出的一个是 scikit-learn。该软件包构建于 SciPy 之上，并大量使用其数学操作。</p><p>scikit-learn 有一个简洁和一致的接口，可利用常见的机器学习算法，让我们可以简单地在生产中应用机器学习。该库结合了质量很好的代码和良好的文档，易于使用且有着非常高的性能，是使用 Python 进行机器学习的实际上的行业标准。</p><h2 id="深度学习：Keras-TensorFlow-Theano"><a href="#深度学习：Keras-TensorFlow-Theano" class="headerlink" title="深度学习：Keras / TensorFlow / Theano"></a>深度学习：Keras / TensorFlow / Theano</h2><blockquote><p>在深度学习方面，Python 中最突出和最方便的库之一是 Keras，它可以在 TensorFlow 或者 Theano 之上运行。让我们来看一下它们的一些细节。</p></blockquote><h3 id="Theano"><a href="#Theano" class="headerlink" title="Theano"></a>Theano</h3><p>地址：<a href="https://github.com/Theano">https://github.com/Theano</a></p><p>首先，让我们谈谈 Theano。Theano 是一个 Python 包，它定义了与 NumPy 类似的多维数组，以及数学运算和表达式。该库是经过编译的，使其在所有架构上能够高效运行。这个库最初由蒙特利尔大学机器学习组开发，主要是为了满足机器学习的需求。</p><p>要注意的是，Theano 与 NumPy 在底层的操作上紧密集成。该库还优化了 GPU 和 CPU 的使用，使数据密集型计算的性能更快。</p><p>效率和稳定性调整允许更精确的结果，即使是非常小的值也可以，例如，即使 x 很小，log(1+x) 也能得到很好的结果。</p><h3 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h3><p>地址：<a href="https://www.tensorflow.org">https://www.tensorflow.org</a><br><img src="http://dinson-blog.hdinson.cn/FlB55UPCqB09XPeWUVlGqzi24Gui.png" alt=""><br>TensorFlow 来自 Google 的开发人员，它是用于数据流图计算的开源库，专门为机器学习设计。它是为满足 Google 对训练神经网络的高要求而设计的，是基于神经网络的机器学习系统 DistBelief 的继任者。然而，TensorFlow 并不是谷歌的科学专用的——它也足以支持许多真实世界的应用。</p><p>TensorFlow 的关键特征是其多层节点系统，可以在大型数据集上快速训练人工神经网络。这为 Google 的语音识别和图像识别提供了支持。</p><h3 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h3><p>地址：<a href="https://keras.io">https://keras.io</a></p><p>最后，我们来看看 Keras。它是一个使用高层接口构建神经网络的开源库，它是用 Python 编写的。它简单易懂，具有高级可扩展性。它使用 Theano 或 TensorFlow 作为后端，但 Microsoft 现在已将 CNTK（Microsoft 的认知工具包）集成为新的后端。</p><p>其简约的设计旨在通过建立紧凑型系统进行快速和容易的实验。</p><p>Keras 极其容易上手，而且可以进行快速的原型设计。它完全使用 Python 编写的，所以本质上很高层。它是高度模块化和可扩展的。尽管它简单易用且面向高层，但 Keras 也非常深度和强大，足以用于严肃的建模。</p><p>Keras 的一般思想是基于神经网络的层，然后围绕层构建一切。数据以张量的形式进行准备，第一层负责输入张量，最后一层用于输出。模型构建于两者之间。</p><h2 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h2><h3 id="NLTK"><a href="#NLTK" class="headerlink" title="NLTK"></a>NLTK</h3><p>地址：<a href="http://www.nltk.org">http://www.nltk.org</a></p><p>这套库的名称是 Natural Language Toolkit（自然语言工具包），顾名思义，它可用于符号和统计自然语言处理的常见任务。NLTK 旨在促进 NLP 及相关领域（语言学、认知科学和人工智能等）的教学和研究，目前正被重点关注。</p><p>NLTK 允许许多操作，例如文本标记、分类和 tokenizing、命名实体识别、建立语语料库树（揭示句子间和句子内的依存性）、词干提取、语义推理。所有的构建块都可以为不同的任务构建复杂的研究系统，例如情绪分析、自动摘要。</p><h3 id="Gensim"><a href="#Gensim" class="headerlink" title="Gensim"></a>Gensim</h3><p>地址：<a href="http://radimrehurek.com/gensim">http://radimrehurek.com/gensim</a></p><p>这是一个用于 Python 的开源库，实现了用于向量空间建模和主题建模的工具。这个库为大文本进行了有效的设计，而不仅仅可以处理内存中内容。其通过广泛使用 NumPy 数据结构和 SciPy 操作而实现了效率。它既高效又易于使用。</p><p>Gensim 的目标是可以应用原始的和非结构化的数字文本。Gensim 实现了诸如分层 Dirichlet 进程（HDP）、潜在语义分析（LSA）和潜在 Dirichlet 分配（LDA）等算法，还有 tf-idf、随机投影、word2vec 和 document2vec，以便于检查一组文档（通常称为语料库）中文本的重复模式。所有这些算法是无监督的——不需要任何参数，唯一的输入是语料库。</p><h2 id="数据挖掘与统计"><a href="#数据挖掘与统计" class="headerlink" title="数据挖掘与统计"></a>数据挖掘与统计</h2><h3 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h3><p>地址：<a href="https://scrapy.org">https://scrapy.org</a></p><p>Scrapy 是用于从网络检索结构化数据（如联系人信息或 URL）的爬虫程序（也称为 spider bots）的库。它是开源的，用 Python 编写。它最初是为 scraping 设计的，正如其名字所示的那样，但它现在已经发展成了一个完整的框架，可以从 API 收集数据，也可以用作通用的爬虫。</p><p>该库在接口设计上遵循著名的 Don』t Repeat Yourself 原则——提醒用户编写通用的可复用的代码，因此可以用来开发和扩展大型爬虫。</p><p>Scrapy 的架构围绕 Spider 类构建，该类包含了一套爬虫所遵循的指令。</p><h3 id="Statsmodels"><a href="#Statsmodels" class="headerlink" title="Statsmodels"></a>Statsmodels</h3><p>地址：<a href="http://www.statsmodels.org">http://www.statsmodels.org</a></p><p>statsmodels 是一个用于 Python 的库，正如你可能从名称中猜出的那样，其让用户能够通过使用各种统计模型估计方法以及执行统计断言和分析来进行数据探索。</p><p>许多有用的特征是描述性的，并可通过使用线性回归模型、广义线性模型、离散选择模型、稳健的线性模型、时序分析模型、各种估计器进行统计。</p><p>该库还提供了广泛的绘图函数，专门用于统计分析和调整使用大数据统计数据的良好性能。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这个列表中的库被很多数据科学家和工程师认为是最顶级的，了解和熟悉它们是很有价值的。这里有这些库在 GitHub 上活动的详细统计：<br><img src="http://dinson-blog.hdinson.cn/Fih19SF7s1rRHz8_SY05D8WI5ni0.png" alt=""><br>当然，这并不是一份完全详尽的列表，还有其它很多值得关注的库、工具包和框架。比如说用于特定任务的 SciKit 包，其中包括用于图像的 SciKit-Image。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=3435378&auto=1&height=66"></iframe> ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python从入门到放弃（3）-- Python基础3</title>
      <link href="/2017/05/22/17-05-22/"/>
      <url>/2017/05/22/17-05-22/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><ol><li>集合操作</li><li>文件操作</li><li>字符编码与转码</li></ol></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>集合是一个无序的，不重复的数据组合，它的主要作用如下：</p><ul><li>去重，把一个列表变成集合，就自动去重了,天生去重</li><li>关系测试，测试两组数据之前的交集、差集、并集等关系</li></ul><p><strong>创建</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">s = set([5, 2, 1, 4, 3])</span><br><span class="line"></span><br><span class="line"># 增</span><br><span class="line"># s.add(&quot;Dinson&quot;)  # &#123;1, 2, 3, 4, 5, &#x27;Dinson&#x27;&#125;</span><br><span class="line"># s.update([&quot;Disnon&quot;, 4, 6])  # &#123;1, 2, 3, 4, 5, &#x27;Disnon&#x27;, 6&#125;</span><br><span class="line"></span><br><span class="line"># 删</span><br><span class="line"># s.remove(1)  # &#123;2, 3, 4, 5&#125; 删除一项</span><br><span class="line"># s.discard(8)  # &#123;1, 2, 3, 4, 5&#125; 有则删，不会崩溃</span><br><span class="line"># s.pop();  # &#123;2, 3, 4, 5&#125; 随机删除一项</span><br><span class="line"></span><br><span class="line"># 查</span><br><span class="line"># print(4 in s)  # True</span><br><span class="line"># print(4 not in s)  # False</span><br><span class="line"></span><br><span class="line"># 其他</span><br><span class="line"># print(len(s))  # 5 集合长度</span><br><span class="line"># print(s.clear())  # None</span><br><span class="line"># print(s.copy())  # 浅copy</span><br><span class="line"></span><br><span class="line">s1 = set([1, 2])</span><br><span class="line">s2 = set([2, 3])</span><br><span class="line"></span><br><span class="line"># 交集</span><br><span class="line"># print(s1 &amp; s2)  # &#123;2&#125;</span><br><span class="line"># print(s1.intersection(s2))  # &#123;2&#125;</span><br><span class="line"></span><br><span class="line"># 并集</span><br><span class="line"># print(s1 | s2)  # &#123;1, 2, 3&#125;</span><br><span class="line"># print(s1.union(s2))  # &#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line"># 差集</span><br><span class="line"># print(s1 - s2)  # &#123;1&#125;</span><br><span class="line"># print(s1.difference(s2))  # &#123;1&#125;</span><br><span class="line"></span><br><span class="line"># 对称差集</span><br><span class="line"># print(s1 ^ s2)  # &#123;1, 3&#125;</span><br><span class="line"># print(s1.symmetric_difference(s2))  # &#123;1, 3&#125;</span><br><span class="line"></span><br><span class="line"># 两个集合是否不相交</span><br><span class="line"># print(s1.isdisjoint(s2))  # False</span><br><span class="line"></span><br><span class="line"># 判断子父集</span><br><span class="line"># print(s1.issubset(s2))  # False</span><br><span class="line"># print(s1.issuperset(s2))  # False</span><br></pre></td></tr></table></figure></p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>对文件操作流程</p><ol><li>打开文件，得到文件句柄并赋值给一个变量</li><li>通过句柄对文件进行操作</li><li>关闭文件 </li></ol><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作　　"></a>基本操作　　</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = open(&#x27;source_name&#x27;) #打开文件</span><br><span class="line">first_line = f.readline()</span><br><span class="line">print(&#x27;first line:&#x27;,first_line) #读一行</span><br><span class="line">print(&#x27;我是分隔线&#x27;.center(50,&#x27;-&#x27;))</span><br><span class="line">data = f.read()# 读取剩下的所有内容,文件大时不要用</span><br><span class="line">print(data) #打印文件</span><br><span class="line"> </span><br><span class="line">f.close() #关闭文件</span><br></pre></td></tr></table></figure><p><strong>打开文件的模式有：</strong></p><ul><li>r，只读模式（默认）。</li><li>w，只写模式。【不可读；不存在则创建；存在则删除内容；】</li><li>a，追加模式。【可读；   不存在则创建；存在则只追加内容；】</li></ul><p><strong>“+” 表示可以同时读写某个文件</strong></p><ul><li>r+，可读写文件。【可读；可写；可追加】</li><li>w+，写读</li><li>a+，同a</li></ul><p><strong>“U”表示在读取时，可以将 \r \n \r\n自动转换成 \n （与 r 或 r+ 模式同使用）</strong></p><ul><li>rU</li><li>r+U</li></ul><p><strong>“b”表示处理二进制文件（如：FTP发送上传ISO镜像文件，linux可忽略，windows处理二进制文件时需标注）</strong></p><ul><li>rb</li><li>wb</li><li>ab</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;lyrice&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line"># print(f.read(50))  # 读取，带参表示读取字符数</span><br><span class="line"># print(f.readline(50))  # 读取一行，带参表示读取字符数</span><br><span class="line"># print(f.readable())  # Ture or False 判断文件是否可读</span><br><span class="line"># f.write()  # 写数据</span><br><span class="line"># print(f.writelines())  # 写一行数据</span><br><span class="line"># print(f.writable())  # Ture or False 判断文件是否可写</span><br><span class="line"></span><br><span class="line"># print(f.name)  # lyrice    文件名</span><br><span class="line"># print(f.encoding)  # utf-8 文件格式</span><br><span class="line"># print(f.errors)</span><br><span class="line"># print(f.closed)  # Ture or False 查询文件是否关闭</span><br><span class="line"># print(f.buffer)  # &lt;_io.BufferedReader name=&#x27;lyrice&#x27;&gt;</span><br><span class="line"># print(f.newlines)</span><br><span class="line"># print(f.line_buffering)</span><br><span class="line"></span><br><span class="line"># print(f.flush())  # 强制刷新</span><br><span class="line"># print(f.close())  # 关闭文件</span><br><span class="line"># print(f.fileno())  # 3 操作系统IO在内存的编号</span><br><span class="line"># print(f.isatty())  # 是否是终端设备(打印机之类)</span><br><span class="line"># print(f.tell())  # 查询当前光标在第几个字符位置</span><br><span class="line"># print(f.seek(10))  # 光标移动到指定字符</span><br><span class="line"># print(f.seekable())  # 光标是否可移动(tty file,device file等返回False)</span><br><span class="line"># print(f.truncate(10))  # 截断，无视光标位置</span><br><span class="line"># print(f.detach())  # 有问题，会造成文件格式异常</span><br></pre></td></tr></table></figure><p><strong>with语句</strong><br>为了避免打开文件后忘记关闭，可以通过管理上下文，即：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;log&#x27;,&#x27;r&#x27;) as f:</span><br><span class="line">     </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><br>如此方式，当with代码块执行完毕时，内部会自动关闭并释放文件资源。<br>在Python 2.7 后，with又支持同时对多个文件的上下文进行管理，即：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;log1&#x27;) as obj1, open(&#x27;log2&#x27;) as obj2:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p><h2 id="字符编码与转码"><a href="#字符编码与转码" class="headerlink" title="字符编码与转码"></a>字符编码与转码</h2><p>详细文章:<br><a href="http://www.cnblogs.com/yuanchenqi/articles/5956943.html">http://www.cnblogs.com/yuanchenqi/articles/5956943.html</a><br><a href="http://www.diveintopython3.net/strings.html">http://www.diveintopython3.net/strings.html</a></p><p><strong>需知</strong></p><blockquote><p>1.在python2默认编码是ASCII, python3里默认是unicode</p><p>2.unicode 分为 utf-32(占4个字节),utf-16(占两个字节)，utf-8(占1-4个字节)， so utf-16就是现在最常用的unicode版本， 不过在文件里存的还是utf-8，因为utf8省空间</p><p>3.在py3中encode,在转码的同时还会把string 变成bytes类型，decode在解码的同时还会把bytes变回string</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/Fl1tIyvZx5Wxfyzqt82Z1rdGwdkO.png" alt=""></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=29950496&auto=1&height=66"></iframe>  ]]></content>
      
      
      <categories>
          
          <category> Python从入门到放弃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python从入门到放弃（2）-- Python基础2</title>
      <link href="/2017/05/21/17-05-21/"/>
      <url>/2017/05/21/17-05-21/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><ol><li>列表、元组操作</li><li>字符串操作</li><li>字典操作</li></ol></blockquote><span id="more"></span><!-- 这是　　缩进 --><h2 id="列表、元组操作"><a href="#列表、元组操作" class="headerlink" title="列表、元组操作"></a>列表、元组操作</h2><p><strong>列表</strong>是我们最以后最常用的数据类型之一，通过列表可以对数据实现最方便的存储、修改等操作<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">name = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;, &quot;赵六&quot;]</span><br><span class="line"></span><br><span class="line">print(name.clear())  # []</span><br><span class="line">print(name.count(&quot;赵六&quot;))  # 2</span><br><span class="line">print(name.index(&quot;赵六&quot;))  # 3</span><br><span class="line">print(name[0], name[2], name[-4])  # 张三 王五 李四</span><br><span class="line">print(name[:])  # [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;, &#x27;赵六&#x27;]</span><br><span class="line">print(name[0:2])  # [&#x27;张三&#x27;, &#x27;李四&#x27;]</span><br><span class="line"></span><br><span class="line">name.remove(&quot;李四&quot;)</span><br><span class="line">print(name)  # [&#x27;张三&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;, &#x27;赵六&#x27;]</span><br><span class="line"></span><br><span class="line">del name[2]</span><br><span class="line">print(name)  # [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;赵六&#x27;, &#x27;赵六&#x27;]</span><br><span class="line"></span><br><span class="line">name[4] = &quot;孙七&quot;</span><br><span class="line">print(name)  # [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;, &#x27;孙七&#x27;]</span><br><span class="line"></span><br><span class="line">name.insert(2, &quot;周八&quot;)</span><br><span class="line">print(name)  # [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;周八&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;, &#x27;赵六&#x27;]</span><br><span class="line"></span><br><span class="line">name.append(&quot;孙七&quot;)</span><br><span class="line">print(name)  # [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;, &#x27;孙七&#x27;]</span><br><span class="line"></span><br><span class="line">name.pop()</span><br><span class="line">print(name)  # [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;]</span><br><span class="line"></span><br><span class="line">name.pop(1)  # 李四</span><br><span class="line">print(name)  # [&#x27;张三&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;, &#x27;赵六&#x27;]</span><br><span class="line"></span><br><span class="line">name.remove(&quot;赵六&quot;)</span><br><span class="line">print(name)  # [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;]</span><br><span class="line"></span><br><span class="line">name.reverse();</span><br><span class="line">print(name)  # [&#x27;赵六&#x27;, &#x27;赵六&#x27;, &#x27;王五&#x27;, &#x27;李四&#x27;, &#x27;张三&#x27;]</span><br><span class="line"></span><br><span class="line">name2 = [&quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;]</span><br><span class="line">name2.sort();</span><br><span class="line">print(name2)  # [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br><span class="line"></span><br><span class="line">name2 = [&quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;]</span><br><span class="line">name.extend(name2)</span><br><span class="line">print(name)  # [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;, &#x27;赵六&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;e&#x27;, &#x27;c&#x27;]</span><br><span class="line"></span><br><span class="line"># 浅copy</span><br><span class="line">name1 = [&quot;a&quot;, &quot;b&quot;, [&quot;张三&quot;, &quot;李四&quot;], &quot;d&quot;, &quot;e&quot;]</span><br><span class="line">name2 = name.copy();</span><br><span class="line">name1[1] = &quot;f&quot;</span><br><span class="line">name1[2][0] = &quot;王五&quot;</span><br><span class="line">print(name1)  # [&#x27;a&#x27;, &#x27;f&#x27;, [&#x27;王五&#x27;, &#x27;李四&#x27;], &#x27;d&#x27;, &#x27;e&#x27;]</span><br><span class="line">print(name2)  # [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;王五&#x27;, &#x27;李四&#x27;], &#x27;d&#x27;, &#x27;e&#x27;]</span><br><span class="line"></span><br><span class="line"># 深copy</span><br><span class="line">import copy</span><br><span class="line">name1 = [&quot;a&quot;, &quot;b&quot;, [&quot;张三&quot;, &quot;李四&quot;], &quot;d&quot;, &quot;e&quot;]</span><br><span class="line">name2 = copy.deepcopy(name1)</span><br><span class="line">name1[1] = &quot;f&quot;</span><br><span class="line">name1[2][0] = &quot;王五&quot;</span><br><span class="line">print(name1)  # [&#x27;a&#x27;, &#x27;f&#x27;, [&#x27;王五&#x27;, &#x27;李四&#x27;], &#x27;d&#x27;, &#x27;e&#x27;]</span><br><span class="line">print(name2)  # [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;张三&#x27;, &#x27;李四&#x27;], &#x27;d&#x27;, &#x27;e&#x27;]</span><br><span class="line"></span><br><span class="line"># 遍历</span><br><span class="line">print(name[0:-1:2])  # [&#x27;张三&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;]</span><br><span class="line">print(name[::2])  # [&#x27;张三&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;]</span><br><span class="line">print(name[:])  # [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;, &#x27;赵六&#x27;]</span><br><span class="line">for i in name:</span><br><span class="line">    print(i)  # 张三李四王五赵六赵六</span><br></pre></td></tr></table></figure></p><p><strong>元组</strong><br>元组其实跟列表差不多，也是存一组数，只不是它一旦创建，便不能再修改，所以又叫只读列表<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = (&quot;alex&quot;,&quot;jack&quot;,&quot;eric&quot;)</span><br><span class="line">它只有2个方法，一个是count,一个是index，完毕。</span><br></pre></td></tr></table></figure></p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;My Name is Dinson&quot;</span><br><span class="line"></span><br><span class="line"># print(str.index(&quot;n&quot;))  # 13  索引字符 无该字符则报错</span><br><span class="line"># print(str.rindex(&quot;n&quot;))  # 16 从右边开始索引字符 无该字符则报错</span><br><span class="line"># print(str.find(&quot;y&quot;))  # 1 索引字符 无该字符则返回-1</span><br><span class="line"># print(str.rfind(&quot;n&quot;))  # 16 从右边开始索引字符 无该字符则返回-1</span><br><span class="line"># print(str.count(&quot;n&quot;))  # 2  字符出现的个数</span><br><span class="line"># print(&quot;dinson&quot;.capitalize())  # Dinson    首字母大写</span><br><span class="line"># print(str.center(24, &quot;-&quot;))  # ---My Name is Dinson----</span><br><span class="line"># print(str.ljust(24, &quot;-&quot;))   # My Name is Dinson-------</span><br><span class="line"># print(str.rjust(24, &quot;-&quot;))   # -------My Name is Dinson</span><br><span class="line"># print(str.zfill(24))        # 0000000My Name is Dinson</span><br><span class="line"># print(str.endswith(&quot;on&quot;))  # True 判断是否以该字符结束</span><br><span class="line"># print(str.startswith(&quot;my&quot;))  # False  判断是否以该字符开始</span><br><span class="line"># print(&quot;a\ta&quot;.expandtabs(10))  # a         a</span><br><span class="line"># print(&quot;_&quot;.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]))  # a_b_c_d</span><br><span class="line"># print(str.swapcase())  # mY nAME IS dINSON 大小写互换</span><br><span class="line"># print(str.lower())  # my name is dinson</span><br><span class="line"># print(str.upper())  # MY NAME IS DINSON</span><br><span class="line"># print(str.replace(&quot;Dinson&quot;, &quot;Mike&quot;))  # My Name is Mike</span><br><span class="line"># print(&quot;\n  Dinson  \n&quot;.strip())  # Dinson 去除左右空格和换行</span><br><span class="line"># print(&quot;\n  Dinson  \n&quot;.lstrip())  # Dinson  \n 去除左边空格和换行</span><br><span class="line"># print(&quot;\n  Dinson  \n&quot;.rstrip())  # \n  Dinson 去除右边空格和换行</span><br><span class="line"># print(&quot;aaaaa&quot;.split(&quot;a&quot;, 2))  # [&#x27;&#x27;, &#x27;&#x27;, &#x27;aaa&#x27;] 从左切割</span><br><span class="line"># print(&quot;aaaaa&quot;.rsplit(&quot;a&quot;, 2))  # [&#x27;aaa&#x27;, &#x27;&#x27;, &#x27;&#x27;] 从右切割</span><br><span class="line"># print(&quot;Dinson&quot;.partition(&quot;n&quot;))  # (&#x27;Di&#x27;, &#x27;n&#x27;, &#x27;son&#x27;) 切割成固定三个元组</span><br><span class="line"># print(&quot;Dinson&quot;.rpartition(&quot;n&quot;))  # (&#x27;Dinso&#x27;, &#x27;n&#x27;, &#x27;&#x27;)从右边切割成固定三个元组</span><br><span class="line"># print(&quot;a\nb&quot;.splitlines())  # [&#x27;a&#x27;, &#x27;b&#x27;] 根据不用系统换行符分割</span><br><span class="line"># print(&quot;my name is dinson&quot;.title())  # My Name Is Dinson</span><br><span class="line"># p1 = str.maketrans(&quot;abcdefghijklmnopqrstuvwxyz MND&quot;, &quot;9352401867peiwqcmzoshlmabv$*&amp;^&quot;)</span><br><span class="line"># p2 = str.maketrans(&quot;9352401867peiwqcmzoshlmabv$*&amp;^&quot;, &quot;abcdefghijklmnopqrstuvwxyz MND&quot;)</span><br><span class="line"># print(str.translate(p1))                # *b$&amp;9i4$6o$^6woqw</span><br><span class="line"># print(str.translate(p1).translate(p2))  # My Name is Dinson</span><br><span class="line"># print(&quot;name:&#123;name&#125;,age:&#123;age&#125;&quot;.format(name=&quot;Dinson&quot;, age=18))  # name:Dinson,age:18</span><br><span class="line"># print(&quot;name:&#123;name&#125;,age:&#123;age&#125;&quot;.format_map(&#123;&quot;name&quot;: &quot;Dinson&quot;, &quot;age&quot;: 18&#125;))  # name:Dinson,age:18</span><br><span class="line"></span><br><span class="line"># print(&quot;123&quot;.isdecimal())  # True 是否为阿拉伯数字(非负整数)</span><br><span class="line"># print(&quot;123&quot;.isalnum())  # True 是否为阿拉伯数字(非负整数)</span><br><span class="line"># print(&quot;123&quot;.isnumeric())  # True 是否为阿拉伯数字(非负整数)</span><br><span class="line"># print(&quot;123&quot;.isdigit())  # True 是否为阿拉伯数字(非负整数)</span><br><span class="line"># print(&quot;abcdABCD&quot;.isalpha())  # True 是否为字母</span><br><span class="line"># print(&quot;_1a中国&quot;.isidentifier())  # True 是否为合法标识符</span><br><span class="line"># print(&quot;abcd&quot;.islower())  # True 是否全部为小写</span><br><span class="line"># print(&quot;ABCD&quot;.isupper())  # True 是否全部为大写</span><br><span class="line"># print(&quot;My Name Is Dinson&quot;.istitle())  # True 是否为标题格式</span><br><span class="line"># print(&quot;\t&quot;.isspace())  # True 是否全部为空格</span><br><span class="line"># print(str.isprintable())  # True tty file,drive file不可打印</span><br></pre></td></tr></table></figure><h2 id="字典操作"><a href="#字典操作" class="headerlink" title="字典操作"></a>字典操作</h2><p>字典一种key - value 的数据类型，使用就像我们上学用的字典，通过笔划、字母来查对应页的详细内容。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cinfo = &#123;</span><br><span class="line">    &#x27;stu1101&#x27;: &quot;TengLan Wu&quot;,</span><br><span class="line">    &#x27;stu1102&#x27;: &quot;LongZe Luola&quot;,</span><br><span class="line">    &#x27;stu1103&#x27;: &quot;XiaoZe Maliya&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>字典的特性</strong></p><ul><li>dict是无序的</li><li>key必须是唯一的,so 天生去重</li></ul><p><strong>增加</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info[&quot;stu1104&quot;] = &quot;苍井空&quot;</span><br></pre></td></tr></table></figure></p><p><strong>修改</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info[&#x27;stu1101&#x27;] = &quot;武藤兰&quot;</span><br></pre></td></tr></table></figure></p><p><strong>删除</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">info.pop(&quot;stu1101&quot;) #标准删除姿势</span><br><span class="line">或者</span><br><span class="line">del info[&#x27;stu1103&#x27;] #换个姿势删除</span><br><span class="line">或者</span><br><span class="line">info.popitem() #随机删除</span><br></pre></td></tr></table></figure></p><p><strong>查找</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;stu1102&quot; in info #标准用法，返回Ture，False</span><br><span class="line">或者</span><br><span class="line">info.get(&quot;stu1102&quot;)  #获取，返回value</span><br><span class="line">或者</span><br><span class="line">info[&quot;stu1102&quot;] #同上，但是看下面</span><br><span class="line">info[&quot;stu1105&quot;] #如果一个key不存在，就报错，get不会，不存在只返回None</span><br></pre></td></tr></table></figure></p><p><strong>其它姿势</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#values</span><br><span class="line">&gt;&gt;&gt; info.values()</span><br><span class="line">dict_values([&#x27;LongZe Luola&#x27;, &#x27;XiaoZe Maliya&#x27;])</span><br><span class="line"></span><br><span class="line">#keys</span><br><span class="line">&gt;&gt;&gt; info.keys()</span><br><span class="line">dict_keys([&#x27;stu1102&#x27;, &#x27;stu1103&#x27;])</span><br><span class="line"></span><br><span class="line">#setdefault</span><br><span class="line">&gt;&gt;&gt; info.setdefault(&quot;stu1106&quot;,&quot;Alex&quot;)</span><br><span class="line">&#x27;Alex&#x27;</span><br><span class="line">&gt;&gt;&gt; info</span><br><span class="line">&#123;&#x27;stu1102&#x27;: &#x27;LongZe Luola&#x27;, &#x27;stu1103&#x27;: &#x27;XiaoZe Maliya&#x27;, &#x27;stu1106&#x27;: &#x27;Alex&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; info.setdefault(&quot;stu1102&quot;,&quot;龙泽萝拉&quot;)</span><br><span class="line">&#x27;LongZe Luola&#x27;</span><br><span class="line">&gt;&gt;&gt; info</span><br><span class="line">&#123;&#x27;stu1102&#x27;: &#x27;LongZe Luola&#x27;, &#x27;stu1103&#x27;: &#x27;XiaoZe Maliya&#x27;, &#x27;stu1106&#x27;: &#x27;Alex&#x27;&#125;</span><br><span class="line"></span><br><span class="line">#update </span><br><span class="line">&gt;&gt;&gt; info</span><br><span class="line">&#123;&#x27;stu1102&#x27;: &#x27;LongZe Luola&#x27;, &#x27;stu1103&#x27;: &#x27;XiaoZe Maliya&#x27;, &#x27;stu1106&#x27;: &#x27;Alex&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; b = &#123;1:2,3:4, &quot;stu1102&quot;:&quot;龙泽萝拉&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; info.update(b)</span><br><span class="line">&gt;&gt;&gt; info</span><br><span class="line">&#123;&#x27;stu1102&#x27;: &#x27;龙泽萝拉&#x27;, 1: 2, 3: 4, &#x27;stu1103&#x27;: &#x27;XiaoZe Maliya&#x27;, &#x27;stu1106&#x27;: &#x27;Alex&#x27;&#125;</span><br><span class="line"></span><br><span class="line">#items</span><br><span class="line">info.items()</span><br><span class="line">dict_items([(&#x27;stu1102&#x27;, &#x27;龙泽萝拉&#x27;), (1, 2), (3, 4), (&#x27;stu1103&#x27;, &#x27;XiaoZe Maliya&#x27;), (&#x27;stu1106&#x27;, &#x27;Alex&#x27;)])</span><br><span class="line"></span><br><span class="line">#通过一个列表生成默认dict,有个没办法解释的坑，少用吧这个</span><br><span class="line">&gt;&gt;&gt; dict.fromkeys([1,2,3],&#x27;testd&#x27;)</span><br><span class="line">&#123;1: &#x27;testd&#x27;, 2: &#x27;testd&#x27;, 3: &#x27;testd&#x27;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>循环dict</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#方法1</span><br><span class="line">for key in info:</span><br><span class="line">    print(key,info[key])</span><br><span class="line"></span><br><span class="line">#方法2</span><br><span class="line">for k,v in info.items(): #会先把dict转成list,数据里大时莫用</span><br><span class="line">    print(k,v)</span><br></pre></td></tr></table></figure></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=26372969&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Python从入门到放弃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python从入门到放弃（1）-- Python基础1</title>
      <link href="/2017/05/20/17-05-20/"/>
      <url>/2017/05/20/17-05-20/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><ol><li>Python介绍</li><li>发展史</li><li>Python 2 or 3?</li><li>安装</li><li>Hello World程序</li><li>变量</li><li>用户输入</li><li>模块初识</li><li>.pyc是个什么鬼？</li><li>数据类型初识</li><li>数据运算</li><li>表达式if …else语句</li><li>表达式for 循环</li><li>break and continue </li><li>表达式while 循环</li><li>一切皆对象</li></ol></blockquote><span id="more"></span><h2 id="Python介绍"><a href="#Python介绍" class="headerlink" title="Python介绍"></a>Python介绍</h2><p>python的创始人为吉多·范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。  </p><p>最新的TIOBE排行榜，Python赶超PHP占据第四， Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。<br><img src="http://dinson-blog.hdinson.cn/Fjyi1qC0MKR3BoyQygGOvVu4fqxk.png" alt=""></p><p>由上图可见，Python整体呈上升趋势，反映出Python应用越来越广泛并且也逐渐得到业内的认可！！！</p><p>Python可以应用于众多领域，如：数据分析、组件集成、网络服务、图像处理、数值计算和科学计算等众多领域。目前业内几乎所有大中型互联网企业都在使用Python，如：Youtube、Dropbox、BT、Quora（中国知乎）、豆瓣、知乎、Google、Yahoo!、Facebook、NASA、百度、腾讯、汽车之家、美团等。</p><p><strong>目前Python主要应用领域：</strong></p><ul><li>云计算: 云计算最火的语言， 典型应用OpenStack</li><li>WEB开发: 众多优秀的WEB框架，众多大型网站均为Python开发，Youtube, Dropbox, 豆瓣。。。， 典型WEB框架有Django</li><li>科学运算、人工智能: 典型库NumPy, SciPy, Matplotlib, Enthought librarys,pandas</li><li>系统运维: 运维人员必备语言</li><li>金融：量化交易，金融分析，在金融工程领域，Python不但在用，且用的最多，而且重要性逐年提高。原因：作为动态语言的Python，语言结构清晰简单，库丰富，成熟稳定，科学计算和统计分析都很牛逼，生产效率远远高于c,c++,java,尤其擅长策略回测</li><li>图形GUI: PyQT, WxPython,TkInter</li></ul><p><strong>Python在一些公司的应用： </strong></p><ul><li>谷歌：Google App Engine 、code.google.com 、Google earth 、谷歌爬虫、- - - Google广告等项目都在大量使用Python开发</li><li>CIA: 美国中情局网站就是用Python开发的</li><li>NASA: 美国航天局(NASA)大量使用Python进行数据分析和运算</li><li>YouTube:世界上最大的视频网站YouTube就是用Python开发的</li><li>Dropbox:美国最大的在线云存储网站，全部用Python实现，每天网站处理10亿个文件的上传和下载</li><li>Instagram:美国最大的图片分享社交网站，每天超过3千万张照片被分享，全部用python开发</li><li>Facebook:大量的基础库均通过Python实现的</li><li>Redhat: 世界上最流行的Linux发行版本中的yum包管理工具就是用python开发的</li><li>豆瓣: 公司几乎所有的业务均是通过Python开发的</li><li>知乎: 国内最大的问答社区，通过Python开发(国外Quora)</li><li>春雨医生：国内知名的在线医疗网站是用Python开发的</li><li>除上面之外，还有搜狐、金山、腾讯、盛大、网易、百度、阿里、淘宝 、土豆、新浪、果壳等公司都在使用Python完成各种各样的任务。 </li></ul><h3 id="Python-是一门什么样的语言？"><a href="#Python-是一门什么样的语言？" class="headerlink" title="Python 是一门什么样的语言？"></a>Python 是一门什么样的语言？</h3><blockquote><p>编程语言主要从以下几个角度为进行分类，编译型和解释型、静态语言和动态语言、强类型定义语言和弱类型定义语言，每个分类代表什么意思呢，我们一起来看一下。</p></blockquote><p><strong>编译和解释的区别是什么？</strong></p><p><strong>编译器</strong>是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快;<br>而<strong>解释器</strong>则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的. </p><p>这是因为计算机不能直接认识并执行我们写的语句,它只能认识机器语言(是二进制的形式)<br><img src="http://dinson-blog.hdinson.cn/FnLlYURhDBaW4cpWv38KuQ55fJZX.png" alt=""></p><p><img src="http://dinson-blog.hdinson.cn/Ft9VR7pT0oVd2ahshLFUppbkNkzW.png" alt=""></p><p><strong>编译型vs解释型</strong><br>编译型<br>优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。<br>缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</p><p>解释型<br>优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。<br>缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。</p><p>一、<strong>低级语言与高级语言</strong></p><blockquote><p>最初的计算机程序都是用0和1的序列表示的，程序员直接使用的是机器指令，无需翻译，从纸带打孔输入即可执行得到结果。后来为了方便记忆，就将用0、1序列表示的机器指令都用符号助记，这些与机器指令一一对应的助记符就成了汇编指令，从而诞生了汇编语言。无论是机器指令还是汇编指令都是面向机器的，统称为低级语言。因为是针对特定机器的机器指令的助记符，所以汇编语言是无法独立于机器(特定的CPU体系结构)的。但汇编语言也是要经过翻译成机器指令才能执行的，所以也有将运行在一种机器上的汇编语言翻译成运行在另一种机器上的机器指令的方法，那就是交叉汇编技术。</p><p>高级语言是从人类的逻辑思维角度出发的计算机语言，抽象程度大大提高，需要经过编译成特定机器上的目标代码才能执行，一条高级语言的语句往往需要若干条机器指令来完成。高级语言独立于机器的特性是靠编译器为不同机器生成不同的目标代码(或机器指令)来实现的。那具体的说，要将高级语言编译到什么程度呢，这又跟编译的技术有关了，既可以编译成直接可执行的目标代码，也可以编译成一种中间表示，然后拿到不同的机器和系统上去执行，这种情况通常又需要支撑环境，比如解释器或虚拟机的支持，Java程序编译成bytecode，再由不同平台上的虚拟机执行就是很好的例子。所以，说高级语言不依赖于机器，是指在不同的机器或平台上高级语言的程序本身不变，而通过编译器编译得到的目标代码去适应不同的机器。从这个意义上来说，通过交叉汇编，一些汇编程序也可以获得不同机器之间的可移植性，但这种途径获得的移植性远远不如高级语言来的方便和实用性大。</p></blockquote><p>二、<strong>编译与解释</strong></p><blockquote><p>编译是将源程序翻译成可执行的目标代码，翻译与执行是分开的；而解释是对源程序的翻译与执行一次性完成，不生成可存储的目标代码。这只是表象，二者背后的最大区别是：对解释执行而言，程序运行时的控制权在解释器而不在用户程序；对编译执行而言，运行时的控制权在用户程序。</p></blockquote><p>解释具有良好的动态特性和可移植性，比如在解释执行时可以动态改变变量的类型、对程序进行修改以及在程序中插入良好的调试诊断信息等，而将解释器移植到不同的系统上，则程序不用改动就可以在移植了解释器的系统上运行。同时解释器也有很大的缺点，比如执行效率低，占用空间大，因为不仅要给用户程序分配空间，解释器本身也占用了宝贵的系统资源。</p><p>编译器是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快;<br>而解释器则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的.</p><p>三、<strong>编译型和解释型</strong></p><blockquote><p>我们先看看编译型，其实它和汇编语言是一样的：也是有一个负责翻译的程序来对我们的源代码进行转换，生成相对应的可执行代码。这个过程说得专业一点，就称为编译（Compile），而负责编译的程序自然就称为编译器（Compiler）。如果我们写的程序代码都包含在一个源文件中，那么通常编译之后就会直接生成一个可执行文件，我们就可以直接运行了。但对于一个比较复杂的项目，为了方便管理，我们通常把代码分散在各个源文件中，作为不同的模块来组织。这时编译各个文件时就会生成目标文件（Object   file）而不是前面说的可执行文件。一般一个源文件的编译都会对应一个目标文件。这些目标文件里的内容基本上已经是可执行代码了，但由于只是整个项目的一部分，所以我们还不能直接运行。待所有的源文件的编译都大功告成，我们就可以最后把这些半成品的目标文件“打包”成一个可执行文件了，这个工作由另一个程序负责完成，由于此过程好像是把包含可执行代码的目标文件连接装配起来，所以又称为链接（Link），而负责链接的程序就叫……就叫链接程序（Linker）。链接程序除了链接目标文件外，可能还有各种资源，像图标文件啊、声音文件啊什么的，还要负责去除目标文件之间的冗余重复代码，等等，所以……也是挺累的。链接完成之后，一般就可以得到我们想要的可执行文件了。 </p><p>上面我们大概地介绍了编译型语言的特点，现在再看看解释型。噢，从字面上看，“编译”和“解释”的确都有“翻译”的意思，它们的区别则在于翻译的时机安排不大一样。打个比方：假如你打算阅读一本外文书，而你不知道这门外语，那么你可以找一名翻译，给他足够的时间让他从头到尾把整本书翻译好，然后把书的母语版交给你阅读；或者，你也立刻让这名翻译辅助你阅读，让他一句一句给你翻译，如果你想往回看某个章节，他也得重新给你翻译。 </p><p>两种方式，前者就相当于我们刚才所说的编译型：一次把所有的代码转换成机器语言，然后写成可执行文件；而后者就相当于我们要说的解释型：在程序运行的前一刻，还只有源程序而没有可执行程序；而程序每执行到源程序的某一条指令，则会有一个称之为解释程序的外壳程序将源代码转换成二进制代码以供执行，总言之，就是不断地解释、执行、解释、执行……所以，解释型程序是离不开解释程序的。像早期的BASIC就是一门经典的解释型语言，要执行BASIC程序，就得进入BASIC环境，然后才能加载程序源文件、运行。解释型程序中，由于程序总是以源代码的形式出现，因此只要有相应的解释器，移植几乎不成问题。编译型程序虽然源代码也可以移植，但前提是必须针对不同的系统分别进行编译，对于复杂的工程来说，的确是一件不小的时间消耗，况且很可能一些细节的地方还是要修改源代码。而且，解释型程序省却了编译的步骤，修改调试也非常方便，编辑完毕之后即可立即运行，不必像编译型程序一样每次进行小小改动都要耐心等待漫长的Compiling…Linking…这样的编译链接过程。不过凡事有利有弊，由于解释型程序是将编译的过程放到执行过程中，这就决定了解释型程序注定要比编译型慢上一大截，像几百倍的速度差距也是不足为奇的。 </p><p>编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object   Pascal（Delphi）、VB等基本都可视为编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如Java、JavaScript、VBScript、Perl、Python等等。 </p><p>但既然编译型与解释型各有优缺点又相互对立，所以一批新兴的语言都有把两者折衷起来的趋势，例如Java语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介于机器码和Java源代码之间的中介代码，运行的时候则由JVM（Java的虚拟机平台，可视为解释器）解释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以执行起来比“纯解释型”程序要快许多。而像VB6（或者以前版本）、C#这样的语言，虽然表面上看生成的是.exe可执行程序文件，但VB6编译之后实际生成的也是一种中介码，只不过编译器在前面安插了一段自动调用某个外部解释器的代码（该解释程序独立于用户编写的程序，存放于系统的某个DLL文件中，所有以VB6编译生成的可执行程序都要用到它），以解释执行实际的程序体。C#（以及其它.net的语言编译器）则是生成.net目标代码，实际执行时则由.net解释系统（就像JVM一样，也是一个虚拟机平台）进行执行。当然.net目标代码已经相当“低级”，比较接近机器语言了，所以仍将其视为编译语言，而且其可移植程度也没有Java号称的这么强大，Java号称是“一次编译，到处执行”，而.net则是“一次编码，到处编译”。呵呵，当然这些都是题外话了。总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。</p></blockquote><p>四、<strong>动态语言和静态语言</strong></p><blockquote><p>通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。</p><p>（1）动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。</p><p>（2）静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。</p></blockquote><p>五、<strong>强类型定义语言和弱类型定义语言</strong></p><blockquote><p>（1）强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。</p><p>（2）弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。</p><p>强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的！<br>例如：Python是动态语言，是强类型定义语言（类型安全的语言）; VBScript是动态语言，是弱类型定义语言（类型不安全的语言）; JAVA是静态语言，是强类型定义语言（类型安全的语言）。</p></blockquote><p>通过上面这些介绍，我们可以得出，<code>python是一门动态解释性的强类型定义语言</code>。那这些基因使成就了Python的哪些优缺点呢？我们继续往下看。</p><h3 id="Python的优缺点"><a href="#Python的优缺点" class="headerlink" title="Python的优缺点"></a>Python的优缺点</h3><p><strong>优点</strong></p><ol><li>Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。</li><li>开发效率非常高，Python有非常强大的第三方库，基本上你想通过计算机实现任何功能，Python官方库里都有相应的模块进行支持，直接下载调用后，在基础库的基础上再进行开发，大大降低开发周期，避免重复造轮子。</li><li>高级语言————当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节</li><li>可移植性————由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工 作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就几乎可以在市场上所有的系统平台上运行</li><li>可扩展性————如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。</li><li>可嵌入性————你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚本功能。</li></ol><p><strong>缺点</strong></p><ol><li>速度慢，Python 的运行速度相比C语言确实慢很多，跟JAVA相比也要慢一些，因此这也是很多所谓的大牛不屑于使用Python的主要原因，但其实这里所指的运行速度慢在大多数情况下用户是无法直接感知到的，必须借助测试工具才能体现出来，比如你用C运一个程序花了0.01s,用Python是0.1s,这样C语言直接比Python快了10倍,算是非常夸张了，但是你是无法直接通过肉眼感知的，因为一个正常人所能感知的时间最小单位是0.15-0.4s左右，哈哈。其实在大多数情况下Python已经完全可以满足你对程序速度的要求，除非你要写对速度要求极高的搜索引擎等，这种情况下，当然还是建议你用C去实现的。</li><li>代码不能加密，因为PYTHON是解释性语言，它的源码都是以名文形式存放的，不过我不认为这算是一个缺点，如果你的项目要求源代码必须是加密的，那你一开始就不应该用Python来去实现。</li><li>线程不能利用多CPU问题，这是Python被人诟病最多的一个缺点，GIL即全局解释器锁（Global Interpreter Lock），是计算机程序设计语言解释器用于同步线程的工具，使得任何时刻仅有一个线程在执行，Python的线程是操作系统的原生线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。一个python解释器进程内有一条主线程，以及多条用户程序的执行线程。即使在多核CPU平台上，由于GIL的存在，所以禁止多线程的并行执行。关于这个问题的折衷解决方法，我们在以后线程和进程章节里再进行详细探讨。</li></ol><p>当然，Python还有一些其它的小缺点，在这就不一一列举了，我想说的是，任何一门语言都不是完美的，都有擅长和不擅长做的事情，建议各位不要拿一个语言的劣势去跟另一个语言的优势来去比较，语言只是一个工具，是实现程序设计师思想的工具，就像我们之前中学学几何时，有的时候需要要圆规，有的时候需要用三角尺一样，拿相应的工具去做它最擅长的事才是正确的选择。之前很多人问我Shell和Python到底哪个好？我回答说Shell是个脚本语言，但Python不只是个脚本语言，能做的事情更多，然后又有钻牛角尖的人说完全没必要学Python, Python能做的事情Shell都可以做，只要你足够牛B,然后又举了用Shell可以写俄罗斯方块这样的游戏，对此我能说表达只能是，不要跟SB理论，SB会把你拉到跟他一样的高度，然后用充分的经验把你打倒。</p><h3 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h3><p>当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。</p><p>由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。</p><p><strong>CPython</strong><br>当我们从Python官方网站下载并安装好Python 2.7后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。</p><p>CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。</p><p><strong>IPython</strong><br>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。</p><p>CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。</p><p><strong>PyPy</strong><br>PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。</p><p>绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。</p><p><strong>Jython</strong><br>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p><p><strong>IronPython</strong><br>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</p><h2 id="Python发展史"><a href="#Python发展史" class="headerlink" title="Python发展史"></a>Python发展史</h2><ul><li>1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。</li><li>1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。</li><li>Granddaddy of Python web frameworks, Zope 1 was released in 1999</li><li>Python 1.0 - January 1994 增加了 <a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda</a>, <a href="https://en.wikipedia.org/wiki/Map_(higher-order_function">map</a>), <a href="https://en.wikipedia.org/wiki/Filter_(higher-order_function">filter</a>) and <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function">reduce</a>).</li><li>Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础</li><li>Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django 诞生</li><li>Python 2.5 - September 19, 2006</li><li>Python 2.6 - October 1, 2008</li><li>Python 2.7 - July 3, 2010</li><li>In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible</li><li>Python 3.0 - December 3, 2008</li><li>Python 3.1 - June 27, 2009</li><li>Python 3.2 - February 20, 2011</li><li>Python 3.3 - September 29, 2012</li><li>Python 3.4 - March 16, 2014</li><li>Python 3.5 - September 13, 2015</li><li>Python 3.6 - December 23, 2016</li></ul><h2 id="Python-2-or-3"><a href="#Python-2-or-3" class="headerlink" title="Python 2 or 3?"></a>Python 2 or 3?</h2><p><strong>In summary : Python 2.x is legacy, Python 3.x is the present and future of the language</strong></p><p>Python 3.0 was released in 2008. The final 2.x version 2.7 release came out in mid-2010, with a statement of extended support for this end-of-life release. The 2.x branch will see no new major releases after that. 3.x is under active development and has already seen over five years of stable releases, including version 3.3 in 2012, 3.4 in 2014, and 3.5 in 2015. This means that all recent standard library improvements, for example, are only available by default in Python 3.x.</p><p>Guido van Rossum (the original creator of the Python language) decided to clean up Python 2.x properly, with less regard for backwards compatibility than is the case for new releases in the 2.x range. The most drastic improvement is the better Unicode support (with all text strings being Unicode by default) as well as saner bytes/Unicode separation.</p><p>Besides, several aspects of the core language (such as print and exec being statements, integers using floor division) have been adjusted to be easier for newcomers to learn and to be more consistent with the rest of the language, and old cruft has been removed (for example, all classes are now new-style, “range()” returns a memory efficient iterable, not a list as in 2.x). </p><p><strong>py2与3的详细区别</strong><br><strong>PRINT IS A FUNCTION</strong><br>The statement has been replaced with a print() function, with keyword arguments to replace most of the special syntax of the old statement (PEP 3105). Examples:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Old: print &quot;The answer is&quot;, 2*2 New: print(&quot;The answer is&quot;, 2*2)</span><br><span class="line">Old: print x, # Trailing comma suppresses newline New: print(x, end=&quot; &quot;) # Appends a space instead of a newline</span><br><span class="line">Old: print # Prints a newline</span><br><span class="line">New: print() # You must call the function!</span><br><span class="line">Old: print &gt;&gt;sys.stderr, &quot;fatal error&quot; New: print(&quot;fatal error&quot;, file=sys.stderr)</span><br><span class="line">Old: print (x, y) # prints repr((x, y))</span><br><span class="line">New: print((x, y)) # Not the same as print(x, y)!</span><br></pre></td></tr></table></figure></p><p>You can also customize the separator between items, e.g.:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;There are &lt;&quot;, 2**32, &quot;&gt; possibilities!&quot;, sep=&quot;&quot;)</span><br></pre></td></tr></table></figure><br><strong>ALL IS UNICODE NOW<br>从此不再为讨厌的字符编码而烦恼</strong></p><p>还可以这样玩： (A,*REST,B)=RANGE(5)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;strong&gt;&gt;&gt;&gt; a,*rest,b = range(5)</span><br><span class="line">&gt;&gt;&gt; a,rest,b</span><br><span class="line">(0, [1, 2, 3], 4)</span><br><span class="line">&lt;/strong&gt;</span><br></pre></td></tr></table></figure></p><p>某些库改名了</p><div class="table-container"><table><thead><tr><th>Old Name</th><th>New Name</th></tr></thead><tbody><tr><td>_winreg</td><td>winreg</td></tr><tr><td>ConfigParser</td><td>configparser</td></tr><tr><td>copy_reg</td><td>copyreg</td></tr><tr><td>Queue</td><td>queue</td></tr><tr><td>SocketServer</td><td>socketserver</td></tr><tr><td>markupbase</td><td>_markupbase</td></tr><tr><td>repr</td><td>reprlib</td></tr><tr><td>test.test_support</td><td>test.support</td></tr></tbody></table></div><p>还有谁不支持PYTHON3?<br>One popular module that don’t yet support Python 3 is Twisted (for networking and other applications). Most actively maintained libraries have people working on 3.x support. For some libraries, it’s more of a priority than others: Twisted, for example, is mostly focused on production servers, where supporting older versions of Python is important, let alone supporting a new version that includes major changes to the language. (Twisted is a prime example of a major package where porting to 3.x is far from trivial ）</p><h2 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h2><p><strong>windows</strong></p><ol><li>下载安装包<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></li><li>安装</li><li>配置环境变量</li></ol><p><strong>linux、Mac</strong><br>无需安装，原装Python环境</p><p>ps：如果自带2.6，请更新至2.7</p><h2 id="Hello-World程序"><a href="#Hello-World程序" class="headerlink" title="Hello World程序"></a>Hello World程序</h2><p>创建一个文件叫hello.py,并输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello World!&quot;)</span><br></pre></td></tr></table></figure></p><p>然后执行命令:python hello.py ,输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p><p><strong>指定解释器</strong><br>那么就需要在 hello.py 文件的头部指定解释器，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br></pre></td></tr></table></figure></p><p><strong>指定字符编码</strong><br>那么就需要在 hello.py 文件的头部指定解释器，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>声明变量</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line"> </span><br><span class="line">name = &quot;Dinson&quot;</span><br></pre></td></tr></table></figure><br>上述代码声明了一个变量，变量名为： name，变量name的值为：”Dinson”　</p><p><strong>变量定义的规则</strong>：</p><ul><li>变量名只能是 字母、数字或下划线的任意组合</li><li>变量名的第一个字符不能是数字</li><li>以下关键字不能声明为变量名<br>[‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</li></ul><h2 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入　"></a>用户输入　</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#_*_coding:utf-8_*_</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#name = raw_input(&quot;What is your name?&quot;) #only on python 2.x</span><br><span class="line">name = input(&quot;What is your name?&quot;)</span><br><span class="line">print(&quot;Hello &quot; + name )</span><br></pre></td></tr></table></figure><p>输入密码时，如果想要不可见，需要利用getpass 模块中的 getpass方法，即：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">  </span><br><span class="line">import getpass</span><br><span class="line">  </span><br><span class="line"># 将用户输入的内容赋值给 name 变量</span><br><span class="line">pwd = getpass.getpass(&quot;请输入密码：&quot;)</span><br><span class="line">  </span><br><span class="line"># 打印输入的内容</span><br><span class="line">print(pwd)</span><br></pre></td></tr></table></figure></p><h2 id="模块初识"><a href="#模块初识" class="headerlink" title="模块初识　　"></a>模块初识　　</h2><p>Python的强大之处在于他有非常丰富和强大的标准库和第三方库，几乎你想实现的任何功能都有相应的Python库支持，以后的课程中会深入讲解常用到的各种库，现在，我们先来象征性的学2个简单的。</p><p><strong>sys</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"> </span><br><span class="line">import sys</span><br><span class="line"> </span><br><span class="line">print(sys.argv)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#输出</span><br><span class="line">$ python test.py helo world</span><br><span class="line">[&#x27;test.py&#x27;, &#x27;helo&#x27;, &#x27;world&#x27;]  #把执行脚本时传递的参数获取到了</span><br></pre></td></tr></table></figure></p><p><strong>os</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"> </span><br><span class="line">import os</span><br><span class="line"> </span><br><span class="line">os.system(&quot;df -h&quot;) #调用系统命令</span><br></pre></td></tr></table></figure></p><p><strong>完全结合一下</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import os,sys</span><br><span class="line"> </span><br><span class="line">os.system(&#x27;&#x27;.join(sys.argv[1:])) #把用户的输入的参数当作一条命令交给os.system来执行</span><br></pre></td></tr></table></figure></p><h2 id="pyc是个什么鬼？"><a href="#pyc是个什么鬼？" class="headerlink" title=".pyc是个什么鬼？"></a>.pyc是个什么鬼？</h2><p><strong>1. Python是一门解释型语言？</strong><br>我初学Python时，听到的关于Python的第一句话就是，Python是一门解释性语言，我就这样一直相信下去，直到发现了<em>.pyc文件的存在。如果是解释型语言，那么生成的</em>.pyc文件是什么呢？c应该是compiled的缩写才对啊！<br>为了防止其他学习Python的人也被这句话误解，那么我们就在文中来澄清下这个问题，并且把一些基础概念给理清。</p><p><strong>2. 解释型语言和编译型语言 </strong><br>计算机是不能够识别高级语言的，所以当我们运行一个高级语言程序的时候，就需要一个“翻译机”来从事把高级语言转变成计算机能读懂的机器语言的过程。这个过程分成两类，第一种是编译，第二种是解释。<br>编译型语言在程序执行之前，先会通过编译器对程序执行一个编译的过程，把程序转变成机器语言。运行时就不需要翻译，而直接执行就可以了。最典型的例子就是C语言。<br>解释型语言就没有这个编译的过程，而是在程序运行的时候，通过解释器对程序逐行作出解释，然后直接运行，最典型的例子是Ruby。<br>通过以上的例子，我们可以来总结一下解释型语言和编译型语言的优缺点，因为编译型语言在程序运行之前就已经对程序做出了“翻译”，所以在运行时就少掉了“翻译”的过程，所以效率比较高。但是我们也不能一概而论，一些解释型语言也可以通过解释器的优化来在对程序做出翻译时对整个程序做出优化，从而在效率上超过编译型语言。<br>此外，随着Java等基于虚拟机的语言的兴起，我们又不能把语言纯粹地分成解释型和编译型这两种。<br>用Java来举例，Java首先是通过编译器编译成字节码文件，然后在运行时通过解释器给解释成机器文件。所以我们说Java是一种先编译后解释的语言。</p><p><strong>3. Python到底是什么 </strong><br>其实Python和Java/C#一样，也是一门基于虚拟机的语言，我们先来从表面上简单地了解一下Python程序的运行过程吧。<br>当我们在命令行中输入python hello.py时，其实是激活了Python的“解释器”，告诉“解释器”：你要开始工作了。可是在“解释”之前，其实执行的第一项工作和Java一样，是编译。<br>熟悉Java的同学可以想一下我们在命令行中如何执行一个Java的程序：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac hello.java</span><br><span class="line">java hello</span><br></pre></td></tr></table></figure><br>只是我们在用Eclipse之类的IDE时，将这两部给融合成了一部而已。其实Python也一样，当我们执行python hello.py时，他也一样执行了这么一个过程，所以我们应该这样来描述Python，Python是一门先编译后解释的语言。</p><p><strong>4. 简述Python的运行过程</strong><br>在说这个问题之前，我们先来说两个概念，PyCodeObject和pyc文件。<br>我们在硬盘上看到的pyc自然不必多说，而其实PyCodeObject则是Python编译器真正编译成的结果。我们先简单知道就可以了，继续向下看。<br>当python程序运行时，编译的结果则是保存在位于内存中的PyCodeObject中，当Python程序运行结束时，Python解释器则将PyCodeObject写回到pyc文件中。<br>当python程序第二次运行时，首先程序会在硬盘中寻找pyc文件，如果找到，则直接载入，否则就重复上面的过程。<br>所以我们应该这样来定位PyCodeObject和pyc文件，我们说pyc文件其实是PyCodeObject的一种持久化保存方式。</p><h2 id="数据类型初识"><a href="#数据类型初识" class="headerlink" title="数据类型初识"></a>数据类型初识</h2><p><strong>1. 数字</strong></p><blockquote><p>2 是一个整数的例子。<br>长整数 不过是大一些的整数。<br>3.23和52.3E-4是浮点数的例子。E标记表示10的幂。在这里，52.3E-4表示52.3 * 10-4。<br>(-5+4j)和(2.3-4.6j)是复数的例子，其中-5,4为实数，j为虚数，数学中表示复数是什么？。</p></blockquote><p>bytes(字节)<br>　　Python 3最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Python 3不会以任意隐式的方式混用str和bytes，正是这使得两者的区分特别清晰。你不能拼接字符串和字节包，也无法在字节包里搜索字符串（反之亦然），也不能将字符串传入参数为字节包的函数（反之亦然）。<br>int（整型）<br>　　在32位机器上，整数的位数为32位，取值范围为-2<strong>31～2</strong>31-1，即-2147483648～2147483647<br>　　在64位系统上，整数的位数为64位，取值范围为-2<strong>63～2</strong>63-1，即-9223372036854775808～9223372036854775807<br>long（长整型）<br>　　跟C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。<br>　　注意，自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了。<br>float（浮点型）<br>　　浮点数用来处理实数，即带有小数的数字。类似于C语言中的double类型，占8个字节（64位），其中52位表示底，11位表示指数，剩下的一位表示符号。<br>complex（复数）<br>　　复数由实数部分和虚数部分组成，一般形式为x＋yj，其中的x是复数的实数部分，y是复数的虚数部分，这里的x和y都是实数。<br>注：Python中存在小数字池：-5 ～ 257</p><p><strong>2、布尔值</strong><br>　　真或假<br>　　1 或 0</p><p><strong>3、字符串</strong><br>　　“hello world”</p><p>　　万恶的字符串拼接：<br>　　python中的字符串在C语言中体现为是一个字符数组，每次创建字符串时候需要在内存中开辟一块连续的空，并且一旦需要修改字符串的话，就需要再次开辟空间，万恶的+号每出现一次就会在内从中重新开辟一块空间。</p><p>字符串格式化输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;Dinson&quot;</span><br><span class="line">print &quot;i am %s &quot; % name</span><br><span class="line">  </span><br><span class="line">#输出: i am Dinson</span><br></pre></td></tr></table></figure><br>PS: 字符串是 %s;整数 %d;浮点数%f</p><p>字符串常用功能：</p><ul><li>移除空白</li><li>分割</li><li>长度</li><li>索引</li><li>切片</li></ul><p><strong>4、列表</strong><br>创建列表：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name_list = [&#x27;dinson&#x27;, &#x27;nick&#x27;, &#x27;decy&#x27;]</span><br><span class="line">或</span><br><span class="line">name_list ＝ list([&#x27;dinson&#x27;, &#x27;nick&#x27;, &#x27;decy&#x27;])</span><br></pre></td></tr></table></figure><br>基本操作：</p><ul><li>索引</li><li>切片</li><li>追加</li><li>删除</li><li>长度</li><li>切片</li><li>循环</li><li>包含</li></ul><p><strong>5、元组(不可变列表)</strong><br>创建元组：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ages = (11, 22, 33, 44, 55)</span><br><span class="line">或</span><br><span class="line">ages = tuple((11, 22, 33, 44, 55))</span><br></pre></td></tr></table></figure></p><p><strong>6、字典（无序）</strong><br>创建字典：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;&quot;name&quot;: &quot;mr.wu&quot;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">或</span><br><span class="line">person = dict(&#123;&quot;name&quot;: &quot;mr.wu&quot;, &#x27;age&#x27;: 18&#125;)</span><br></pre></td></tr></table></figure><br>常用操作：</p><ul><li>索引</li><li>新增</li><li>删除</li><li>键、值、键值对</li><li>循环</li><li>长度</li></ul><h2 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算　"></a>数据运算　</h2><p>算数运算：<br><img src="http://dinson-blog.hdinson.cn/Fp-9vQiBnaADZDMJXDn2BWS4zeX9.png" alt=""><br>比较运算：<br><img src="http://dinson-blog.hdinson.cn/Fh7X_ex7ebXm16-WpR5vldok97ys.png" alt=""><br>赋值运算：<br><img src="http://dinson-blog.hdinson.cn/FqpWM8BtdMLD-0GW-hzGVoqMX4hx.png" alt=""><br>逻辑运算：<br><img src="http://dinson-blog.hdinson.cn/FjKfsi27q5BqYjyyqF0j9hgwJSvN.png" alt=""><br>成员运算：<br><img src="http://dinson-blog.hdinson.cn/Fg9nIiLObvszh1-8H8AH0NxktzS0.png" alt=""><br>身份运算：<br><img src="http://dinson-blog.hdinson.cn/FuYOArbG3tvwyhSUqFQIzOkflAgC.png" alt=""><br>位运算：<br><img src="http://dinson-blog.hdinson.cn/FnI2vXuNHCAzskrIi8nJDHYvY_iL.png" alt=""><br>运算符优先级：<br><img src="http://dinson-blog.hdinson.cn/Fq3y306q1Qss-ovsrdtRcGN_NEIu.png" alt=""><br>更多内容：<a href="http://www.runoob.com/python/python-operators.html">猛击这里</a></p><h2 id="表达式if-…-else"><a href="#表达式if-…-else" class="headerlink" title="表达式if … else"></a>表达式if … else</h2><p>场景一、用户登陆验证<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提示输入用户名和密码</span><br><span class="line">  </span><br><span class="line"># 验证用户名和密码</span><br><span class="line">#     如果错误，则输出用户名或密码错误</span><br><span class="line">#     如果成功，则输出 欢迎，XXX!</span><br><span class="line"> </span><br><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: encoding -*-</span><br><span class="line">  </span><br><span class="line">import getpass</span><br><span class="line">  </span><br><span class="line">name = raw_input(&#x27;请输入用户名：&#x27;)</span><br><span class="line">pwd = getpass.getpass(&#x27;请输入密码：&#x27;)</span><br><span class="line">  </span><br><span class="line">if name == &quot;dinson&quot; and pwd == &quot;cmd&quot;:</span><br><span class="line">    print(&quot;欢迎，dinson！&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;用户名和密码错误&quot;)</span><br></pre></td></tr></table></figure></p><p>场景二、猜年龄游戏</p><p>在程序里设定好你的年龄，然后启动程序让用户猜测，用户输入后，根据他的输入提示用户输入的是否正确，如果错误，提示是猜大了还是小了<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"> </span><br><span class="line">my_age = 28</span><br><span class="line">user_input = int(input(&quot;input your guess num:&quot;))</span><br><span class="line"> </span><br><span class="line">if user_input == my_age:</span><br><span class="line">    print(&quot;Congratulations, you got it !&quot;)</span><br><span class="line">elif user_input &lt; my_age:</span><br><span class="line">    print(&quot;Oops,think bigger!&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;think smaller!&quot;)</span><br></pre></td></tr></table></figure><br>外层变量，可以被内层代码使用<br>内层变量，不应被外层代码使用</p><h2 id="表达式for-loop"><a href="#表达式for-loop" class="headerlink" title="表达式for loop"></a>表达式for loop</h2><p>最简单的循环10次<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">__author__ = &#x27;Alex Li&#x27;</span><br><span class="line"> </span><br><span class="line">for i in range(10):</span><br><span class="line">    print(&quot;loop:&quot;, i )</span><br></pre></td></tr></table></figure></p><p>需求一：还是上面的程序，但是遇到小于5的循环次数就不走了，直接跳入下一次循环<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(10):</span><br><span class="line">    if i&lt;5:</span><br><span class="line">        continue #不往下走了,直接进入下一次loop</span><br><span class="line">    print(&quot;loop:&quot;, i )</span><br></pre></td></tr></table></figure><br>需求二：还是上面的程序，但是遇到大于5的循环次数就不走了，直接退出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(10):</span><br><span class="line">    if i&gt;5:</span><br><span class="line">        break #不往下走了,直接跳出整个loop</span><br><span class="line">    print(&quot;loop:&quot;, i )</span><br></pre></td></tr></table></figure></p><h2 id="while-loop"><a href="#while-loop" class="headerlink" title="while loop 　"></a>while loop 　</h2><p>有一种循环叫死循环，一经触发，就运行个天荒地老、海枯石烂。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = 0</span><br><span class="line">while True:</span><br><span class="line">    print(&quot;你是风儿我是沙,缠缠绵绵到天涯...&quot;,count)</span><br><span class="line">    count +=1</span><br></pre></td></tr></table></figure><br>其实除了时间，没有什么是永恒的，死loop还是少写为好　</p><p>上面的代码循环100次就退出吧<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">count = 0</span><br><span class="line">while True:</span><br><span class="line">    print(&quot;你是风儿我是沙,缠缠绵绵到天涯...&quot;,count)</span><br><span class="line">    count +=1</span><br><span class="line">    if count == 100:</span><br><span class="line">        print(&quot;去你妈的风和沙,你们这些脱了裤子是人,穿上裤子是鬼的臭男人..&quot;)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><br>回到上面for 循环的例子，如何实现让用户不断的猜年龄，但只给最多3次机会，再猜不对就退出程序。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"> </span><br><span class="line">my_age = 28</span><br><span class="line">count = 0</span><br><span class="line">while count &lt; 3:</span><br><span class="line">    user_input = int(input(&quot;input your guess num:&quot;))</span><br><span class="line"> </span><br><span class="line">    if user_input == my_age:</span><br><span class="line">        print(&quot;Congratulations, you got it !&quot;)</span><br><span class="line">        break</span><br><span class="line">    elif user_input &lt; my_age:</span><br><span class="line">        print(&quot;Oops,think bigger!&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;think smaller!&quot;)</span><br><span class="line">    count += 1 #每次loop 计数器+1</span><br><span class="line">else:</span><br><span class="line">    print(&quot;猜这么多次都不对,fuck off.&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h2><p>对于Python，一切事物都是对象，对象基于类创建<br><img src="http://dinson-blog.hdinson.cn/Fr8cO7DUYpkNySDcDJSBEpwNXbkc.png" alt=""><br>所以，以下这些值都是对象： “wupeiqi”、38、[‘北京’, ‘上海’, ‘深圳’]，并且是根据不同的类生成的对象。<br><img src="http://dinson-blog.hdinson.cn/Fpef1qFxifrxnJnoGBOim5EHN0Gb.png" alt=""></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=27713248&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Python从入门到放弃 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin学习资料</title>
      <link href="/2017/05/19/17-05-19/"/>
      <url>/2017/05/19/17-05-19/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Kotlin 成为 Android 官方支持的编程语言</p></blockquote><span id="more"></span><h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><p>首发的肯定是kotlin的官方github地址了：</p><blockquote><p><a href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></p></blockquote><p>github trending，会有很多的新新优质资源</p><blockquote><p><a href="https://github.com/trending/java">https://github.com/trending/java</a></p></blockquote><p>Readme中包含官方的tutorials、推荐的图书《Kotlin in Action》、《Kotlin for Android Developers》以及其他资源。</p><p>英文不太好的不要担心，有官方中文翻译站点：</p><blockquote><p><a href="https://www.kotlincn.net/docs/reference/">https://www.kotlincn.net/docs/reference/</a><br><a href="https://www.gitbook.com/book/hltj/kotlin-reference-chinese/details">https://www.gitbook.com/book/hltj/kotlin-reference-chinese/details</a></p></blockquote><h2 id="《Kotlin-for-android-developers》中文版翻译"><a href="#《Kotlin-for-android-developers》中文版翻译" class="headerlink" title="《Kotlin for android developers》中文版翻译"></a>《Kotlin for android developers》中文版翻译</h2><p>在线版阅读地址</p><blockquote><p><a href="https://wangjiegulu.gitbooks.io/kotlin-for-android-developers-zh/zhe_ben_shu_shi_he_ni_ma_ff1f.html">https://wangjiegulu.gitbooks.io/kotlin-for-android-developers-zh/zhe_ben_shu_shi_he_ni_ma_ff1f.html</a></p></blockquote><p>离线版PDF下载地址</p><blockquote><p><a href="https://www.gitbook.com/download/pdf/book/wangjiegulu/kotlin-for-android-developers-zh">https://www.gitbook.com/download/pdf/book/wangjiegulu/kotlin-for-android-developers-zh</a></p></blockquote><h2 id="张涛的开源实验室"><a href="#张涛的开源实验室" class="headerlink" title="张涛的开源实验室"></a>张涛的开源实验室</h2><p>之前在推送中推荐过张涛的博客，博客质量都很高，在很早的时候就开始编写Kotlin相关博客，此外还有很多比较新的知识~</p><blockquote><p><a href="https://kymjs.com/column/kotlin.html">https://kymjs.com/column/kotlin.html</a></p></blockquote><h2 id="大精-wing的地方酒馆"><a href="#大精-wing的地方酒馆" class="headerlink" title="大精-wing的地方酒馆"></a>大精-wing的地方酒馆</h2><p>让你的代码量减少3倍！使用kotlin开发Android系列~</p><blockquote><p><a href="http://androidwing.net/index.php/89">http://androidwing.net/index.php/89</a></p></blockquote><p>还有个Kotlin项目：</p><blockquote><p><a href="https://github.com/githubwing/GankClient-Kotlin">https://github.com/githubwing/GankClient-Kotlin</a></p></blockquote><h2 id="Kotlin-视频教程"><a href="#Kotlin-视频教程" class="headerlink" title="Kotlin 视频教程"></a>Kotlin 视频教程</h2><p>腾讯视频：</p><blockquote><p><a href="http://v.qq.com/boke/gplay/903446d6231d8612d198c58fb86eb4dc_t6d000101bd9lx1.html">http://v.qq.com/boke/gplay/903446d6231d8612d198c58fb86eb4dc_t6d000101bd9lx1.html</a></p></blockquote><p>百度云：</p><blockquote><p><a href="http://pan.baidu.com/s/1nvGYAfB">http://pan.baidu.com/s/1nvGYAfB</a></p></blockquote><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>一个用Kotlin写的简单漫画APP</p><blockquote><p><a href="https://github.com/wuapnjie/PoiShuhui-Kotlin">https://github.com/wuapnjie/PoiShuhui-Kotlin</a></p></blockquote><h2 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章"></a>其他文章</h2><p>为什么我要改用Kotlin-by:技术小黑屋</p><blockquote><p><a href="http://droidyue.com/blog/2017/05/18/why-do-i-turn-to-kotlin/">http://droidyue.com/blog/2017/05/18/why-do-i-turn-to-kotlin/</a></p></blockquote><p>Android开发必备知识：为什么说Kotlin值得一试-by:腾讯Bugly公众号<br><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=404087761&amp;idx=1&amp;sn=d80625ee52f860a7a2ed4c238d2151b6">https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=404087761&amp;idx=1&amp;sn=d80625ee52f860a7a2ed4c238d2151b6</a></p><p>使用Kotlin进行Android开发</p><blockquote><p><a href="http://ragnraok.github.io/using-kotlin-to-write-android-app.html">http://ragnraok.github.io/using-kotlin-to-write-android-app.html</a></p></blockquote><p>使用Kotlin在Android Studio上开发App-by:Blincheng</p><blockquote><p><a href="http://blog.csdn.net/qq_25867141/article/details/52875330">http://blog.csdn.net/qq_25867141/article/details/52875330</a></p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=26515317&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Kotlin从放弃到入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基本语法</title>
      <link href="/2017/05/18/17-05-18/"/>
      <url>/2017/05/18/17-05-18/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>如果你觉得Java 7是一个过期的语言，并决定找一个更现代的语言代替。恭喜你！就如你知道的，虽然Java 8已经发布了，它包含了很多我们期待的像现代语言中那样的改善，但是我们Android开发者还是被迫在使用Java 7.这是因为法律的问题。但是就算没有这个限制，并且新的Android设备从今天开始使用新的能理解Java8的VM，在当前的设备过期、几乎没有人使用它们之前我们也不能使用Java 8，所以恐怕我们不会很快等到这一天的到来。<br>但是并不是没有补救的方法。多亏使用了JVM，我们可以使用任何语言去编写Android应用，只要它能够编译成JVM能够认识的字节码就可以了。<br>正如你所想，有很多选择，比如Groovy，Scala，Clojure，当然还有Kotlin。通过实践，只有其中一些能够被考虑来作为替代品。<br>上述的每一种语言都有它的利弊，如果你还没有真正确定你该使用那种语言，我建议你可以去尝试一下它们。</p></blockquote><span id="more"></span><h2 id="类和函数"><a href="#类和函数" class="headerlink" title="类和函数"></a>类和函数</h2><p>Kotlin中的类遵循一个简单的结构。尽管与Java有一点细微的差别。你可以使用<a href="https://try.kotlinlang.org/">try.kotlinlang.org</a>在不需要一个真正的项目和不需要部署到机器的前提下来测试一些简单的代码范例。</p><h2 id="怎么定义一个类"><a href="#怎么定义一个类" class="headerlink" title="怎么定义一个类"></a>怎么定义一个类</h2><p>如果你想定义一个类，你只需要使用class关键字。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它有一个默认唯一的构造器。我们会在以后的课程中学习在特殊的情况下创建其它额外的构造器，但是请记住大部分情况下你只需要这个默认的构造器。你只需要在类名后面写上它的参数。如果这个类没有任何内容可以省略大括号：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String, surname: String)</span><br></pre></td></tr></table></figure></p><p>那么构造函数的函数体在哪呢？你可以写在init块中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String, surname: String) &#123;</span><br><span class="line">    init&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><p>默认任何类都是基础继承自Any（与java中的Object类似），但是我们可以继承其它类。所有的类默认都是不可继承的（final），所以我们只能继承那些明确声明open或者abstract的类：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open class Animal(name: String)</span><br><span class="line">class Person(name: String, surname: String) : Animal(name)</span><br></pre></td></tr></table></figure></p><p>当我们只有单个构造器时，我们需要在从父类继承下来的构造器中指定需要的参数。这是用来替换Java中的super调用的。</p><h2 id="函数-方法"><a href="#函数-方法" class="headerlink" title="函数(方法)"></a>函数(方法)</h2><p>函数（我们Java中的方法）可以使用<code>fun</code>关键字就可以定义:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你没有指定它的返回值，它就会返回<code>Unit</code>，与Java中的<code>void</code>类似，但是<code>Unit</code>是一个真正的对象。你当然也可以指定任何其它的返回类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun add(x: Int, y: Int) : Int &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>就想你在上面的例子中看到的那样，我在每句的最后没有使用分号。当然你也可以使用分号，分号不是必须的，而且不使用分号是一个不错的实践。当你这么做了，你会发现这节约了你很多时间。</p></blockquote><p>然而如果返回的结果可以使用一个表达式计算出来，你可以不使用括号而是使用等号：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun add(x: Int,y: Int) : Int = x + y</span><br></pre></td></tr></table></figure></p><h2 id="构造方法和函数参数"><a href="#构造方法和函数参数" class="headerlink" title="构造方法和函数参数"></a>构造方法和函数参数</h2><p>Kotlin中的参数与Java中有些不同。如你所见，我们先写参数的名字再写它的类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun add(x: Int, y: Int) : Int &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以给参数指定一个默认值使得它们变得可选，这是非常有帮助的。这里有一个例子，在Activity中创建了一个函数用来toast一段信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun toast(message: String, length: Int = Toast.LENGTH_SHORT) &#123;</span><br><span class="line">    Toast.makeText(this, message, length).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如你所见，第二个参数（length）指定了一个默认值。这意味着你调用的时候可以传入第二个值或者不传，这样可以避免你需要的重载函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toast(&quot;Hello&quot;)</span><br><span class="line">toast(&quot;Hello&quot;, Toast.LENGTH_LONG)</span><br></pre></td></tr></table></figure></p><p>这个与下面的Java代码是一样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void toast(String message)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void toast(String message, int length)&#123;</span><br><span class="line">    Toast.makeText(this, message, length).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这跟你想象的一样复杂。再看看这个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun niceToast(message: String,</span><br><span class="line">                tag: String = javaClass&lt;MainActivity&gt;().getSimpleName(),</span><br><span class="line">                length: Int = Toast.LENGTH_SHORT) &#123;</span><br><span class="line">    Toast.makeText(this, &quot;[$className] $message&quot;, length).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我增加了第三个默认值是类名的tag参数。如果在Java中总数开销会以几何增长。现在可以通过以下方式调用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toast(&quot;Hello&quot;)</span><br><span class="line">toast(&quot;Hello&quot;, &quot;MyTag&quot;)</span><br><span class="line">toast(&quot;Hello&quot;, &quot;MyTag&quot;, Toast.LENGTH_SHORT)</span><br></pre></td></tr></table></figure><br>而且甚至还有其它选择，因为你可以使用参数名字来调用，这表示你可以通过在值前写明参数名来传入你希望的参数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toast(message = &quot;Hello&quot;, length = Toast.LENGTH_SHORT)</span><br></pre></td></tr></table></figure></p><blockquote><p>你可以在String中直接使用模版表达式。它可以帮助你很简单地在静态值和变量的基础上编写复杂的String。在上面的例子中，我使用了”[$className] $message”。<br>如你所见，任何时候你使用一个<code>$</code>符号就可以插入一个表达式。如果这个表达式有一点复杂，你就需要使用一对大括号括起来：”Your name is ${user.name}”。</p></blockquote><h2 id="Layout的编写"><a href="#Layout的编写" class="headerlink" title="Layout的编写"></a>Layout的编写</h2><blockquote><p>以天气预报应用为例</p></blockquote><p>显示天气预报的列表我们使用<strong>RecyclerView</strong>，所以你需要在<strong>build.gradle</strong>中增加一个新的依赖：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;])</span><br><span class="line">    compile &quot;com.android.support:appcompat-v7:$support_version&quot; </span><br><span class="line">    compile &quot;com.android.support:recyclerview-v7:$support_version&quot; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，activity_main.xml如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">             android:layout_width=&quot;match_parent&quot;</span><br><span class="line">             android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">        android:id=&quot;@+id/forecast_list&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p><p>在<strong>Mainactivity.kt</strong>中删除掉之前用来测试的能正常运行的所有代码（现在应该会提示错误）。暂且我们使用老的<strong>findViewByid()</strong>的方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val forecastList = findViewById(R.id.forecast_list) as RecyclerView</span><br><span class="line">forecastList.layoutManager = LinearLayoutManager(this)</span><br></pre></td></tr></table></figure></p><p>如你所见，我们定义类一个变量并转型为RecyclerView。这里与Java有点不同，我们会在下一章分析这些不同之处。LayoutManager会通过属性的方式被设置，而不是通过setter，这个layout已经足够显示一个列表了。</p><blockquote><p><strong>对象实例化</strong></p><p>对象实例化也是与Java中有些不同。如你所见，我们去掉了new关键字。这时构造函数仍然会被调用，但是我们省略了宝贵的四个字符。LinearLayoutManager(this)创建了一个对象的实例。</p></blockquote><p>我们同样需要一个RecyclerView的<strong>Adapter</strong>。RecyclerView中所使用到的布局现在只需要一个TextView，我会手动去创建这个简单的文本列表。增加一个名为ForecastListAdapter.kt的Kotlin文件，包括如下代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ForecastListAdapter(val items: List&lt;String&gt;) :</span><br><span class="line">        RecyclerView.Adapter&lt;ForecastListAdapter.ViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder &#123;</span><br><span class="line">        return ViewHolder(TextView(parent.context))</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123;</span><br><span class="line">        holder.textView.text = items.[position]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getItemCount(): Int = items.size</span><br><span class="line"></span><br><span class="line">    class ViewHolder(val textView: TextView) : RecyclerView.ViewHolder(textView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>又是如此，我们可以像访问属性一样访问context和text。你可以保持以往那样操作（使用getters和setters）,但是你会得到一个编译器的警告。如果你还是倾向于Java中的使用方式，这个检查可以被关闭。但是一旦你使用上了这种属性调用的方式你就会爱上它，而且它也节省了额外的字符总量。</p><p>回到<strong>MainActivity</strong>，现在简单地创建一系列的String放入List中，然后使用创建分配Adapter实例。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private val items = listOf(</span><br><span class="line">    &quot;Mon 6/23 - Sunny - 31/17&quot;,</span><br><span class="line">    &quot;Tue 6/24 - Foggy - 21/8&quot;,</span><br><span class="line">    &quot;Wed 6/25 - Cloudy - 22/17&quot;,</span><br><span class="line">    &quot;Thurs 6/26 - Rainy - 18/11&quot;,</span><br><span class="line">    &quot;Fri 6/27 - Foggy - 21/10&quot;,</span><br><span class="line">    &quot;Sat 6/28 - TRAPPED IN WEATHERSTATION - 23/18&quot;,</span><br><span class="line">    &quot;Sun 6/29 - Sunny - 20/7&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    ...</span><br><span class="line">    val forecastList = findViewById(R.id.forecast_list) as RecyclerView</span><br><span class="line">    forecastList.layoutManager = LinearLayoutManager(this) </span><br><span class="line">    forecastList.adapter = ForecastListAdapter(items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>List的创建</p><p>尽管我会在后面来对Collection进行讲解，但是我现在仅仅简单地解释你可以通过使用一个函数listOf创建一个常量的List（很快我们就会讲到的immutable）。它接收一个任何类型的vararg（可变长的参数），它会自动推断出结果的类型。还有很多其它的函数可以选择，比如setOf，arrayListOf或者hashSetOf。</p></blockquote><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Kotlin从放弃到入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google I/O 2017</title>
      <link href="/2017/05/17/17-05-17/"/>
      <url>/2017/05/17/17-05-17/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>美国时间5月17日-19日，Google I/O 2017大会将于美国加利福尼亚州山景城的海岸线圆形剧场召开，下面一起看看此次I/O大会将会有哪些值得期待的看点</p></blockquote><span id="more"></span><h2 id="Google-Assistant"><a href="#Google-Assistant" class="headerlink" title="Google Assistant"></a>Google Assistant</h2><p><img src="http://dinson-blog.hdinson.cn/Fsle7cG5g1hAKRNZYOkMefIse-WC.png" alt=""><br>Google宣布其AI语音助手Google Assistant将推出iPhone版，并对其加入了文字输入、Google Lens图像输入，支持到更多设备和语言等新功能升级。<br><img src="http://dinson-blog.hdinson.cn/FgFBMsW0Ii9OrJomlWtFmBlU0viX.png" alt=""><br>Google Assistant将推出iPhone版，iPhone用户也能享受Google这个语音AI助手进行语音搜索、查看Gmail、Youtube和网页搜索等操作。<br>为了方便用户在不能使用语音输入情况下，Google Assistant加入了文字输入方式和通过新公布的Google Lens技术进行图像识别。<br><img src="http://dinson-blog.hdinson.cn/FmoSO2aQS5Z9wXtJVyRGDh_fN8ey.png" alt=""><br>Goolge还推出Assistant SDK给开发者，并联合大量硬件制造商，推出内置Google Assistant的设备，这些设备将标有Google Assistant Built-in。</p><h2 id="Google系统Android-O"><a href="#Google系统Android-O" class="headerlink" title="Google系统Android O"></a>Google系统Android O</h2><p>本次Google I/O 2017上最重要的发布，自然就是Android O了，迄今Android激活设备已经达到20亿部，包括了智能手机、手表、车载和TV等，早在两个月前Android O开发者阅览版便已经放出，现在Google正式介绍了Android O的新功能，包括流动性体验和关键功能改进两部分。<br><img src="http://dinson-blog.hdinson.cn/FgHrbLSOKKKP70RfLT1g1ytDc0T6.png" alt=""><br>Android O提供流动式体验（Fluid Experience），包括画中画分屏功能、在App图标中显示通知的通知点、更好用的网页自动填写、可自动识别文字中地址和电话的智能选择，Google还为新系统推出TensorFlow Lite智能AI学习系统，用于加强语音、图像学习和识别能力。<br><img src="http://dinson-blog.hdinson.cn/Ft0Z6EAr30-aIplsjfFcn5FtupXt.png" alt=""><br>画中画<br><img src="http://dinson-blog.hdinson.cn/FtOdaHdi6pHKtPk8vUy1t_mKa6Bd.png" alt=""><br>通知点<br><img src="http://dinson-blog.hdinson.cn/FoWDfDFY77RIzXSjzZmv3-RhOjcq.png" alt=""><br>智能选择<br><img src="http://dinson-blog.hdinson.cn/Fq9YTOykI-zSbucCJb2eKL3FCPza.png" alt=""></p><h2 id="TensorFlow-Lite"><a href="#TensorFlow-Lite" class="headerlink" title="TensorFlow Lite"></a>TensorFlow Lite</h2><p>Android O另一新部分为关键功能（Vitals），这包括了安全性改进、系统调整和更方便的开发者工具。其中系统调整中，Android O的开机启动时间比N快了2倍，而App的运行也更快更流畅，以Google Sheets作例子，在没有对App作改动情况下，Android O上运行快了两倍，新系统还在后台管理部分更智能，提供App定位和执行的限制。<br><img src="http://dinson-blog.hdinson.cn/Fg-bUT_rDh0qN_p5KM21IeheHUKJ.png" alt=""><br>关键性功能改进<br><img src="http://dinson-blog.hdinson.cn/FhTEAIb6TYUyvrq7DMfWrpCpMAss.png" alt=""><br>开机速度快2倍，App运行速度快2倍<br><img src="http://dinson-blog.hdinson.cn/FloGoCjFPEXthZypGf80L_kY7Y6-.png" alt=""><br>支持Kotlin<br><img src="http://dinson-blog.hdinson.cn/Fjclf9tfioJ3CKm5VAnUVtsC7MAt.png" alt=""><br>Android O最新支持Kotlin开发语言，这是由JetBrains基于JVM的一种编程语言，Google表示这是开发者社区强烈要求加入的。<br><img src="http://dinson-blog.hdinson.cn/FvQwaD1CHS2D8JQ1iYS9sC_77e--.png" alt=""><br>最后Android O还有一些新功能，其中当然少不了增加更多EMOJI表情！Android O Preview开发者阅览版在今天已经提供下载，但Google未透露正式版的推送时间。</p><h2 id="Google-I-O-宣布Galaxy-S8将支持Daydream，推出独立式移动VR设备"><a href="#Google-I-O-宣布Galaxy-S8将支持Daydream，推出独立式移动VR设备" class="headerlink" title="Google I/O 宣布Galaxy S8将支持Daydream，推出独立式移动VR设备"></a>Google I/O 宣布Galaxy S8将支持Daydream，推出独立式移动VR设备</h2><p>Google宣布了三星Galaxy S8手机将可支持移动VR平台Daydream，Google还联合高通、HTC和联想推独立式移动VR设备，在今年晚些时候开卖。<br>这次Google I/O 2017大会上VR和AR部分，为移动VR平台Daydream和AR项目Tango的新介绍，其中宣布了三星Galaxy S8手机将可支持Daydream，Google还联合高通、HTC和联想推独立式移动VR设备，Tango部分则宣布了华硕ZenFone AR手机和VPS定位技术。<br><img src="http://dinson-blog.hdinson.cn/FvGaMDuTLau4ZzOyWGFrDl4w8KeH.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FkytNpII8saTUyQ9UBl03EeZLcfV.png" alt=""><br>除了这类需要搭配Daydream View头显使用的智能手机VR外，Google还宣布推出独立式移动VR设备（Standalone VR）。<br>独立式移动VR设备不需要PC、手机和线缆，有更好易用性和身体定位，相比智能手机VR有更好的WorldSense运动追踪技术。<br><img src="http://dinson-blog.hdinson.cn/Fk0tajcyA6hpq0zI4BSbGzlqq_yL.png" alt=""><br>Google将于与高通、HTC和联想合作推出相关的产品，后者两款独立式VR设备将在今年晚些时候开卖。<br><img src="http://dinson-blog.hdinson.cn/Fudn_2ojtA3h6l3iNTzZIVtBli4t.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FsIg5uxiTPwa3gzJFuY0JAoQFWU2.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/Fu3DWkwPEA3rKa1CaxFvVYIWYKhA.png" alt=""><br>AR部分也就是Google的Tango项目，从2015的DK到去年发布首款AR手机，Tango发展顺利，今年华硕将在夏天开卖第二代Tango手机ZenFone AR。<br><img src="http://dinson-blog.hdinson.cn/FthzcYXG3mMPXkpqZTu2TLmH7nhj.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FpABLGpOuypbj8iojWMtc0jcNJkj.png" alt=""><br>技术方面，Tango与Google地图团体合作开发推出VPS（Visual Positioning Service，可视定位服务），提供准确的室内定位能力，可通过摄像头对室内的物体进行识别。<br><img src="http://dinson-blog.hdinson.cn/FvOhjNNcGzNYUjyKLm26aE7VOAmY.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FvGysvuo23UeVzpiwVJ-j7__Uqmz.png" alt=""><br>Tango还加入到Google的学校和教育项目Google Expeditions中，为学生展示AR技术。</p><h2 id="Google-Home智能音箱"><a href="#Google-Home智能音箱" class="headerlink" title="Google Home智能音箱"></a>Google Home智能音箱</h2><p>Google的智能家庭助手Google Home也迎来四个功能升级，包括主动通知和免提电话在内，并将在更多国家提供服务。<br>在今天凌晨的I/O 2017大会上，Google的智能家庭助手Google Home也迎来功能升级，包括主动式通知助手、免提电话、更多流媒体服务支持和可视化反馈，Google Home还将在更多国家提供服务。<br><img src="http://dinson-blog.hdinson.cn/Fpm-i1TFp-cH_W5I35MHHSMeeTqG.png" alt=""><br>Google Home将扩展在英国、加拿大、澳洲、法国、德国和日本六个国家，这次新加入了Proactive Assistance主动式助手，会自动通过底部的指示灯，提醒用户将下来的行程、事件、重要约会等。<br><img src="http://dinson-blog.hdinson.cn/Fn3pp3lRJ89anJzeFA8YeD27HJVH.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FhwVO3ptpf7N7aSBh5wXHGeqOBPh.png" alt=""><br>Google Home另一个新功能为Hands-Free Calling免提拨打功能，无需设置可免费拨打电话，支持现有的电话号码。<br><img src="http://dinson-blog.hdinson.cn/Fp3BD13nUGF7xxOKrNDo2LKA3gb_.png" alt=""><br>Google Home支持更多音乐流媒体服务商，并加入蓝牙连接播放手机上音乐支持，视频流媒体也加入更多电视内容。<br><img src="http://dinson-blog.hdinson.cn/Flvv6lDwSrSHlHzzW928VDS5FpmQ.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FmEUgXQiZ-FlOemvcdcYv8u6D4EB.png" alt=""><br>可视化反馈让Google Home可以通过Chromecast连接用户家中的电视，作为屏幕显示Google Assistant搜索返回的内容。</p><h2 id="Google公布可180万亿次浮点运算的Cloud-TPU，自动帮你画猫猫"><a href="#Google公布可180万亿次浮点运算的Cloud-TPU，自动帮你画猫猫" class="headerlink" title="Google公布可180万亿次浮点运算的Cloud TPU，自动帮你画猫猫"></a>Google公布可180万亿次浮点运算的Cloud TPU，自动帮你画猫猫</h2><p>Google在这次I/O 2017大会上公布了最新一代Cloud TPU，可提供每秒能进行180万亿次浮点运算，另外Google还利用AI资源建立Google.ai，用于多方面的AI运算。<br>Google CEO Sundar Pichai在这次I/O 2017大会上宣布Goolge要建立Ai First数据中心，用到最新一代Cloud TPU打造，为机器学习提供足够的运算能力，Google还结合现有AI资源推出Google.ai，用在科研项目和自动帮你画猫猫上…<br><img src="http://dinson-blog.hdinson.cn/FhM891BVbZ1o4bAxpbzWaOyhsuZ2.png" alt=""><br>在去年Google便公布了他们的TPU（Tensor Processing Unit，张量处理器），相比以往的CPU和GPU快15-30倍、效能高30-80倍，用于Google所有产品背后的计算，包括在AlphaGO上，但机器学习太复杂，经过锻炼和推断两个阶段，这需要超高的亿万级运算能力，所以Google为此推出了Cloud TPU。<br><img src="http://dinson-blog.hdinson.cn/FtQedQPsnO8spSa-w34Vgf4uz5bb.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FiCxP-toy7zxeVdjCgfY_Wzv84VP.png" alt=""><br>Google的Cloud TPU在一块运算板上包括了四个处理单元，每秒能进行180万亿次浮点运算，64块板可组成一套超级计算机，Google称为TPU Pods，每个Pods能提供11.5千万亿次浮点运算（PetaFLOPS）。<br><img src="http://dinson-blog.hdinson.cn/FmfLkw9eR0goGd01SCQYn6MZwYXa.png" alt=""><br>Could TPU除了AI云计算外，还将在今天开始加入到Google Computing Engine，提供给他们客户使用。<br>Google通过结合自身的AI优势建立了Google.ai，包括AtuoML用在AI的Learing to learn上，还有科研和医疗的活体组织检测模型建立预测、DNA序列研究上。<br><img src="http://dinson-blog.hdinson.cn/Fp6PVWB-_2g_9C92qqUffqjVUSvX.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FizNCl75j_A__tHR0e6nwmVoD_-4.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FvdasEO7hkqxpSsdYE7NwvVPYHkW.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FlLCUtonrbqJ2iTfRtktHE-RkCar.png" alt=""><br>另外除了那些复杂庞大的项目，Google.ai还能做简单有趣的事情，可以帮你自动纠正画猫猫。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=2054828&auto=1&height=66"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> I/O大会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式在Android开发中的应用</title>
      <link href="/2017/05/14/17-05-14/"/>
      <url>/2017/05/14/17-05-14/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>适配器：Adapter，大家看到这个单词是不是非常眼熟了？没错，这就是我们平时用到 ListView 和 RecyclerView 时必定会配合使用的 Adapter。列表显示数据几乎是任何一个安卓项目都会用到的一个功能，谷歌使用适配器模式来封装等使之异常灵活且非常实用，我们想要了解谷歌为什么这样做，就要先理解Java适配器模式是怎样运作的，这篇文章我们就学习一下java设计模式之一的适配器模式以及它在安卓中的应用。</p></blockquote><span id="more"></span><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>使用场景：适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p><p>引用网上的一个例子：笔记本电脑电源一般用的都是5V电压，但是我们的家用电是220V，我们要让笔记本充上电，最好的办法应该是通过一个工具把220V的电压转换成5V，这个工具就是适配器</p><blockquote><p>好好理解一下设计模式的使用场景比起去记住代码是怎样写的效果要好很多，说不定你哪天编码的时候灵光一现用上了，那就是你真正掌握了。</p></blockquote><h2 id="适配器模式的种类"><a href="#适配器模式的种类" class="headerlink" title="适配器模式的种类"></a>适配器模式的种类</h2><ol><li>类适配器<br> UML图(强烈建议大家去了解一下UML图，它很简单粗暴的把类与类之间的关系描述的很清楚易懂)<br> <img src="http://dinson-blog.hdinson.cn/Fs4FzeduZqZwKp_valNHL2xixG_a.png" alt=""><br> 我们可以看到，目标接口 Target 就相当于是上面的5V电压，Adaptee 就是被适配的220V电压，Adapter 就是适配器。看代码：<br> <img src="http://dinson-blog.hdinson.cn/FrnD7GHFRzAkfWsCBsW6S9RyJdCa.png" alt=""><br>输出结果：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">充5V电啦</span><br><span class="line">充220V电啦</span><br></pre></td></tr></table></figure>结合上面给点UML图稍微分析一下：</li></ol><p>Adapter类 继承了 Adaptee220V类 然后实现了接口 Target5V 并实现了目标方法 chong5V()，类适配器的一个特点就是 Adapter 会去继承被适配类，这样适配器就直接拥有了被适配类中的方法，所以类适配器的缺点就是不够灵活，让我们看一下另外一种适配器。</p><p>2.对象适配器<br>    <img src="http://dinson-blog.hdinson.cn/FqlJTeYjCEyqfW1TkXVFWhfXNlBj.png" alt=""><br>    这里的 Target 依然是 5V电压，Adaptee 依然是 220V电压，比起类适配器，Adapter 和 Adaptee 的关系从继承变成了组合，上代码：<br>    <img src="http://dinson-blog.hdinson.cn/Fp19DHfUfVXxpmoVLljE8cbVk_y7.png" alt=""><br>输出结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">充5V电啦</span><br><span class="line">充220V电啦</span><br></pre></td></tr></table></figure><br>这里我们把 Adaptee220V 通过 Adapter 的构造方法传入到 Adapter 中，当调用 Adapter 的 chong220V()方法 时，实际是调用传进来 Adaptee220V 对象的 chong220V 方法，这样就会变得很灵活。</p><h2 id="项目中的运用"><a href="#项目中的运用" class="headerlink" title="项目中的运用"></a>项目中的运用</h2><p>之所以写这篇关于适配器设计模式的文章，是因为作者在以前有一次实际开发中，在没有学习过适配器模式的前提下，为了解决项目中的一个开发痛点，自己费劲脑筋想出来的一种模式，到现在才知道原来这个叫适配器模式，在学习了这个设计模式之后更加深入了解了一下。接下来，就来演示一下作者在实际工作中使用到的变异形态的对象适配器模式。</p><p>当时开发场景：当时作者开发一个基于POS机的APP，APP要求有打印功能，像订单打印、日期打印等等。我们知道POS机是有多种型号的，每种型号的POS机会有他们单独的SDK，也就是说打印方法是不同的！<br><img src="http://dinson-blog.hdinson.cn/FvDRdNm9GjhtZcVJU3zGmFJjlRsS.png" alt=""><br>首先，我们每次调用打印的时候都会先判断 POS机 型号，因为型号不对程序肯定会报错，假如某一天，APP适配的 POS机 类型要增加一款，也就是说我每个判断 POS机 型号的地方都要多家一个if语句，并且还要把 新POS机型 的打印方法加上去，如果我有5个地方用到了打印，就要加5次，这样是很痛苦的，别问我为什么知道。。。经过2次这样的真实情况发生后，我暴走了，痛定思痛要想个办法结局，于是有了以下代码：<br><img src="http://dinson-blog.hdinson.cn/FivN4O4hC_9t73vDyjI-waTLQrd0.png" alt=""><br>每种 POS机 都实现 IPrint 中的打印方法：<br><img src="http://dinson-blog.hdinson.cn/Fpn2N2ZOurpL1MYk_KQGbUy99_Xn.png" alt=""><br>这里我把 POS机 型号判断的代码放到了 PrintManager 的构造方法中，每次 new 出实例时就会去判断。然后我让 PrintManager 也实现了IPrint接口，因为我认为项目中的打印管理类必须要拥有这三种打印方法。<br><img src="http://dinson-blog.hdinson.cn/FthJ065I8Q4WZIDg4qvY6O3y3i-6.png" alt=""><br>发现没，改过之后的代码，在不同的调用的地方再也不用担心新增POS机型需要改代码了，只需要在 PrintManager 的构造方法中增加一个判断就好了。要是改成单例：<br><img src="http://dinson-blog.hdinson.cn/Ft17x0u3weV_Vr1eGsOH5E_OWCG5.png" alt=""><br>改完之后我哭了。。。我他吗的是个天才啊。。。后面果然加了多款POS机，但是我再也不痛苦了！看一下我的UML图：<br><img src="http://dinson-blog.hdinson.cn/FouB2lpViMCX2QC5qam7YltZBmoZ.png" alt=""><br>其实，光看UML图，作者在项目中的这种写法已经不算是适配器模式了，因为 Adaptee 已经直接实现了Target中的方法，也就是说根本就不存在不满足目标接口这个说法了。。不过作者这样写完全是自己想出来的，没有基于任何设计模式，就现在目前的效果来说还是不错的，通过这篇文章，我对于适配器模式有了一个清晰的理解，同时也反思了一下我这种写法，还是很有收获的。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=19107967&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android录屏与截图功能(5.0以上有效)</title>
      <link href="/2017/05/13/17-05-12/"/>
      <url>/2017/05/13/17-05-12/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>这篇文章，会带你学习如何使用 MediaProjection，MediaCodec 以及 MediaMuxer 来实现简单的截屏和录屏功能。</p><p>因为 MediaProjection 是 5.0以上 才出现的，所以今天所讲述功能实现，只在 5.0以上 的系统有效。</p></blockquote><span id="more"></span><h2 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h2><h3 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h3><p>1：获取 MediaProjectionManager</p><p>2：通过 MediaProjectionManager.createScreenCaptureIntent() 获取 Intent</p><p>3：通过 startActivityForResult 传入 Intent 然后在 onActivityResult 中通过 MediaProjectionManager.getMediaProjection(resultCode,data) 获取 MediaProjection</p><p>4：创建 ImageReader,构建 VirtualDisplay</p><p>5 : 最后就是通过 ImageReader 截图，就可以从 ImageReader 里获得 Image 对象。</p><p>6 : 将 Image 对象转换成 bitmap</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>步骤已经给出了，我们就按照步骤来实现代码吧。</p><p>首先 MediaProjectionManager 是系统服务，我们通过<br><code>getSystemService(MEDIA_PROJECTION_SERVICE)</code>获取它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projectionManager = (MediaProjectionManager)getSystemService(MEDIA_PROJECTION_SERVICE);</span><br></pre></td></tr></table></figure><p>然后调用 startActivityForResult 传入 projectionManager.createScreenCaptureIntent() 创建的 Intent</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivityForResult(projectionManager.createScreenCaptureIntent(), SCREEN_SHOT);</span><br></pre></td></tr></table></figure><p>紧接着我们就可以在 onActivityResult(int requestCode, int resultCode, Intent data) 中通过 resultCode 和 data 来获取 MediaProjection：<br><img src="http://dinson-blog.hdinson.cn/FvvwP2iend8mydeWF0tijrsyMnbx.png" alt=""><br>然后就是创建 ImageReader 和 VirtualDisplay：<br><img src="http://dinson-blog.hdinson.cn/FtclwbgSmfNuAKRzLV7ItmxQ2TUB.png" alt=""><br><strong>这里我们依次讲解一下：</strong><br>首先是 ImageReader.newInstance 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static ImageReader newInstance(int width, int height, int format, int maxImages)</span><br></pre></td></tr></table></figure></p><p>方法里接收四个参数。前两个 width,height 是用来指定生成图像的宽和高。<br><strong>第三个参数</strong> format 是图像的格式，这个格式必须是 ImageFormat或 PixelFormat 中的一个，这两个 Format 里有很多格式，大家可以点进去看看，我们例子中使用的是 PixelFormat.RGBA_8888 格式(需要注意的是并不是所有的格式都被 ImageReader 支持，比如说 ImageFormat.NV21)。</p><p><strong>第四个参数</strong> maxImages，这个参数指的是你想同时在 ImageReader 里获取到的 Image对象 的个数，这个参数我不是很懂，我不理解同时的意思。我的理解是 ImageReader 是一个类似数组的东西，然后我们可以通过 acquireLatestImage() 或 acquireNextImage() 方法来得到里面的 Image对象(可能有误，仅供参考)。这个值应该设置的越小越好，但是得大于0，所以我们上面设置的是1。</p><p>然后我们看看 mediaProjection.createVirtualDisplay 方法：<br><img src="http://dinson-blog.hdinson.cn/FtUczK9qlxRq-TQdEndwzXTgfn6F.png" alt=""><br>首先这个方法返回的是 VirtualDisplay。<br>前四个不用说了，分别是 VirtualDisplay 的名字，宽，高和dpi。</p><p><strong>第五个参数</strong>，大家可以访问</p><blockquote><p><a href="https://developer.android.google.cn/reference/android/hardware/display/DisplayManager.html">https://developer.android.google.cn/reference/android/hardware/display/DisplayManager.html</a></p></blockquote><p>查看 DisplayManager 的所有flags，我没有具体的研究过，在本次要实现的例子里，除了 VIRTUAL_DISPLAY_FLAG_SECURE 这个会报错，其他的 flags 效果都一样。</p><p><strong>第六个参数</strong> 是一个 Surface。我这里表达一下我的理解，当 VirtualDisplay 被创建出来时，也就是 createVirtualDisplay 调用后，你在真实屏幕上的每一帧都会输入到 Surface参数 里。也就是说，如果你放个 SurfaceView，然后传入 SurfaceView 的 Surface 那么你在屏幕上的操作都会显示在 SurfaceView 里(这里我们后面录屏会讲)。我们这里传入的是 ImageReader 的 Surface。这其中的逻辑我的理解是这样的，真实屏幕的每一帧都都会传给 ImageReader，根据 ImageReader 的 maxImages参数，比如说 maxImages 是 2，那么 ImageReader 始终保持两帧图片，但这两帧图片是一直随着真实屏幕的操作而更新的(不知道大家有没有听懂)。</p><p><strong>第七个参数</strong> 是一个回调函数，在 VirtualDisplay 状态改变时调用。因为我们这里没有，所以传 null。</p><p><strong>第八个参数</strong> 这里我给出原文：“The Handler on which the callback should be invoked, or null if the callback should be invoked on the calling thread’s main Looper.” 因为我翻译不好。不过和普通的 Handler 使用场景类似。</p><p>现在我们 ImageReader 和 VirtualDisplay，接下来我们就可以通过 ImageReader 的 acquireLatestImage() 或 acquireNextImage() 来得到 Image对象 了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SystemClock.sleep(1000);</span><br><span class="line">Image image = imageReader.acquireNextImage();</span><br></pre></td></tr></table></figure><p>这里有个坑，就是你在获取 Image 的时候，得先暂停1秒左右，不然就会获取失败(原因未知)。</p><p>现在我们有了 Image对象，但是 Image对象 并不能直接作为UI资源被使用，我们可以将它转换成 Bitmap对象。<br><img src="http://dinson-blog.hdinson.cn/FkMjyveYJT5Rk3XXBS6V8-3xAb31.png" alt=""></p><p>这里最主要的逻辑就是像素与字节的转换，我们需要将 Image对象 的字节流写进 Bitmap 里，但是 Bitmap 接收的是像素格式的。</p><p>我们一行一行来看：</p><p>首先获取 image对象 的宽和高，注意 width 和 height 是像素格式的。</p><p>然后获取 ByteBuffer，里面存放的就是图片的字节流，是字节格式的。我是这么理解的，ByteBuffer 里面是一长串的字节序列，按照某种格式分成行列就变成了图片。</p><p>然后获取 PixelStride，这指的是两个像素的距离(就是一个像素头部到相邻像素的头部)，这是字节格式的。</p><p>RowStride 是一行占用的距离(就是一行像素头部到相邻行像素的头部)，这个大小和 width 有关，这里需要注意，因为内存对齐的原因，所以每行会有一些空余。这个值也是字节格式的。</p><p>紧接着我们需要创建一个 Bitmap 用来接受 Image 的 buffer 的输入，buffer 是字节流，它会按照我们设置的 format 转换成像素，所以这里最重要的一个地方就是 Bitmap 创建的大小，因为高度就是行数所以就是 height，但是宽度因为上面说的内存对齐问题会有些空余，所以我们要先求出空余部分，然后加上 width。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rowPadding = rowStride - pixelStride * width;</span><br></pre></td></tr></table></figure><p>这句话用整行的距离减去了一行里像素及空隙占用的距离，剩下的就是空余部分。但是这个是字节格式的。我们将它除以 pixelStride，也就是一个像素及空隙占用的字节大小，就转换成了像素格式。然后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width + rowPadding / pixelStride</span><br></pre></td></tr></table></figure><p>这个就是一行里像素的占用了，我们将它传给Bitmap：<br><img src="http://dinson-blog.hdinson.cn/FjyAwd7uOuIyoNuuaec1qCa3nymr.png" alt=""></p><p>创建出合适大小的 Bitmap，然后把 Image 的 buffer 传给它，就成功的将 Image对象 转换成了 Bitmap。这里我可能讲的不清楚，我给大家画了张图：<br><img src="http://dinson-blog.hdinson.cn/FnWlneYKo0wXmd93bqaRDI4M34d4.png" alt=""></p><p>上面的一小格一小格是一块块像素。</p><p>好了，现在我们已经获取到了 bitmap 了，我们可以把它放到 ImageView 里显示一下，我写了一个例子，效果如下：<br><img src="http://dinson-blog.hdinson.cn/FtWvLYP7rKhdUAWUPx34llXrOGK3.png" alt=""></p><p>点击按钮，弹出一个对话框请求截屏，点击立即开始的话，截屏就会显示在下面的 ImageView 里。</p><h2 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>录屏的前三步和截屏是一样的，出现分歧点的地方在于 VirtualDisplay 创建时传入的 Surface，还记得我们上面说的吗，说在创建 VirtualDisplay 的时候，传入一个 SurfaceView 的 Surface 的话，那么你在真实屏幕上的操作，都会重现在 SurfaceView 上。我们来试一下：<br><img src="http://dinson-blog.hdinson.cn/FnytHOMHEcK-U27XqYMkI8d69TrV.png" alt=""></p><p>我们在Surface参数中传入一个 SurfaceView 的 Surface，效果如下：<br><img src="http://dinson-blog.hdinson.cn/FrUySmrKvQ8DIsbBwUNS2O_VRUMk.png" alt=""></p><p>可以看到我们放了一个 Button，放了一个 ImageView，放了一个 SurfaceView。点击 Button，然后点立即开始之后，真实屏幕就映射到了 SurfaceView 里。</p><p>所以当创建 VirtualDisplay 时，真实屏幕就映射到了 Surface，也就是我们可以再 Surface 里拿到屏幕的一个输入。那我们要录屏的话，就只要把 Surface 转换成我们需要的格式就行了。</p><p>在本篇文章的例子中，我们会将 Surface对象 转换成 mp4格式。这就需要用到MediaCodec类 和 MediaMuxer类。MediaCodec 生成一个 Surface 用来接收屏幕的输出并按照格式编码，然后传给 MediaMuxer 用来封装成 mp4格式 的视频。<br><img src="http://dinson-blog.hdinson.cn/Frwb1-cIhukMvnpralVVIChnGnxj.png" alt=""><br>上面讲了 MediaCodec 的创建，我们也可以从中看到屏幕数据是怎么进入 MediaCodec 的。具体的我已经注释了。</p><p>接下来我们创建一个 MediaMuxer对象：<br><img src="http://dinson-blog.hdinson.cn/FghD5GELyVoh3Q10yfrrEyxvGmIJ.png" alt=""><br>然后创建 VirtualDisplay，把 MediaCodec的surface 传进去：<br><img src="http://dinson-blog.hdinson.cn/FlSvfgcwQfAnOYlwK965rqsxvQw1.png" alt=""><br>最后就是视频的编码与转换MP4还有保存了：<br><img src="http://dinson-blog.hdinson.cn/FkgEsiyPE32QpetqNVJ-1RJsZZy2.png" alt=""><br>好了，录屏到此结束了。我们来看下实例演示：<br><img src="http://dinson-blog.hdinson.cn/FuksI4ntCx3D9s-GcPmdh6vpQHu9.png" alt=""></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=17194024&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 录屏 </tag>
            
            <tag> 截图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android ConstraintLayout 使用指南</title>
      <link href="/2017/05/11/17-05-11/"/>
      <url>/2017/05/11/17-05-11/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>升级Android Studio 2.3之后，IDE默认生成的Activity布局都是以ConstraintLayout做为根布局，体验了一把这个Google去年就开始力推的ConstraintLayout后，觉得非常不错，本文用于记录ConstraintLayout各个方面的使用知识。</p></blockquote><span id="more"></span><h2 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h2><ul><li>ConstraintLayout最低兼容Android 2.3；</li><li>目前Android Studio 2.3默认使用ConstraintLayout作为布局文件的根布局；</li><li>想要使用ConstraintLayout，需在项目的build.gradle添加com.android.support.constraint:constraint-layout：XXX版本号依赖；</li></ul><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>ConstraintLayout翻译成中文也称为约束布局，在整个使用体验过程中真的是贯穿约束二字，这一节先来介绍一些基础使用，后面你就会慢慢感受到约束布局的魅力。创建完工程后打开布局文件，底部切换Design的Tab上，可以看到整个操作界面<br><img src="http://dinson-blog.hdinson.cn/Fh88OzTWuj-tCkdgHRA4cfXqVNiZ.png" alt=""> </p><p>左上角的面板是放置了系统内置各种各样的控件，想要布局直接拖到到布局文件中即可（所见即所得），右边的面板是选中布局文件中的控件时期各种各样的空间属性，ConstraintLayout最大的好处在于让我们通过拖控件的形式进行布局，并且不用担心适配问题。所以，先来拖个控件试试看，将一个Button拖动到屏幕正中央，然后运行显示看看效果。<br><img src="http://dinson-blog.hdinson.cn/Fk9RCseEVhX1YMe1HgpvyfRgXSgK.gif" alt=""></p><p><img src="http://dinson-blog.hdinson.cn/Fh5ZFnU_lprrxHcRDq6bRkSfn_dH.png" alt=""><br>而实际运行后却发现，这个Button还是位于屏幕左上角，说好的居中效果呢？<br>这里就要开始引入ConstraintLayout的约束概念，我们切换回去看xml的布局代码，发现了两个问题。<br>第一，布局预览时能够看到显示居中的Button，是因为控件属性设置中引用了两个tools命名空间下的属性。<br><img src="http://dinson-blog.hdinson.cn/FhfHzegfsnDjDfUcSq1myX6wS65z.png" alt=""><br>我们都知道，这两个属性只在布局编辑器的预览中有效，实际运行效果是不生效的。</p><p>第二，Button标签下有红色波浪线警告，我们把鼠标移到对应位置会发现警告内容，告诉我们Button没有任何约束设置，当前效果只支持预览，实际运行后会返回到左上角去，同时提示我们应该给控件添加约束。<br><img src="http://dinson-blog.hdinson.cn/FvQG1W61UkNfFJgK2koGJ_YsIbHf.png" alt=""><br>如何增加约束？回到Design页面，对着控件上下左右四个原点拖动添加对应的约束即可<br><img src="http://dinson-blog.hdinson.cn/FuIMSr43yM-CT5v1UrwDfaY1aZld.gif" alt=""><br>成功添加约束后，即可得到正常的运行效果了。<br><img src="http://dinson-blog.hdinson.cn/FmuneIrlzFFdwgBcyb-e0BIsMnbw.png" alt=""><br>实际操作不一定要在Tab，也可以直接在Text页面拖动控件添加约束<br><img src="http://dinson-blog.hdinson.cn/FqukVcGA7UTeISA3PFnP1tz2cQku.png" alt=""><br>成功实现添加约束后，可以看到Button多了下面几个属性设置<br><img src="http://dinson-blog.hdinson.cn/Fl1j15gsnVPfVL1sZONRs5ERxYXC.png" alt=""></p><p><code>app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</code> 意思是Button底部的布局约束是位于parent的底部，parent是指包裹着它的ConstraintLayout，也可以设置指定某个控件的id，其他类似的属性就不再赘述，以上四个约束联合起来便实现了Button的居中，ConstraintLayout总共有下面这些同类的属性<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintLeft_toLeftOf</span><br><span class="line">app:layout_constraintLeft_toRightOf</span><br><span class="line"></span><br><span class="line">app:layout_constraintRight_toLeftOf</span><br><span class="line">app:layout_constraintRight_toRightOf</span><br><span class="line"></span><br><span class="line">app:layout_constraintTop_toTopOf</span><br><span class="line">app:layout_constraintTop_toBottomOf</span><br><span class="line"></span><br><span class="line">app:layout_constraintBottom_toTopOf</span><br><span class="line">app:layout_constraintBottom_toBottomOf</span><br><span class="line"></span><br><span class="line">app:layout_constraintStart_toEndOf</span><br><span class="line">app:layout_constraintStart_toStartOf</span><br><span class="line"></span><br><span class="line">app:layout_constraintEnd_toStartOf</span><br><span class="line">app:layout_constraintEnd_toEndOf</span><br><span class="line"></span><br><span class="line">app:layout_constraintBaseline_toBaselineOf</span><br></pre></td></tr></table></figure></p><p>你会发现ConstraintLayout非常灵活的把RelativeLayout的活给干了，关于left、right、top、bottom、start、end、baseline的基准可以参照下图<br><img src="http://dinson-blog.hdinson.cn/FsKl7bMhdTD8qXyQDnFAi-4Kxfjo.png" alt=""><br>如果我想加多一个Button2并且将其放置到原先居中Button的右方并且与其底部对齐，只需如下操作即可<br><img src="http://dinson-blog.hdinson.cn/FqliwdR_M5jojMB502KyRRSJIzjp.gif" alt=""><br>并且你也可以发现，Button2依赖与Button后会随着Button的移动而跟着发生相对移动，目的是了保证我设置的依赖，时刻保持Button2就在Button的右边，并且底部对齐。你也可以看到布局文件中也为Button2添加了如下两个属性<br><img src="http://dinson-blog.hdinson.cn/FudjacpmywOSX8_e4celVfQh76Sw.png" alt=""><br>如果你已经理解上面提到的属性含义，这里应该不会有疑惑。</p><p>介绍完上下左右的依赖设置后，下面介绍一些Margin属性，除了Android常见的各种android:layout_marginXXX外，ConstraintLayout自行添加了如下属性<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app:layout_goneMarginBottom</span><br><span class="line">app:layout_goneMarginEnd</span><br><span class="line">app:layout_goneMarginLeft</span><br><span class="line">app:layout_goneMarginRight</span><br><span class="line">app:layout_goneMarginStart</span><br><span class="line">app:layout_goneMarginTop</span><br></pre></td></tr></table></figure></p><p>这些设置生效于当依赖的约束对象被设置visibility为gone时。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app:layout_constraintVertical_bias</span><br><span class="line">app:layout_constraintHorizontal_bias</span><br></pre></td></tr></table></figure></p><p>当为目标控件设置好横纵向的约束时（app:layout_constraintLeft_toLeftOf=”parent”、app:layout_constraintRight_toRightOf=”parent”或者app:layout_constraintTop_toTopOf=”parent”、app:layout_constraintBottom_toBottomOf=”parent”），这个两个属性才会生效。实际操作过程中，你会发现对着设置好横纵向约束的Button进行拖动，布局中的layout_constraintHorizontal_bias和layout_constraintVertical_bias会一直发生相应的变化，如果你需要Button居中，那么直接将这两个属性的参数值设置为0.5即可。<br><img src="http://dinson-blog.hdinson.cn/Fj8JMcH1IR1cbDpfn7TnzupsmW2Y.gif" alt=""></p><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><blockquote><p>这里先补充一个关于ConstraintLayout的知识点，与其他Layout不同之处在于，它的layout_width和layout_height不支持设置match_parent，其属性取值只有以下三种情况：</p><ul><li>wrap_content；</li><li>指定具体dp值；</li><li>0dp（match_constraint），代表填充约束之意，注意不要以为和match_parent是一样的；</li></ul></blockquote><p>想想如果没有ConstraintLayout，我们要让一个控件的宽高按某个比例进行布局应该怎么做？有了ConstraintLayout后，我们可以使用layout_constraintDimentionRatio属性设置宽高比例，前提是目标控件的layout_width和layout_height至少有一个设置为0dp，如下让一个ImageView宽高按照2:1的比例显示</p><p><img src="http://dinson-blog.hdinson.cn/Fsf4Y9m69YwE5HujvsEGNIr-HBNH.png" alt=""><br>layout_constraintDimentionRatio默认参数比例是指宽：高，变成高:宽可以设app:layout_constraintDimensionRatio=”H,2:1”。</p><p>ConstraintLayout的链条（Chains）特性非常强大，在没有ConstraintLayout之前，线性布局我们主要都依靠LinearLayout来完成，有了ConstraintLayout之后，它把LinearLayout的活也干了，例如要把按钮水平排成一行，可以这样操作<br><img src="http://dinson-blog.hdinson.cn/FqYICFlgWhQmP9vk-xHU8hPF0i33.gif" alt=""><br>这样ButtonA、B、C就在水平方向形成了一条Chain，并且底部对齐。回去看xml文件，会见到ButtonA新增app:layout_constraintHorizontal_chainStyle的属性设置，这个属性在一条Chain中只会出现在第一个控件中，这个控件是整条Chain的Head。<br><img src="http://dinson-blog.hdinson.cn/FtGPVrfIVjFmGFRNWHqzxnoLXTbl.png" alt=""><br>除了水平方向的layout_constraintHorizontal_chainStyle外还有垂直方向的layout_constraintVertical_chainStyle，两者均有spread,spread_inside,packed这三种取值，如果将控件的layout_width和layout_height设置成为0dp，还可以配合layout_constraintHorizontal_weight、layout_constraintVertical_weight两个属性实现和LinearLayout中设置layout_weight相同的效果，具体的操作这里就不再展示了，下面一张图告诉你Chain的强大之处。<br><img src="http://dinson-blog.hdinson.cn/FnHoSNDHIKaTMcmeAQLkqovC0ZDs.png" alt=""><br>关于Chain的就介绍到此，进阶的最后一部分再介绍一下Guideline功能，如果我们需要对着屏幕的中轴线进行布局，就可以使用到Guideline进行操作，例如下面两个Button分别分布在中轴线的左右两侧<br><img src="http://dinson-blog.hdinson.cn/FpwkfWafTRKbMMwnblVjXogv9uiW.gif" alt=""><br>从操作上我们可以看到Guideline也分为垂直和水平两种，并且支持设置在屏幕中所处的位置，可以使用layout_constraintGuide_begin和layout_constraintGuide_end设置具体dp值，也可以使用layout_constraintGuide_percent来设置比例。实际上它也只是一个辅助我们布局的View而已，其源码内部实现也非常简单，并且默认设置了visibility为gone，关于ConstraintLayout的进阶使用便介绍到这里。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ConstraintLayout的使用优势</p><ul><li>高效布局，Android这么多年以来真正意义上的实现了所见即所得的拖曳方式布局，极大的提高开发效率；</li><li>轻松灵活的实现复杂的布局；</li><li>解决多重布局嵌套问题，通过前面介绍你会发现ConstraintLayout真的是非常灵活，可以很大程度的避免Layout之间的嵌套；</li><li>满足屏幕适配的需求，想想没有ConstraintLayout之前的拖曳式布局，你就知道有多恶心；</li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=33410478&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConstraintLayout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android全屏／沉浸式状态栏下，各种键盘挡住输入框解决办法</title>
      <link href="/2017/05/10/17-05-10/"/>
      <url>/2017/05/10/17-05-10/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>在开发中，经常会遇到键盘挡住输入框的情况，比如登录界面或注册界面，弹出的软键盘把登录或注册按钮挡住了，用户必须把软键盘收起，才能点击相应按钮，这样的用户体验非常不好。像微信则直接把登录按钮做在输入框的上面，但有很多情况下，这经常满足不了需求。同时如果输入框特别多的情况下，点击输入时，当前输入框没被挡住，但是当前输入框下面的输入框却无法获取焦点，必须先把键盘收起，再去获取下面输入框焦点，这样用户体验也非常不好，那有什么办法呢？ </p></blockquote><span id="more"></span><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><blockquote><p>非透明状态栏下使用adjustResize和adjustPan，或是透明状态栏下使用fitsSystemWindows=true属性</p></blockquote><p>主要实现方法：<br>在AndroidManifest.xml对应的Activity里添加<br>Android:windowSoftInputMode=”adjustPan”或是android:windowSoftInputMode=”adjustResize”属性 </p><p>这两种属性的区别，官方的解释是： </p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>adjustResize</td><td>该活动的主窗口始终调整大小，以使屏幕上的软键盘的余地。</td></tr><tr><td>adjustPan</td><td>该活动的主窗口无法调整大小，使软键盘的余地。相反，窗口的内容是自动平移以便当前焦点从来没有遮挡键盘，用户始终可以看到他们正在键入。这是比调整大小，一般是较不可取，因为用户可能需要关闭软键盘在获取和与模糊部分窗口的互动。</td></tr></tbody></table></div><p>这两个属性作用都是为了调整界面使键盘不挡住输入框 ，我这里对这两种属性使用场景、优缺点、注意事项进行了全方面总结，不知大家平时使用时是否注意到了。</p><div class="table-container"><table><thead><tr><th><strong>属性</strong></th><th><strong>注意事项</strong></th><th><strong>优缺点</strong></th><th><strong>失效情况</strong></th><th><strong>适用情况</strong></th></tr></thead><tbody><tr><td>adjustResize</td><td>需要界面本身可调整尺寸，如在布局添加ScrollView，或输入控件属于RecycleView/ListView某一项</td><td>优点：1.不会把标题栏顶出当前布局；<br>2.有多项输入时，当前输入框下面的输入框可上下滑动输入<br>缺点：1.需要界面本身可调整尺寸;<br>2. 全屏时失效</td><td>1.Activity主窗口尺寸无法调整；<br>2.Activity全屏<br>3.android5.0以上通过style设置沉浸式状态栏模式而不设置fitSystemWindow为true</td><td>非全屏或是非沉浸式状态栏输入界面，输入框比较多</td></tr><tr><td>adjustPan</td><td>页面不会重新布局，当前输入框和键盘会直接将当前输入框以上界面整体向上平移，这样即使界面包含标题栏，也会被顶上去</td><td>优点： 使用简单，不需要界面本身可调整尺寸，不会有失效情况 <br>缺点： 会把标题栏顶出当前布局；有多项输入时，当前输入框下面的输入框无法输入，必须收起键盘显示输入框再输入</td><td>无</td><td>有少量输入项，且输入量居界面上方</td></tr><tr><td>fitsSystemWindows</td><td>如果多个View设置了fitsSystemWindows=”true”,只有初始的view起作用，都是从第一个设置了fitsSystemWindows的view开始计算padding</td><td>优点：使用简单，需要沉浸式状态栏的界面，不需要自己计算padding状态栏的高度<br>缺点：使用有限制</td><td>1.View 的其他 padding 值被重新改写了<br>2.手机系统版本&gt;=android 4.4</td><td>1.界面全屏<br>2.设置界面主题为沉浸式状态栏</td></tr></tbody></table></div><ul><li>adjustResize失效情况：activity设置了全屏属性指Theme.Light.NotittleBar.Fullscreen(键盘弹起时会将标题栏也推上去)或者设置了activity对应的主题中android:windowTranslucentStatus属性，设置方式为：android:windowTranslucentStatus=true，这时如果对应的页面上含有输入框，将会导致点击输入框时软键盘弹出后键盘覆盖输入框，导致输入框看不见。</li><li>fitsSystemWindows=”true”,只有初始的view起作用：如果在布局中不是最外层控件设置fitsSystemWindows=”true”, 那么设置的那个控件高度会多出一个状态栏高度。若有多个view设置了，因第一个view已经消耗掉insect，其他view设置了也会被系统忽略。</li></ul><p>假设原始界面是一个LinearLayout包含若干EditText,如下图所示，在分别使用两种属性时的表现。<br><img src="http://dinson-blog.hdinson.cn/FiBssb1owc6o5RWvY8jttNlNpqEw.png" alt=""></p><h3 id="adjustPan"><a href="#adjustPan" class="headerlink" title="adjustPan"></a>adjustPan</h3><p>整个界面向上平移，使输入框露出，它不会改变界面的布局；界面整体可用高度还是屏幕高度，这个可以通过下面的截图看出，如点击输入框6,输入框会被推到键盘上方，但输入框1被顶出去了，如果界面包含标题栏，也会被顶出去。<br><img src="http://dinson-blog.hdinson.cn/FqcA0acjqFTCdq7fhGMQAQLCymuy.png" alt=""></p><h3 id="adjustResize"><a href="#adjustResize" class="headerlink" title="adjustResize"></a>adjustResize</h3><p><img src="http://dinson-blog.hdinson.cn/FlalEPmcfHwUAaQzlmbOZCOny3Qq.png" alt=""></p><p>但使用这两种属性，我们可以总结以下几点：<br>1) 使用adjustPan, 如果需要输入的项比较多时，点击输入框，当前输入项会被顶到软键盘上方，但若当前输入框下面还有输入项时，却需要先收起键盘，再点击相应的输入项才能输入。这样操作太繁琐了，对于用户体验不大好；<br>2) adjustResize的使用，需要界面本身可显示的窗口内容能调整，可结合scrollview使用；</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><blockquote><p>在界面最外层布局包裹ScrollView</p></blockquote><h3 id="只使用ScrollView"><a href="#只使用ScrollView" class="headerlink" title="只使用ScrollView"></a>只使用ScrollView</h3><p>在相应界面的xml布局中，最外层添加一个ScrollView，不在AndroidMainfest.xml中设置任何android:windowSoftInputMode属性，此时点击输入框，输入框均不会被软键盘档住。即使当前输入框下方也有输入框，在键盘显示的情况下，也可以通过上下滑动界面来输入，而不用先隐藏键盘，点击下方输入框，再显示键盘输入。 </p><p>我们可以根据Android Studio的Inspect Layout工具来查看界面真正占用的布局高度，工具在<br><img src="http://dinson-blog.hdinson.cn/FtVH5PO3wZr8dcUo_npuTi46j9Aj.png" alt=""><br>通过该工具，我们看到：<br>界面真正能用的高度=屏幕高度-状态栏高度-软键盘高度<br>界面中蓝框是真正界面所用的高度：<br><img src="http://dinson-blog.hdinson.cn/Fnd8_JCSsg5tPYqYC7yOjESZXX3U.png" alt=""></p><h3 id="ScrollView-adjustPan"><a href="#ScrollView-adjustPan" class="headerlink" title="ScrollView+adjustPan"></a>ScrollView+adjustPan</h3><p>我们再在该类的AndroidMainfest.xml中设置windowSoftInputMode属性为adjustPan<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.TestInputActivity&quot; android:windowSoftInputMode=&quot;adjustPan&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>发现当前输入框不会被挡住，但是输入框比较多时，在有键盘显示时，界面上下滑动，但只能滑动部分，且如果输入框在界面靠下方时，点击输入框，标题栏也会被顶出去，如下图所示：<br><img src="http://dinson-blog.hdinson.cn/FvQ_kx2DYkusBw3VGgEvueIr8kEb.png" alt=""></p><p>我们借助Inspect Layout工具查看此设置布局可用高度，从下图可以看出，此时布局可用高度是屏幕的高度，上下滑动也只是此屏的高度，在输入框9以下的输入框滑不出来，向上滑动，也只能滑到输入框1。<br><img src="http://dinson-blog.hdinson.cn/FhsoS1St7ob22uZpH5n2ZCvDp-Q-.png" alt=""></p><h3 id="ScrollView-adjustResize"><a href="#ScrollView-adjustResize" class="headerlink" title="ScrollView+adjustResize"></a>ScrollView+adjustResize</h3><p>我们前面说过adjustResize的使用必须界面布局高度是可变的，如最外层套个ScrollView或是界面可收缩的，才起作用。这里在该类的AndroidMainfest.xml中设置windowSoftInputMode属性为adjustResize<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.TestInputActivity&quot; android:windowSoftInputMode=&quot;adjustResize&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>发现效果和1不设置任何windowSoftInputMode属性类似，其使用高度也是：屏幕高度-状态栏高度-软键盘高度<br><img src="http://dinson-blog.hdinson.cn/Fk4K9zDXpOsQlqHUKCqrBP20zEAI.png" alt=""></p><p>我们再来看看windowSoftInputMode默认属性值stateUnspecified:</p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>stateUnspecified</td><td>软键盘的状态(隐藏或可见)没有被指定。系统将选择一个合适的状态或依赖于主题的设置</td></tr></tbody></table></div><p>可以看出，系统将选择合适的状态，也就是在界面最外层包含一层ScrollView时，设置默认属性值stateUnspecified其实就是adjustResize属性。</p><p>但以下两方面无法满足需求：<br>1) 当Activity设置成全屏fullscreen模式时或是使用沉浸式状态栏时，界面最外层包裹 ScrollView，当输入框超过一屏，当前输入框下面的输入框并不能上下滑动来输入，情况类似于ScrollView+adjustPan，只能滑动部分，通过Inspect Layout也可以看到，界面可用高度是整个屏幕高度，并不会进行调整高度。即使设置adjustResize，也不起作用。<br>2) 如果是类似于注册界面或是登录界面，键盘会挡住输入框下面的登录按钮。</p><h3 id="沉浸式状态栏／透明状态栏情况下"><a href="#沉浸式状态栏／透明状态栏情况下" class="headerlink" title="沉浸式状态栏／透明状态栏情况下"></a>沉浸式状态栏／透明状态栏情况下</h3><p>自android系统4.4(API&gt;=19）就开始支持沉浸式状态栏，当使用觉System windows(系统窗口),显示系统一些属性和操作区域，如 最上方的状态及没有实体按键的最下方的虚拟导航栏。<br>android:fitsSystemWindows=“true”会使得屏幕上的可布局空间位于状态栏下方与导航栏上方</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><blockquote><p>使用scrollTo方法，当键盘弹起时，让界面整体上移；键盘收起，让界面整体下移<br>使用场景：针对界面全屏或是沉浸式状态栏，输入框不会被键盘遮挡。主要用于一些登录界面，或是需要把界面整体都顶上去的场景。</p></blockquote><h3 id="主要实现步骤"><a href="#主要实现步骤" class="headerlink" title="主要实现步骤"></a>主要实现步骤</h3><ol><li>获取Activity布局xml的最外层控件，如xml文件如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:id=&quot;@+id/main&quot;</span><br><span class="line">    tools:context=&quot;com.example.liubin1.softkeyboardhelper.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id=&quot;@+id/name&quot;</span><br><span class="line">        android:hint=&quot;请输入用户名：&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;50dp&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id=&quot;@+id/pas&quot;</span><br><span class="line">        android:layout_below=&quot;@id/name&quot;</span><br><span class="line">        android:hint=&quot;请输入密码：&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;50dp&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/login_btn&quot;</span><br><span class="line">        android:layout_below=&quot;@id/rpas&quot;</span><br><span class="line">        android:layout_centerHorizontal=&quot;true&quot;</span><br><span class="line">        android:text=&quot;登录&quot;</span><br><span class="line">        android:layout_width=&quot;180dp&quot;</span><br><span class="line">        android:layout_height=&quot;50dp&quot; /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure></li><li>先获取到最外层控件，再获取到最后一个控件，如上面的xml文件，最后一个控件是Button <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RelativeLayout main = (RelativeLayout) findViewById(R.id.main);</span><br><span class="line">Button login_btn = (Button) findViewById(R.id.login_btn);</span><br></pre></td></tr></table></figure></li><li>给最外层控件和最后一个控件添加监听事件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//在Activity的onCreate里添加如下方法</span><br><span class="line">addLayoutListener(main,login_btn);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**   </span><br><span class="line"> * addLayoutListener方法如下</span><br><span class="line"> * @param main 根布局</span><br><span class="line"> * @param scroll 需要显示的最下方View</span><br><span class="line"> */</span><br><span class="line">public void addLayoutListener(final View main, final View scroll) &#123;</span><br><span class="line">main.getViewTreeObserver().addOnGlobalLayoutListener(new  ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onGlobalLayout() &#123;</span><br><span class="line">                Rect rect = new Rect();</span><br><span class="line">                //1、获取main在窗体的可视区域</span><br><span class="line">                main.getWindowVisibleDisplayFrame(rect);</span><br><span class="line">                //2、获取main在窗体的不可视区域高度，在键盘没有弹起时，main.getRootView().getHeight()调节度应该和rect.bottom高度一样</span><br><span class="line">                int mainInvisibleHeight = main.getRootView().getHeight() - rect.bottom;</span><br><span class="line">                int screenHeight = main.getRootView().getHeight();//屏幕高度</span><br><span class="line">                //3、不可见区域大于屏幕本身高度的1/4：说明键盘弹起了</span><br><span class="line">                if (mainInvisibleHeight &gt; screenHeight / 4) &#123;</span><br><span class="line">                    int[] location = new int[2];</span><br><span class="line">                    scroll.getLocationInWindow(location);</span><br><span class="line">                    // 4､获取Scroll的窗体坐标，算出main需要滚动的高度</span><br><span class="line">                    int srollHeight = (location[1] + scroll.getHeight()) - rect.bottom;</span><br><span class="line">                    //5､让界面整体上移键盘的高度</span><br><span class="line">                    main.scrollTo(0, srollHeight);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                //3、不可见区域小于屏幕高度1/4时,说明键盘隐藏了，把界面下移，移回到原有高度</span><br><span class="line">                    main.scrollTo(0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>此方法通过监听Activity最外层布局控件来检测软键盘是否弹出，然后去手动调用控件的scrollTo方法达到调整布局目的。</p><h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>此种方法需要在当前界面写比较多的代码，在某些手机上，若输入时，软键盘高度是可变的，如中英文切换，高度变化时，会发现适配的不大好。如下图：<br><img src="http://dinson-blog.hdinson.cn/FkeMDvMrmpqiAagMm2xTPeIq-nMV.gif" alt=""><br>从上图可以看出，如果键盘高度变化，键盘还是会挡住登录按钮。</p><h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><blockquote><p>适配键盘高度变化情况，当键盘弹起时，让界面整体上移；键盘收起，让界面整体下移<br>此方法主要是通过在需要移动的控件外套一层scrollView，同时最布局最外层使用自定义view监听键盘弹出状态，计算键盘高度，再进行计算需要移动的位置，这个和方法三有点类似，但能适配键盘高度变化情况。</p></blockquote><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>先写自定义View，实时临听界面键盘弹起状态，计算键盘高度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class KeyboardLayout extends FrameLayout &#123;</span><br><span class="line"></span><br><span class="line">    private KeyboardLayoutListener mListener;</span><br><span class="line">    private boolean mIsKeyboardActive = false; //输入法是否激活</span><br><span class="line">    private int mKeyboardHeight = 0; // 输入法高度</span><br><span class="line"></span><br><span class="line">    public KeyboardLayout(Context context) &#123;</span><br><span class="line">        this(context, null, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public KeyboardLayout(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public KeyboardLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        // 监听布局变化</span><br><span class="line">        getViewTreeObserver().addOnGlobalLayoutListener(new KeyboardOnGlobalChangeListener());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeyboardListener(KeyboardLayoutListener listener) &#123;</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public KeyboardLayoutListener getKeyboardListener() &#123;</span><br><span class="line">        return mListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isKeyboardActive() &#123;</span><br><span class="line">        return mIsKeyboardActive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取输入法高度</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int getKeyboardHeight() &#123;</span><br><span class="line">        return mKeyboardHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface KeyboardLayoutListener &#123;</span><br><span class="line">        /**</span><br><span class="line">         * @param isActive       输入法是否激活</span><br><span class="line">         * @param keyboardHeight 输入法面板高度</span><br><span class="line">         */</span><br><span class="line">        void onKeyboardStateChanged(boolean isActive, int keyboardHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class KeyboardOnGlobalChangeListener implements ViewTreeObserver.OnGlobalLayoutListener &#123;</span><br><span class="line"></span><br><span class="line">        int mScreenHeight = 0;</span><br><span class="line"></span><br><span class="line">        private int getScreenHeight() &#123;</span><br><span class="line">            if (mScreenHeight &gt; 0) &#123;</span><br><span class="line">                return mScreenHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            mScreenHeight = ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE))</span><br><span class="line">                    .getDefaultDisplay().getHeight();</span><br><span class="line">            return mScreenHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onGlobalLayout() &#123;</span><br><span class="line">            Rect rect = new Rect();</span><br><span class="line">            // 获取当前页面窗口的显示范围</span><br><span class="line">            ((Activity) getContext()).getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);</span><br><span class="line">            int screenHeight = getScreenHeight();</span><br><span class="line">            int keyboardHeight = screenHeight - rect.bottom; // 输入法的高度</span><br><span class="line">            boolean isActive = false;</span><br><span class="line">            if (Math.abs(keyboardHeight) &gt; screenHeight / 4) &#123;</span><br><span class="line">                isActive = true; // 超过屏幕五分之一则表示弹出了输入法</span><br><span class="line">                mKeyboardHeight = keyboardHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            mIsKeyboardActive = isActive;</span><br><span class="line">            if (mListener != null) &#123;</span><br><span class="line">                mListener.onKeyboardStateChanged(isActive, keyboardHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml文件编写，在界面最外层套上自定义view，在需要滚动的控件外层添加scrollView</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.example.smilexie.softboradblockedittext.util.KeyboardLayout</span><br><span class="line">        android:id=&quot;@+id/main_ll&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:background=&quot;@mipmap/login_bg&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;ScrollView</span><br><span class="line">            android:id=&quot;@+id/login_ll&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;LinearLayout</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">                &lt;LinearLayout</span><br><span class="line">                    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                    android:layout_marginLeft=&quot;50dp&quot;</span><br><span class="line">                    android:layout_marginRight=&quot;50dp&quot;</span><br><span class="line">                    android:layout_marginTop=&quot;200dp&quot;</span><br><span class="line">                    android:background=&quot;@mipmap/login_input_field_icon&quot;</span><br><span class="line">                    android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;ImageView</span><br><span class="line">                        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                        android:layout_gravity=&quot;center_vertical&quot;</span><br><span class="line">                        android:layout_marginLeft=&quot;20dp&quot;</span><br><span class="line">                        android:background=&quot;@mipmap/login_yonghuming_icon&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;EditText</span><br><span class="line">                        android:id=&quot;@+id/ui_username_input&quot;</span><br><span class="line">                        style=&quot;@style/editext_input_style&quot;</span><br><span class="line">                        android:layout_marginLeft=&quot;40dp&quot;</span><br><span class="line">                        android:layout_marginRight=&quot;20dp&quot;</span><br><span class="line">                        android:background=&quot;@null&quot;</span><br><span class="line">                        android:hint=&quot;@string/login_hint_username&quot;</span><br><span class="line">                        android:imeOptions=&quot;actionNext&quot;</span><br><span class="line">                        android:textColor=&quot;@android:color/white&quot;</span><br><span class="line">                        android:textColorHint=&quot;@android:color/white&quot;&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;requestFocus /&gt;</span><br><span class="line">                    &lt;/EditText&gt;</span><br><span class="line">                &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &lt;LinearLayout</span><br><span class="line">                    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                    android:layout_marginLeft=&quot;50dp&quot;</span><br><span class="line">                    android:layout_marginRight=&quot;50dp&quot;</span><br><span class="line">                    android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">                    android:background=&quot;@mipmap/login_input_field_icon&quot;</span><br><span class="line">                    android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;ImageView</span><br><span class="line">                        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">                        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                        android:layout_gravity=&quot;center_vertical&quot;</span><br><span class="line">                        android:layout_marginLeft=&quot;20dp&quot;</span><br><span class="line">                        android:background=&quot;@mipmap/login_mima_icon&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &lt;EditText</span><br><span class="line">                        android:id=&quot;@+id/ui_password_input&quot;</span><br><span class="line">                        style=&quot;@style/editext_input_style&quot;</span><br><span class="line">                        android:layout_marginLeft=&quot;40dp&quot;</span><br><span class="line">                        android:layout_marginRight=&quot;20dp&quot;</span><br><span class="line">                        android:background=&quot;@null&quot;</span><br><span class="line">                        android:hint=&quot;@string/login_hint_pwd&quot;</span><br><span class="line">                        android:imeOptions=&quot;actionDone&quot;</span><br><span class="line">                        android:inputType=&quot;textPassword&quot;</span><br><span class="line">                        android:textColor=&quot;@android:color/white&quot;</span><br><span class="line">                        android:textColorHint=&quot;@android:color/white&quot;&gt;&lt;/EditText&gt;</span><br><span class="line">                &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">                &lt;Button</span><br><span class="line">                    android:id=&quot;@+id/login_btn&quot;</span><br><span class="line">                    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">                    android:layout_marginLeft=&quot;50dp&quot;</span><br><span class="line">                    android:layout_marginRight=&quot;50dp&quot;</span><br><span class="line">                    android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">                    android:background=&quot;@mipmap/login_button_bg_icon&quot;</span><br><span class="line">                    android:text=&quot;@string/login&quot;</span><br><span class="line">                    android:textColor=&quot;@color/titlebar_main_color&quot;</span><br><span class="line">                    android:textSize=&quot;@dimen/font_normal&quot; /&gt;</span><br><span class="line">            &lt;/LinearLayout&gt;</span><br><span class="line">        &lt;/ScrollView&gt;</span><br><span class="line">&lt;/com.example.smilexie.softboradblockedittext.util.KeyboardLayout&gt;</span><br></pre></td></tr></table></figure></li><li><p>Activity调用，自定义view控件添加键盘响应，在键盘变化时调用scrollView的smoothScrollTo去滚动界面</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 监听键盘状态，布局有变化时，靠scrollView去滚动界面</span><br><span class="line"> */</span><br><span class="line">public void addLayoutListener() &#123;</span><br><span class="line">    bindingView.mainLl.setKeyboardListener(new  KeyboardLayout.KeyboardLayoutListener() &#123;</span><br><span class="line">       @Override</span><br><span class="line">            public void onKeyboardStateChanged(boolean isActive, int keyboardHeight) &#123;</span><br><span class="line">                Log.e(&quot;onKeyboardStateChanged&quot;, &quot;isActive:&quot; + isActive + &quot; keyboardHeight:&quot; + keyboardHeight);</span><br><span class="line">                if (isActive) &#123;</span><br><span class="line">                    scrollToBottom();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 弹出软键盘时将SVContainer滑到底</span><br><span class="line">     */</span><br><span class="line">    private void scrollToBottom() &#123;</span><br><span class="line"></span><br><span class="line">        bindingView.loginLl.postDelayed(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                bindingView.loginLl.smoothScrollTo(0, bindingView.loginLl.getBottom() + SoftKeyInputHidWidget.getStatusBarHeight(LoginActivityForDiffkeyboardHeight.this));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现代码见demo中的LoginActivityForDiffkeyboardHeight类。实现效果如下：<br><img src="http://dinson-blog.hdinson.cn/Fprl5ny3iQ-8LXr6R_IOJNDsDlxY.gif" alt=""><br>可以看到键盘高度变化了，也不会影响界面布局</p><h2 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h2><blockquote><p>监听Activity顶层View，判断软键盘是否弹起，对界面重新绘制<br>使用场景：针对界面全屏或是沉浸式状态栏，界面包含比较多输入框，界面即使包裹了一层ScrollView,在键盘显示时，当前输入框下面的输入不能通过上下滑动界面来输入。</p></blockquote><h3 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>把SoftHideKeyBoardUtil类复制到项目中； </li><li>在需要使用的Activity的onCreate方法中添加：SoftHideKeyBoardUtil.assistActivity(this);即可。</li></ol><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>SoftHideKeyBoardUtil类具体代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 解决键盘档住输入框</span><br><span class="line"> * Created by SmileXie on 2017/4/3.</span><br><span class="line"> */</span><br><span class="line">public class SoftHideKeyBoardUtil &#123;</span><br><span class="line">    public static void assistActivity (Activity activity) &#123;</span><br><span class="line">        new SoftHideKeyBoardUtil(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    private View mChildOfContent;</span><br><span class="line">    private int usableHeightPrevious;</span><br><span class="line">    private FrameLayout.LayoutParams frameLayoutParams;</span><br><span class="line">    //为适应华为小米等手机键盘上方出现黑条或不适配</span><br><span class="line">    private int contentHeight;//获取setContentView本来view的高度</span><br><span class="line">    private boolean isfirst = true;//只用获取一次</span><br><span class="line">    private  int statusBarHeight;//状态栏高度</span><br><span class="line">    private SoftHideKeyBoardUtil(Activity activity) &#123;</span><br><span class="line">   //1､找到Activity的最外层布局控件，它其实是一个DecorView,它所用的控件就是FrameLayout</span><br><span class="line">        FrameLayout content = (FrameLayout) activity.findViewById(android.R.id.content);</span><br><span class="line">        //2､获取到setContentView放进去的View</span><br><span class="line">        mChildOfContent = content.getChildAt(0);</span><br><span class="line">        //3､给Activity的xml布局设置View树监听，当布局有变化，如键盘弹出或收起时，都会回调此监听  </span><br><span class="line">          mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">        //4､软键盘弹起会使GlobalLayout发生变化</span><br><span class="line">            public void onGlobalLayout() &#123;</span><br><span class="line">            if (isfirst) &#123;</span><br><span class="line">                    contentHeight = mChildOfContent.getHeight();//兼容华为等机型</span><br><span class="line">                    isfirst = false;</span><br><span class="line">                &#125;</span><br><span class="line">                //5､当前布局发生变化时，对Activity的xml布局进行重绘</span><br><span class="line">                possiblyResizeChildOfContent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //6､获取到Activity的xml布局的放置参数</span><br><span class="line">        frameLayoutParams = (FrameLayout.LayoutParams) mChildOfContent.getLayoutParams();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取界面可用高度，如果软键盘弹起后，Activity的xml布局可用高度需要减去键盘高度  </span><br><span class="line">    private void possiblyResizeChildOfContent() &#123;</span><br><span class="line">        //1､获取当前界面可用高度，键盘弹起后，当前界面可用布局会减少键盘的高度</span><br><span class="line">        int usableHeightNow = computeUsableHeight();</span><br><span class="line">        //2､如果当前可用高度和原始值不一样</span><br><span class="line">        if (usableHeightNow != usableHeightPrevious) &#123;</span><br><span class="line">            //3､获取Activity中xml中布局在当前界面显示的高度</span><br><span class="line">            int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();</span><br><span class="line">            //4､Activity中xml布局的高度-当前可用高度</span><br><span class="line">            int heightDifference = usableHeightSansKeyboard - usableHeightNow;</span><br><span class="line">            //5､高度差大于屏幕1/4时，说明键盘弹出</span><br><span class="line">            if (heightDifference &gt; (usableHeightSansKeyboard/4)) &#123;</span><br><span class="line">                // 6､键盘弹出了，Activity的xml布局高度应当减去键盘高度</span><br><span class="line">                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT)&#123;</span><br><span class="line">                    frameLayoutParams.height = usableHeightSansKeyboard - heightDifference + statusBarHeight;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                frameLayoutParams.height = contentHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            //7､ 重绘Activity的xml布局</span><br><span class="line">            mChildOfContent.requestLayout();</span><br><span class="line">            usableHeightPrevious = usableHeightNow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private int computeUsableHeight() &#123;</span><br><span class="line">        Rect r = new Rect();</span><br><span class="line">        mChildOfContent.getWindowVisibleDisplayFrame(r);</span><br><span class="line">        // 全屏模式下：直接返回r.bottom，r.top其实是状态栏的高度</span><br><span class="line">        return (r.bottom - r.top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>( 1 ) 找到Activity的最外层布局控件，我们知道所有的Activity都是DecorView，它就是一个FrameLayout控件，该控件id是系统写死叫R.id.content，就是我们setContentView时，把相应的View放在此FrameLayout控件里<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FrameLayout content = (FrameLayout) activity.findViewById(android.R.id.content);</span><br></pre></td></tr></table></figure><br>所以content.getChildAt(0)获取到的mChildOfContent，也就是我们用setContentView放进去的View。 </p><p>( 2 ) 给我们的Activity的xml布局View设置一个Listener监听<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(&#123; </span><br><span class="line">        possiblyResizeChildOfContent();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>View.getViewTreeObserver()可以获取一个ViewTreeObserver对象——它是一个观察者，用以监听当前View树所发生的变化。这里所注册的addOnGlobalLayoutListener，就是会在当前的View树的全局布局（GlobalLayout）发生变化、或者其中的View可视状态有变化时，进行通知回调。『软键盘弹出/隐 』都能监听到。</p><p>( 3 ) 获取当前界面可用高度<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private int computeUsableHeight() &#123;</span><br><span class="line">    Rect rect = new Rect();</span><br><span class="line">    mChildOfContent.getWindowVisibleDisplayFrame(rect);</span><br><span class="line">    // rect.top其实是状态栏的高度，如果是全屏主题，直接 return rect.bottom就可以了</span><br><span class="line">    return (rect.bottom - rect.top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如下图所示：<br><img src="http://dinson-blog.hdinson.cn/Fu0LdpFKY1wxCoC-_00ybugeipUu.png" alt=""></p><p>( 4 ) 重设高度， 我们计算出的可用高度，是目前在视觉效果上能看到的界面高度。但当前界面的实际高度是比可用高度要多出一个软键盘的距离的。</p><p>注意：如果既使用了沉浸式状态栏，又加了fitSystetemWindow=true属性，就需要在AndroidMainfest.xml注册Activity的地方添加上以下属性。因为你两种都用，系统不知道用哪种了。fitSystetemWindow已经有resize屏幕的作用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面对上面几种方法进行对比：</p><ul><li><p>方法一：优点：使用简单，只需在Activity的AndroidMainfest.xml中设置windowSoftInput属性即可。<br>注意点：adjustResize属性必须要界面大小可以自身改变；<br>缺点：当输入框比较多时，当前输入框下方的输入框会初键盘挡住，须收起键盘再进入输入；使用adjustPan，输入框较多时，因它是把界面当成一个整体，只会显示一屏的高度，会把ActionBar顶上去。</p></li><li><p>方法二：优点：使用简单，只需在Activity的最外层布局包裹一个ScrollView即可。<br>注意点：不可使用adjustPan属性，否则ScrollView失效；<br>缺点：对于全屏时，在键盘显示时，无法上下滑动界面达到输入的目的；</p></li><li><p>方法三：优点：可以解决全屏时，键盘挡入按钮问题。<br>缺点：只要有此需求的Activity均需要获取到最外层控件和最后一个控件，监测键盘是否弹出，再调用控件的scrollTo方法对界面整体上移或是下移。代码冗余。对于键盘高度变化时，适配不好。</p></li><li><p>方法四：优点：可以解决全屏时，键盘挡入按钮问题。<br>缺点：只要有此需求的Activity均需要获取到最外层控件和最后一个控件，布局多出一层。</p></li><li><p>方法五：优点：可以解决全屏时，键盘挡入输入框问题。只需要写一个全局类，其他有需求的界面直接在onCreate方法里调用此类的全局方法，即可。<br>缺点：多用了一个类。</p></li></ul><p>综上所述： </p><ol><li>当输入框比较少时，界面只有一个输入框时，可以通过方法一设置adjustPan； </li><li>如果对于非全屏/非沉浸式状态栏需求，只需要使用方法二ScrollView+adjustResize； </li><li>如果对于使用沉浸式状态栏，使用fitSystemWindow=true属性，按道理android系统已经做好适配，键盘不会挡住输入框； </li><li>如果全屏/沉浸式状态栏界面，类似于登录界面，有需要把登录键钮或是评论按钮也顶起，如果键盘没有变化需求，可以使用方法三，若需要适配键盘高度变化，则需要使用方法四； </li><li>如果界面使用全屏或沉浸式状态栏，没有使用fitSystemWindow=true属性，一般如需要用到抽屈而且状态栏颜色也需要跟着变化，则选择方法五更恰当。</li></ol><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=4154790&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android软键盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android双缓冲绘图技术分析</title>
      <link href="/2017/05/09/17-05-09/"/>
      <url>/2017/05/09/17-05-09/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>双缓冲、多缓冲技术在计算机科学中其实是一个广义的概念，不过其本质上的意思都是差不多的。今天我们就来讲一讲双缓冲技术在android绘图中的应用。所谓的双缓冲技术其实就是当程序需要在指定的View上进行绘制时，程序并不需要直接绘制到该View组件，而是先绘制到一个内存中的Bitmap图片上（就是缓冲），等内存中的Bitmap绘制好之后，再一次性将Bitmap绘制到View组件上。当进行复杂的绘制操作时会导致呈现的图像闪烁或具有 其他不可接受的外观。双缓冲的使用解决这些问题。双缓冲使用内存缓冲区来解决由多重 绘制操作造成的闪烁问题。当使用双缓冲时，首先在内存缓冲区里完成所有绘制操作，而 不是在屏幕上直接进行绘图。当所有绘制操作完成后，把内存缓冲区完成的图像直接复制 到屏幕。因为在屏幕上只执行一个图形操作，所以消除了由复杂绘制操作造成的图像闪烁 问题。</p></blockquote><span id="more"></span><h2 id="Android绘图中的双缓冲"><a href="#Android绘图中的双缓冲" class="headerlink" title="Android绘图中的双缓冲"></a>Android绘图中的双缓冲</h2><p>我们知道，我们在绘图时有两样东西是少不了的，一个是Canvas（画布），一个是Paint(画笔）。Canvas提供画各种图形的方法，如画圆（drawCircle)，画矩形（drawRect）等等，Paint用来设置画笔的样式，比如笔的粗细，颜色等。每个Canvas内部持有一个Bitmap对象的引用，画图的过程其实就是往这个Bitmap当中写入ARGB信息。<br>比如我们现在自定义一个View,在上面画一个矩形和一个圆：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">canvas.drawRect(rect,mPaint);</span><br><span class="line">canvas.drawCircle(cx,cy,100,mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么现在有一个问题，画矩形和画圆是两个独立的动作，会不会在drawRect执行完之后屏幕上马上就会显示出来一个矩形呢？<br>为了验证我们的猜想，我们在两个绘图动作中加一个sleep:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">canvas.drawRect(rect,mPaint);</span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(2000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">canvas.drawCircle(cx,cy,100,mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们会看到，并不是先显示矩形再显示圆，而是两个几乎同时一起显示出来的。这就说明必须要等onDraw方法执行完成之后，才会把数据交给GPU去处理展示。这就是android绘图当中的第一道缓冲，即显示缓冲区。</p><p>而所谓的双缓冲，在android绘图中其实就是再创建一个Canvas和对应的Bitmap，然后在onDraw方法里默认的Canvas通过drawBitmap画刚才new的那个bitmap从而实现双缓冲。用代码简单的表述是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void init()&#123;</span><br><span class="line">    Bitmap bufferBm = Bitmap.create(getWidth,getHeight,Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas bufferCanvas = new Canvas(bufferBm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void drawSomething()&#123;</span><br><span class="line">    bufferCanvas.drawRect();</span><br><span class="line">    bufferCanvas.drawCircle();</span><br><span class="line">    ...</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    canvas.drawBitmap(bufferBm,0,0,null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>示意图：<br><img src="http://dinson-blog.hdinson.cn/FjYCnjDP3ixkk0ZniR2-KFHD4eGi.png" alt=""></p><h2 id="双缓冲绘图的优缺点及适用场景"><a href="#双缓冲绘图的优缺点及适用场景" class="headerlink" title="双缓冲绘图的优缺点及适用场景"></a>双缓冲绘图的优缺点及适用场景</h2><p>我们通过一个例子来说明。<br>实现这样一个功能，一个自定义View,每次点击的时候在点击处画一个圆。我们先不使用双缓冲来实现：</p><ul><li>不用双缓冲的代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class MyView extends View&#123;</span><br><span class="line"></span><br><span class="line">    private Paint mPaint;</span><br><span class="line">    private List&lt;Point&gt; mPoints;</span><br><span class="line"></span><br><span class="line">    public MyView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);</span><br><span class="line">        mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        mPaint.setColor(Color.GREEN);</span><br><span class="line">        setBackgroundColor(Color.WHITE);</span><br><span class="line">        mPoints = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        int action = event.getAction();</span><br><span class="line">        switch (action)&#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                mPoints.add(new Point((int)event.getX(),(int)event.getY()));</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                invalidate();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        for (Point p : mPoints) &#123;</span><br><span class="line">            canvas.drawCircle(p.x,p.y,50,mPaint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在实验之前，我们先打开开发者选项里的”GPU呈现模式分析“，设置为“在屏幕上显示为条形图”。可以看到，当画的圆数目比较少时，GPU的负荷较低，但是出现一个逐步上升的趋势：<br><img src="http://dinson-blog.hdinson.cn/FqUK07_35kXMCMkICr4rhu2YQIvD.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FkxoIY31BZ0xVhm9r1GZXOf66qKg.png" alt=""></li></ul><p>当画的圆数目增加到比较大时，GPU负荷有点惨不妨睹了：<br><img src="http://dinson-blog.hdinson.cn/Ft4kjiraYoIF9GysLMRPNYFpNdrc.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/Fgthd-vIMt0Lbc_jdyx8sJxuPhcD.png" alt=""></p><ul><li>我们现在改用双缓冲来绘图，代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class MyView extends View&#123;</span><br><span class="line"></span><br><span class="line">    private Paint mPaint;</span><br><span class="line">    private Canvas mBufferCanvas;</span><br><span class="line">    private Bitmap mBufferBitmap;</span><br><span class="line"></span><br><span class="line">    public MyView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);</span><br><span class="line">        mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        mPaint.setColor(Color.GREEN);</span><br><span class="line">        setBackgroundColor(Color.WHITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        int action = event.getAction();</span><br><span class="line">        switch (action)&#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                if (mBufferBitmap == null) &#123;</span><br><span class="line">                    mBufferBitmap = Bitmap.createBitmap(getWidth(),getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">                    mBufferCanvas = new Canvas(mBufferBitmap);</span><br><span class="line">                &#125;</span><br><span class="line">                mBufferCanvas.drawCircle((int)event.getX(),(int)event.getY(),50,mPaint);</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                invalidate();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        if (mBufferBitmap == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.drawBitmap(mBufferBitmap,0,0,null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>使用双缓冲，在数量较小时的GPU使用情况是这样的：<br><img src="http://dinson-blog.hdinson.cn/FqdunQxqjgDDyO1Y5a6wXJO4NiJi.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FmLMpDHp359u2m-LX67kNEaViR0D.png" alt=""></li></ul><p>使用双缓冲，在数量非常大的时候，GPU使用情况是这样的：<br><img src="http://dinson-blog.hdinson.cn/FtmsmsWOtLxCv9ZuBos1HVAxIir9.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/Fj_TW47YAjMiSJTIgCAtRnApTv5_.png" alt=""></p><p>从上面的实验数据我们可以得出结论：</p><ul><li>在绘制数据量较小时，不使用双缓冲，GPU的负荷更低，即绘制性能更高；</li><li>在绘制数据量较大时，使用双缓冲绘图，绘制性能明显高于不使用双缓冲的情况；</li><li>使用双缓冲会增加内存消耗。</li></ul><p>其实上面的结论也很好理解，就像上面举的搬砖的例子，如果砖少的话，用车来拉明显是划不来的，砖的数量很多的时候，用车来拉就可以节省很多时间，但是用车就要消耗额外的资源，这就需要根据不同的情况做出正确的选择。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=2526613&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> 自定义控件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你真的了解SharedPreferences吗？</title>
      <link href="/2017/05/08/17-05-08/"/>
      <url>/2017/05/08/17-05-08/</url>
      
        <content type="html"><![CDATA[<h2 id="SharedPreferences踩坑"><a href="#SharedPreferences踩坑" class="headerlink" title="SharedPreferences踩坑"></a>SharedPreferences踩坑</h2><blockquote><p>在日常开发中SharedPreferences想必肯定是经常被我们使用的了，通常情况下使用它并不会发生什么问题，但是假如遇到了在不同进程中使用SharedPreferences（例如指定了process的activity/service），那坑就来了。</p></blockquote><span id="more"></span><p>这里我们可以实验一下，创建两个Activity，在AndroidManifest其中一个将其process指定为second进程</p><p><img src="http://dinson-blog.hdinson.cn/Fhv03YDAqb37rRk1FWWGv-fyvmsN.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/Fobj0jcsuu1wYcODuqLR49DgDDFj.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FufFaJXxAFaPYmQbS5MqVKue-IzK.png" alt=""></p><p>代码比较简单，就是将输入框的内容存入到SharedPreferences中，并显示到TextView上，点击跳转按钮跳转到SecondActivity<br><img src="http://dinson-blog.hdinson.cn/Fo2znhVgjpF8V3xIm3ongiFU9KrY.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FiaPwAVp3_Ce5qAJ8FbniDgNU1Zc.png" alt=""></p><p>SecondActivity就是点击按钮获取SharedPreferences的值并显示到TextView，不过这里要注意它是运行在不同的进程中的。<br><img src="http://dinson-blog.hdinson.cn/FhMLVx8S6Oaul-hMY7ORp4iNYYLP.png" alt=""></p><p>这里我们将值改为hello，然后点击修改，可以看到SharedPreferences的值已经改成功了。</p><p>然后我们跳转到SecondActivity并获取值，<br><img src="http://dinson-blog.hdinson.cn/Fsd7m-sUEmjdUWtWeykZrhoXedTU.png" alt=""></p><p>一切正常，好现在我们回到MainActivity，并再次修改SharedPreferences中的值，<br><img src="http://dinson-blog.hdinson.cn/FpLCVsm2nu14bNeSUKYC7LbXvfGS.png" alt=""></p><p>可以看到SharedPreferences的值已经再次被修改成功，这时我们再跳转到SecondActivity并获取值，<br><img src="http://dinson-blog.hdinson.cn/Fo32ZpcZ9M3arNwdAgyQ-KgIKfna.png" alt=""></p><p>不管怎么获取都是之前的值，然后重启app，再进入SecondActivity，便又能获取到正确的值了。<br><img src="http://dinson-blog.hdinson.cn/FlO8FVy_A5NO-2oWgQE1m4ey_y7U.png" alt=""><br>-SecondActivity(重启app后)-</p><p>这里我们先总结一下结论</p><ul><li>先启动主进程并获取SharedPreferences对象，然后启动其他进程并获取SharedPreferences对象，那么此时对SharedPreferences的数值进行修改均不能对其他进程产生作用。</li><li>先启动主进程并获取SharedPreferences对象，然后对值进行修改，然后启动其他进程并获取SharedPreferences对象，能取得修改后的值，但此时如果再对此值进行修改，均不能对其他进程产生作用。</li></ul><p>总结下来就是，其他进程在启动时获取到的SharedPreferences的值只能是这个进程启动前这个值的最后值，即在进程启动后对值的修改只对当前进程有效，须等到进程重启或者app重启才能与其他进程进行“同步”。</p><p>这里<strong>即使把获取SharedPreferences对象的模式改为MODE_MULTI_PROCESS，也仅仅是在Android 3.0以下才有效，在Android 3.0以上也是一样不行的。</strong></p><p>那么为什么会这样子呢，笔者带大家从源码的角度来分析一下，我们来看一下关于SharedPreferences的源码。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>通常我们获取SharedPreferences对象一般是这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//或者这样</span></span><br><span class="line">SharedPreferences sharedPreferences = getSharedPreferences(<span class="string">&quot;name&quot;</span>, Context.MODE_PRIVATE);</span><br></pre></td></tr></table></figure></p><p>实际上PreferenceManager.getDefaultSharedPreferences(context)方法也是对getSharedPreferences做了封装</p><p><img src="http://dinson-blog.hdinson.cn/FvywJ70yizMOhfF3aaqGv2vpojew.png" alt=""></p><p>所以不管通过哪种方式，最终都是通过Context中的getSharedPreferences方法来获取SharedPreferences对象，在Context中，getSharedPreferences方法是一个抽象方法，没有具体实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract SharedPreferences </span><br><span class="line">            getSharedPreferences(<span class="built_in">String</span> name, int mode);</span><br></pre></td></tr></table></figure></p><p>我们知道Context的实现类其实就是ContextImpl，所以这里我们直接去到ContextImpl的getSharedPreferences方法中，<br><img src="http://dinson-blog.hdinson.cn/FvnQplSy9iuRj4G-AdhNU3jApBRS.png" alt=""></p><p>这里比较简单，先判断了ArrayMap中是否存在该File对象，不存在则创建一个并放入ArrayMap，然后调用getSharedPreferences的重载方法getSharedPreferences(file, mode)，我们看一下这个方法的源码<br><img src="http://dinson-blog.hdinson.cn/FudqaDKO4sr06vuTurN5IHzJq5a0.png" alt=""></p><p>可以看到，这里将SharedPreferences的实例对象SharedPreferencesImpl缓存起来，以后每次获取如果内存中已经存在那么直接返回，如果不存在才会进行重新创建;</p><p>那么这里我们可以有个猜想，即是否只有在创建SharedPreferences对象的时候才会从磁盘中进行读取，读取后的值保存在了内存中，获取SharedPreferences对象优先从缓存中获取，再次创建时才会重新从磁盘中再次读取文件。</p><p>我们直接看一下SharedPreferencesImpl的源码，验证一下我们的猜想。<br><img src="http://dinson-blog.hdinson.cn/FoBTygVx4rT-JlInHmhTXGSzK7Pd.png" alt=""></p><p>可以看到，在SharedPreferencesImpl的构造方法中调用了startLoadFromDisk，startLoadFromDisk方法中开启了一个线程加载磁盘中的文件，loadFromDisk源码如下<br><img src="http://dinson-blog.hdinson.cn/FteY8ItDC7WESvhix2ob3oIM5wAK.png" alt=""></p><p>看到这里，已经逐步验证了我们之前的猜想，在构造方法中读取了磁盘文件的内容并赋值给了成员变量mMap集合，我们只需要看看所有的get方法是不是从mMap成员变量中获取值就能完全验证我们的猜想是否正确，因为get方法都大同小异，所以我们就只分析一下getString方法就可以了。<br><img src="http://dinson-blog.hdinson.cn/Fp848IwmUi2p-UpRmBfCADLmnUtj.png" alt=""></p><p>可以看到，果然是这样的，从mMap集合中直接取出值进行返回，那么看到这里肯定会有个疑问，为什么在同个进程却又没有问题呢，或者其他进程对SharedPreferences的获取在值修改完毕之后也没有问题，这里我们看一下SharedPreferencesImpl的内部类EditorImpl的源码，EditorImpl是Editor的实现类。<br><img src="http://dinson-blog.hdinson.cn/FsnC_5x72iexCxpU7_w6p1A01f5D.png" alt=""></p><p>可以看到，EditorImpl内部有一个mModified的Map成员变量，我们所有的修改在调用了commit或者apply方法后才会执行保存，可以看到，不管调用哪个方法都会调用commitToMemory()和enqueueDiskWrite方法，那么我们看一下这两个方法的源码<br><img src="http://dinson-blog.hdinson.cn/FtvV2I3jnenZxTJeCv6J-twW7eQy.png" alt=""></p><p>其实通过方法名我们也可以猜到，就是将值提交到内存，从代码上也可以看出来，就是将Editor的所有put进去的值添加到SharedPreferences的mMap成员变量中。</p><p>那么最后将内容写入磁盘的方法就是enqueueDiskWrite了，我们看一下它的源码<br><img src="http://dinson-blog.hdinson.cn/FijRzuJIAO3jXq0PrHwylN1NAASG.png" alt=""></p><p>源码比较简单，其中最主要的就是区分了apply方法调用和commit的调用,apply调用的话会将写入磁盘的任务加入到一个线程池中在后台运行，直接commit的话则会在当前线程进行写入。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个获取SharedPreferences对象过程的流程图如下<br><img src="http://dinson-blog.hdinson.cn/FpnUPmqHC5RdoGU_HabRZXbQ4aip.png" alt=""></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=16686122&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SharedPreferences </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全世界最著名的 icons 网站都在这了</title>
      <link href="/2017/05/05/17-05-05/"/>
      <url>/2017/05/05/17-05-05/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>分享几个高逼格，免费的icons网站</p></blockquote><span id="more"></span><h2 id="icons8"><a href="#icons8" class="headerlink" title="icons8"></a>icons8</h2><p><img src="http://dinson-blog.hdinson.cn/FgagQPjcElDhzpQ0xc9QuOmY2YZU.png" alt=""><br><a href="https://icons8.com/">icons8：</a>拥有 48,900 个免费图标，提供各个平台的基础图标与分类图标，其特色是大小和颜色随意自定义。 </p><h2 id="iconfinder"><a href="#iconfinder" class="headerlink" title="iconfinder"></a>iconfinder</h2><p><img src="http://dinson-blog.hdinson.cn/FmkrERamIL5tyHCN8RMfKb3WrB_q.png" alt=""><br><a href="https://www.iconfinder.com/">iconfinder：</a>哥本哈根一个团队做的 icon 专业图标网站，拥有 1,667,626 个图标和 40,113 图标集，是最专业的 icon 图标网站之一。</p><h2 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h2><p><img src="http://dinson-blog.hdinson.cn/FpXxLtfKf4u2-mGev-qLrzhI0zXt.png" alt=""><br><a href="http://iconfont.cn/">iconfont：</a>国内功能很强大且图标内容很丰富的矢量图标库,提供矢量图标下载、在线存储、格式转换等功能，是阿里妈妈 MUX 组业余时间做的的矢量图标管理、交流平台。</p><h2 id="Font-Awesome"><a href="#Font-Awesome" class="headerlink" title="Font-Awesome"></a>Font-Awesome</h2><p><img src="http://dinson-blog.hdinson.cn/FvqWqkLBNsi2ZlvOKaK7oPRlE7H2.png" alt=""><br><a href="http://fontawesome.io/">Font-Awesome：</a>一套专门为 Twitter Boostrap 设计的图标字体库。这套图标字体集几乎囊括了网页中可能用到的所有图标，除了包括 Twitter Boostrap 的默认图标外，还有社交网络图标、Web 应用程序图标和编辑器图标等等，可以免费用于商业项目。</p><h2 id="iconstore"><a href="#iconstore" class="headerlink" title="iconstore"></a>iconstore</h2><p><img src="http://dinson-blog.hdinson.cn/FvE9rxkw3oN3NYaWUrrhySmoAFR0.png" alt=""><br><a href="https://iconstore.co/">iconstore：</a>Icon Store 提供高质量的免费的/收费的图标，包括卡通风格图标，极简主义图标，扁平化设计风格图标，手绘风格图标，像素风格图标等等，也包括各种类型主题图标，比如圣诞节主题图标，情人节主题图标，天气图标，办公室图标,动物图标，美容美发图标等等。</p><h2 id="Material-icons"><a href="#Material-icons" class="headerlink" title="Material icons"></a>Material icons</h2><p><img src="http://dinson-blog.hdinson.cn/FinrvrujnuCMQpTBYGnyInazNC2J.png" alt=""><br><a href="https://material.io/icons/">Material icons：</a>Google 官方的扁平化图标手册，收集了多达10,000+图标，包括了网页，排版，音频，商务等等主题的绝大多数图标。格式包括SVG,PNG,ICON,以及字体图标，你可以在网页中轻松引用图标。</p><h2 id="swifticons"><a href="#swifticons" class="headerlink" title="swifticons"></a>swifticons</h2><p><img src="http://dinson-blog.hdinson.cn/FhBcgyetvVUy3wzrSJJMD9a57PQd.png" alt=""><br><a href="https://www.swifticons.com/">swifticons：</a>覆盖 20 个大类包含 2,264 个高质量图标</p><h2 id="flat-icon-design"><a href="#flat-icon-design" class="headerlink" title="flat-icon-design"></a>flat-icon-design</h2><p><img src="http://dinson-blog.hdinson.cn/Flmo9pR-2DYI_oKg9DI-3fJufTew.png" alt=""><br><a href="http://flat-icon-design.com/">flat-icon-design：</a>一个日本的免费扁平化设计图示网站，总数量大约有 500 个左右！网站提供的图示风格设计都很简约、可爱，非常适合使用于网页设计、应用程序开发或投影片报告，而且这些图示明确标示为「可以作为商业用途」，网站开放 Illustrator AI、EPS、JPEG、PNG 和 SVG 五种格式下载。</p><h2 id="Noun-Project"><a href="#Noun-Project" class="headerlink" title="Noun Project"></a>Noun Project</h2><p><img src="http://dinson-blog.hdinson.cn/Fgy4KZ0iiSCB2U4G3LoNz7yhuBKg.png" alt=""><br><a href="https://thenounproject.com/">Noun Project：</a>国外三位设计师 2010 创建一个收录、并可免费使用高清符号图示的媒体库，包含25个语言版本，每天都有来自世界各地的设计师提交新 icon。</p><h2 id="Flaticon"><a href="#Flaticon" class="headerlink" title="Flaticon"></a>Flaticon</h2><p><img src="http://dinson-blog.hdinson.cn/FqW2k1l7XItrd4rFB4OGORpJL-Mp.png" alt=""><br><a href="http://www.flaticon.com/">Flaticon：</a>搜索海量扁平化图标，让图标搜索和转换变得非常简单和快速，并提供常用格式 SVG、PSD 源文件和 PNG 下载。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=28828120&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> UI设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI </tag>
            
            <tag> 设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio 打包时Signature Version V1 V2</title>
      <link href="/2017/04/18/17-04-18/"/>
      <url>/2017/04/18/17-04-18/</url>
      
        <content type="html"><![CDATA[<p>前几天更新了一下Android Studio ,今天在打正式包的时候发现多了个签名版本选择：<br><img src="http://dinson-blog.hdinson.cn/FnDLFoLyOmCbSA460u26Q0cvUlnl.png" alt=""></p><p>从图中可以看到多了签名版本的选择，因为刚开始默认勾选的v2(Full APK Signature)，没多想一路下一步下去，<br>结果在测试机上（5.0.1）一直都安装失败，想着和那个选择签名版本有关系，那就查查吧。<br><span id="more"></span></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>Android 7.0中引入了APK Signature Scheme v2，v1呢是jar Signature来自JDK</p></blockquote><p>V1：应该是通过ZIP条目进行验证，这样APK 签署后可进行许多修改，可以移动甚至重新压缩文件。<br>V2：验证压缩文件的所有字节，而不是单个 ZIP 条目，因此，在签名后无法再更改(包括 zipalign)。正因如此，现在在编译过程中，我们将压缩、调整和签署合并成一步完成。好处显而易见，更安全而且新的签名可缩短在设备上进行验证的时间（不需要费时地解压缩然后验证），从而加快应用安装速度。</p><h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h2><p>v1和v2的签名使用<br>只勾选v1签名并不会影响什么，但是在7.0上不会使用更安全的验证方式<br>只勾选V2签名7.0以下会直接安装完显示未安装，7.0以上则使用了V2的方式验证<br><strong>同时勾选</strong>V1和V2则所有机型都没问题</p><h2 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h2><p>在app的build.gradle的android标签下加入如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;  </span><br><span class="line">    debug &#123;  </span><br><span class="line">        v1SigningEnabled true  </span><br><span class="line">        v2SigningEnabled true  </span><br><span class="line">    &#125;  </span><br><span class="line">    release &#123;  </span><br><span class="line">        v1SigningEnabled true  </span><br><span class="line">        v2SigningEnabled true  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=32752246&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android庶系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AS </tag>
            
            <tag> 签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minimum supported Gradle version is 3.3. Current version is 2.14.1</title>
      <link href="/2017/04/17/17-04-17/"/>
      <url>/2017/04/17/17-04-17/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近gradle更新到了3.3，studio 每次重新进入项目都会提醒更新，于是手贱便点击了update。点击更新后发现我的项目就瘫痪了，但是打开其他的项目发现并没有出现什么问题。结果就是自己挖的坑把自己埋了一天半，在这记录一下</p></blockquote><p>首先要搞懂两个概念，<strong>gradle版本</strong>和<strong>gradle插件版本</strong>，比如我现在as升级到了2.3，那么2.3就是gradle版本，2.14.1就是gradle插件版本，这两个概念的一一对应的，而之所以出现这个报错信息，就是因为当前项目的gradle插件版本是2.14.1，而gradle2.3对应的插件版本就是3.3，所以导致了报错。（gradle2.2.3对应的插件版本是2.14.1）<br>那应该怎么解决呢？</p><span id="more"></span><p>首先我们先查看一下gradle版本，打开根目录的build.gradle文件，框选的即为当前项目的gradle版本<br><img src="http://dinson-blog.hdinson.cn/FsOv-qbTsgOI6NcyEw_sBGkXUPJ_.png" alt=""></p><p>再来看一下gradle插件版本，打开gradle/wrapper/gradle-wrapper.properties文件，框选的即为gradle插件版本<br><img src="http://dinson-blog.hdinson.cn/Fp365p4680YEk2KjrSSR_Jycf5w-.png" alt=""></p><p>这里我们是修改了gradle版本，即在build.gradle中把2.3改为了2.2.0，当然我们也可以修改gradle插件的版本，在gradle-wrapper.properties文件中把2.14.1改为3.3，这时候联网下载gradle3.3插件的时候会非常慢，其实我们可以直接从网上下载好对应的gradle-3.3-all.zip包，然后直接放在C:\Users\用户名.gradle\wrapper\dists\gradle-3.3-all\xxxxxxxxxxxxxx文件下（这里注意不要解压缩），然后重新编译就可以了~</p><p>对应关系<br><img src="http://dinson-blog.hdinson.cn/FtyUo8siEM3laLZaxDwwaMJgGvNW.png" alt=""></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=27911432&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android庶系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AS </tag>
            
            <tag> Gradle </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android共享元素场景切换动画的实现</title>
      <link href="/2017/04/16/17-04-16/"/>
      <url>/2017/04/16/17-04-16/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>我们知道安卓5.0系统引入了共享元素，能做出非常炫酷的场景切换效果，这让人非常兴奋同时非常蛋疼，因为低版本没法使用啊，所以今天就跟大家分享一下自己写的一个库，其实只有2个文件而已，还是叫它工具比较合适吧……非常轻量级，简直是人畜无害，兼容安卓5.0以下的版本。</p></blockquote><span id="more"></span><!-- 这是　　缩进--><p>先看看效果：<br><img src="http://dinson-blog.hdinson.cn/FuAsXRvr0p3XH756f5X0YoVWzwid.gif" alt=""><br>效果图涉及了Activity中的元素（顶部bar）和ListView中的元素（icon和name），事实上无论哪个位置的元素都能轻松实现。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>使用这个工具非常简单，假设有ActivityA（简称A）和ActivityB（简称B），在A中启动B，再从B回退到A，首先需要在A和B中，各自定义id相同的两个View，这里可以是ListView的item布局中的View，只要获取到View即可，然后：</p><p><strong>·A启动B：</strong><br><img src="http://dinson-blog.hdinson.cn/FsQNPZ4ay7W6EjnqWp5lM3gbMX7o.png" alt=""><br><strong>·B回退到A：</strong><br><img src="http://dinson-blog.hdinson.cn/FqJBAMpZBWsFUi_ob4YzPEOMzrjO.png" alt=""></p><p>用法非常简单，当然以上只是最少参数的基本用法，除此之外可以设置的参数还有时间、加减速以及动画监听，其中动画监听可以方便在动画开始前做一些初始化操作，以及动画结束后做一些显示操作，下面就来讲一下实现的原理。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从A启动B时，首先需要构造一个EasyTransitionOptions对象，直接通过EasyTransitionOptions.makeTransitionOptions方法进行构造，传入的参数为ActivityA以及需要共享的元素View，我们看一下EasyTransitionOptions有啥：<br><img src="http://dinson-blog.hdinson.cn/FoHI7ZVr4oe5ArnzcvyA_QoGliAj.png" alt=""><br>可以看到前两个即为构造时传入的参数，第三个attrs接下来会用到。</p><p>接着我们跟往常一样，构造一个Intent对象，然后调用EasyTransition.startActivity方法，传入了该Intent以及前面构造好的options，我们看看EasyTransition.startActivity做了什么：<br><img src="http://dinson-blog.hdinson.cn/FhV13pgqrzTBaPTQa7a2qQ6S0OVn.png" alt=""><br>首先调用了options.update方法，接着又获取了options的attrs并放到intent中，看看update方法：<br><img src="http://dinson-blog.hdinson.cn/Fp6PhrgxeEOwz62IAv7qlv3hupXW.png" alt=""><br>就是这里，options使用传入的View填充了之前看到的那个ViewAttrs集合attrs，attrs存储了View的一些属性，分别为：<br><img src="http://dinson-blog.hdinson.cn/FuhInkYnHM0VHscuPaK8rJY6QqxX.png" alt=""><br>id用于获取B中的对应的View，接下来会讲到。startX和startY分别为View在A中的x、y坐标，这里通过View的getLocationOnScreen方法获取View在屏幕中的坐标，可以看到该方法的参数为int[] outLocation，以out开头的参数，意思即为执行方法后将填充该参数。width和height分别为View在A中的宽和高。</p><p>接下来通过options获取Activity并调用真正的startActivity方法，然后再调用overridePendingTransition(0, 0)将系统的转场动画覆盖，0表示没有转场动画。</p><p>然后进入到B，我们在B的onCreate方法中，只调用了一个方法EasyTransition.enter，看看这个方法做了什么：<br><img src="http://dinson-blog.hdinson.cn/FjU_eSsjyaj2Fhm93Fl7Zl-PLn1C.png" alt=""><br>这个方法有很多个重载，最简单的只需要传入一个Activity参数即可。参数都很简单，分别为ActivityB，动画时间，动画的差值器以及动画监听。</p><p>首先通过Activity获取到Intent并拿到从A传入的ViewAttrs集合，接着执行了runEnterAnimation方法，到这里就要开始执行动画了，看看runEnterAnimation方法：<br><img src="http://dinson-blog.hdinson.cn/Fq1k7n-d1dXjqVYHGT-JZHRDk8T3.png" alt=""><br>看似挺长的，其实只做了一件事，<strong>即根据ViewAttrs集合attrs，给B中的View先设置属性，再执行一段动画。</strong></p><p>首先遍历attrs，通过id找到B中对应的View；然后在ViewTreeObserver.OnPreDrawListener中设置View的属性，其中scale属性设置为A中View的宽高与B中View的宽高的比，transition属性设置为A中View的坐标相对于B中View的坐标的偏移量，之所以使用屏幕坐标就是为了准确地算出坐标的偏移量，而不受状态栏等其他因素的影响。</p><p>设置完成后，再调用View.animate方法，将动画结束状态设置为View在B中的初始状态，再传入时间、动画差值器以及监听器，就这样简单地完成了转场动画。</p><p>接着我们需要从B回退到A，在回退的操作中，调用了EasyTransition.exit方法，看看它做了什么：<br><img src="http://dinson-blog.hdinson.cn/FgMNcEbDy1bKlJxuezkHk_nS4xuM.png" alt=""><br>看起来跟enter方法差不多，通过Activity获取到Intent，再拿到ViewAttrs集合，是的它又派上用场了，接着执行了runExitAnimation方法，可以看到也是挺眼熟的：<br><img src="http://dinson-blog.hdinson.cn/FlQzDy1wE3dBBJ1w0qiBSyyzopdQ.png" alt=""><br>也是遍历attrs，找到B中对应id的View，只不过这次动画是从View在B中的初始状态开始，变到View在A中的状态，属性还是那些属性，没有啥其他的。不一样的是，在执行动画后需要关闭B，所以调用了View.postDelayed方法，然后finish掉当前的Activity，依旧是覆盖一下系统的转场动画overridePendingTransition(0, 0)。</p><p>就这样简单的实现了共享元素炫酷的转场动画，最初纠结于如何实现比较优雅，然后开始看5.0共享元素有关的那部分源码（也只是粗略看了一下），再看了看网上一些其他人的做法，最终提炼出了这个工具，非常轻量，用起来也挺舒服的。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=27571329&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>android 最全缓存目录获取方式和函数解析</title>
      <link href="/2016/07/28/16-07-28/"/>
      <url>/2016/07/28/16-07-28/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Android 开发中基本都要使用到文件的保存和读取操作，我们一般遇见的文件读写问题有几个：文件保存在哪？以及如何使用相关函数，目录权限的问题？以及删除应用之后目录是否会随之删除的问题？接下来就来解析一下这几个相关目录的操作函数。 </p></blockquote><span id="more"></span><!-- 这是　　缩进--><h2 id="data-data-package-name-…"><a href="#data-data-package-name-…" class="headerlink" title="/data/data/package_name/…"></a>/data/data/package_name/…</h2><blockquote><p>该目录是只对应用可见的，而且如果手机没有 root，用普通权限的 adb 也看不了这个目录，该目录用来存储和应用周期相关的文件，会随着应用的卸载一起删除，相关的子目录如下所示：</p></blockquote><ul><li><p>/data/data/package_name/shared_prefs/<br>用来存储 SharedPreference，对应函数为：getSharedPreferences(String fileName, int mode)；</p></li><li><p>/data/data/package_name/databases/<br>用来存储数据库 DB，相关函数还有 getDatabasePath()；</p></li><li><p>/data/data/package_name/app_webview 和 /data/data/package_name/xxxwebviewcachexxx<br>来存储应用内置 webview 所产生的 cache 和 cookies 等，该目录由于 android 版本不同名字和位置也可能不同；</p></li><li><p>/data/data/package_name/lib<br>用来存储该应用的 .so 静态库文件；</p></li><li><p>/data/data/package_name/cache<br>该目录可以使用函数 getCacheDir() 获取；</p></li><li><p>/data/data/package_name/files<br>该目录可以使用函数 getFilesDir() 获取，openFileInput() 和 openFileOutput() 函数也是在该目录下操作文件， fileList() 函数是用来列出该 files 目录下的所有文件，deleteFile(String name) 用来删除该 files 目录下的文件；</p></li><li><p>/data/data/package_name/XXXX<br>这个目录下面当然也能够创建子集的目录，使用的方法就是 getDir(String name, int mode)，参数中的 name 就是需要在该目录下创建的子目录名字。</p></li></ul><p>如果能够打开应用的该目录，一般会在该目录下看到很多子目录。 </p><blockquote><p>还有一个特别奇怪的函数，无意中看见的 getCodeCacheDir() 函数，该函数的解释为 This location is optimal for storing compiled or optimized code generated by your application at runtime，该目录适合在运行时存放应用产生的编译或者优化的代码，但是我调用就报了 NoSuchMethodError，不知道为什么，知道的可以告诉我。 </p></blockquote><p>另外还有其他两个相关函数：</p><p>`<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">getPackageCodePath() = /data/app/com.android.framework-1.apk </span><br><span class="line">getPackageResourcePath() = /data/app/com.android.framework-1.apk</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">&gt; 以上函数没有明确指定的都是使用 Context 调用。</span><br><span class="line"></span><br><span class="line">## SD卡下的目录</span><br><span class="line"></span><br><span class="line">&gt; SD 卡下的目录，顾名思义就是需要插入 SD 卡，当 SD 卡不可用时这两个目录都是无效的，SD 卡下面也分为应用的私有目录和共有目录，私有目录的生命周期也是和应用挂钩的，卸载之后就会被删除，共有目录不会随着应用的卸载而删除。 </span><br><span class="line"></span><br><span class="line">可以通过 `Environment.getExternalStorageState()` 函数来获取 SD 卡的挂载状态，当该函数返回 `mounted` 的时候，代表 SD 卡可用。 </span><br><span class="line"></span><br><span class="line">注意 SD 卡使用时需要注册相关权限：&lt;uses-permission android:name=”android.permission.WRITE_EXTERNAL_STORAGE”/&gt;。</span><br><span class="line"></span><br><span class="line">## SD卡私有目录</span><br><span class="line"></span><br><span class="line">&gt; 该目录下的文件卸载应用之后会自动删除。</span><br><span class="line"></span><br><span class="line">## /sdcard/Android/data/package_name/</span><br><span class="line"></span><br><span class="line">- /sdcard/Android/data/com.android.framework/files/</span><br><span class="line">该目录可用 getExternalFilesDir(String type) 和 getExternalFilesDirs(String type) 获取，参数 type 为子目录名字，null 则为根目录，后者调用之后会自动生成该目录，并且后者返回的是一个数组，如果插入外置存储卡，外置存储卡目录也会一并返回，具体区别可以查看后面的源码和结果；</span><br><span class="line"></span><br><span class="line">- /sdcard/Android/data/com.android.framework/cache/</span><br><span class="line">该目录可用 getExternalCacheDir() 和 getExternalCacheDirs() 获取，后者调用之后自动生成该目录，和上面一样，后者返回的是一个数组，如果插入外置存储卡，外置存储卡目录也会一并返回，具体区别可以查看后面的源码和结果。</span><br><span class="line"></span><br><span class="line">## /sdcard/Android/obb/package_name/</span><br><span class="line"></span><br><span class="line">&gt; 需要注意的是，obb 目录也可能不存在，原文：Note if the application does not have any OBB files, this directory may not exist，一般游戏 APP 会将游戏相关的数据包放到这个目录下。 </span><br><span class="line"></span><br><span class="line">该目录的的相关函数简单只有两个：`getObbDirs()` 和 `getObbDir()`，前者调用之后会自动生成该目录，后者在插入外置存储卡之后会在前者的基础上另外返回外置存储卡的 obb 目录，具体的结果可以查看后面的源码和结果。</span><br><span class="line"></span><br><span class="line">## SD卡共有目录</span><br><span class="line"></span><br><span class="line">&gt; 该目录下的文件卸载应用之后还会留存，所以为了 SD 卡的整洁度，不要随便在 SD 卡的根目录下面创建文件，最好以应用名字创建一个目录，所有的需要卸载之后留存或者需要给其他应用共享的文件都放到该目录下，不要在根目录下创建文件，还有一个公司的多个应用最好共享一个目录，特别讨厌 360 ，恨不得把 360XXX 式的目录全部创建完才行，极其讨厌和反对。</span><br><span class="line"></span><br><span class="line">## /sdcard/(any_folder_name)</span><br><span class="line"></span><br><span class="line">- Environment.getExternalStorageState()</span><br><span class="line">这个函数用来获取 SD 卡的挂载状态，如果传入参数 path 则是获取该路径的的挂载状态，比如这个目录被用户的 PC 挂载，或者从设备中移除，或者其他问题发生，状态的返回是不一样的；</span><br><span class="line"></span><br><span class="line">- Environment.getExternalStorageDirectory()</span><br><span class="line">该函数用来返回 SD 卡的根目录，即 /storage/emulated/0，注意不要在根目录下创建文件，强烈建立创建一个子目录去操作，要不然会污染 SD 卡的主目录，该目录所有应用都可操作，为共享目录；</span><br><span class="line"></span><br><span class="line">- Environment.getDownloadCacheDirectory()</span><br><span class="line">该函数用来返回 SD 卡下面的下载缓存目录；</span><br><span class="line"></span><br><span class="line">- Environment.getDataDirectory()</span><br><span class="line">该函数用来获取用户的数据目录；</span><br><span class="line"></span><br><span class="line">- Environment.getExternalStoragePublicDirectory(String type)</span><br><span class="line">该函数用来根据类型返回相关目录，类型为 Environment 的一些变量，传入的类型参数不能是 null，返回的目录路径有可能不存在，所以必须在使用之前确认一下，没有就创建该目录；</span><br><span class="line"></span><br><span class="line">- Environment.getRootDirectory()</span><br><span class="line">该函数用来返回根 System 目录，只挂载为只读;</span><br><span class="line"></span><br><span class="line">## 源码及结果</span><br><span class="line"></span><br><span class="line">&gt; 手机如果还能够SD卡扩展，就相当于能挂载两张SD卡，下面的测试结果也是两张SD卡的结果：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>L.e(“getDatabasePath():”+getDatabasePath(“student.db”));<br>L.e(“getCacheDir():” + getCacheDir());<br>L.e(“getFilesDir():” + getFilesDir());<br>String[] strings = fileList();<br>for (String path : strings){//为空<br>   L.e(“fileList():—-“ + path);<br>}<br>L.e(“getDir(\”zhao\”):” + getDir(“zhao”, MODE_PRIVATE));<br>//        L.e(“getCodeCacheDir():” + getCodeCacheDir()); //java.lang.NoSuchMethodError<br>L.e(“getPackageCodePath():” + getPackageCodePath());<br>L.e(“getPackageResourcePath():” + getPackageResourcePath());<br>L.e(“getExternalFilesDir():” + getExternalFilesDir(null));<br>File[] paths = getExternalFilesDirs(null);<br>for (File path : paths){<br>    L.e(“getExternalFilesDirs():—-“ + path.getPath());<br>}<br>L.e(“getExternalCacheDir():” + getExternalCacheDir());<br>paths = getExternalCacheDirs();<br>for (File path : paths){<br>   L.e(“getExternalCacheDirs():—-“ + path.getPath());<br>}<br>L.e(“getObbDir():” + getObbDir());<br>paths = getObbDirs();<br>for (File path : paths){<br>   L.e(“getObbDirs():—-“ + path.getPath());<br>}<br>L.e(“Environment.getExternalStorageState():”+ Environment.getExternalStorageState());<br>L.e(“Environment.getExternalStorageDirectory():”+Environment.getExternalStorageDirectory());<br>L.e(“Environment.getDownloadCacheDirectory():”+Environment.getDownloadCacheDirectory());<br>L.e(“Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC):”+Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC));<br>L.e(“Environment.getRootDirectory():”+Environment.getRootDirectory());<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对应的结果为，注意看外部存储卡的路径：</span><br></pre></td></tr></table></figure><br>getDatabasePath():/data/data/com.dinson.framework/databases/student.db<br>getCacheDir():/data/data/com.dinson.framework/cache<br>getFilesDir():/data/data/com.dinson.framework/files<br>getDir(“zhao”):/data/data/com.dinson.framework/app_zhao<br>getPackageCodePath():/data/app/com.dinson.framework-1.apk<br>getPackageResourcePath():/data/app/com.dinson.framework-1.apk<br>getExternalFilesDir():/storage/emulated/0/Android/data/com.dinson.framework/files<br>getExternalFilesDirs():—-/storage/emulated/0/Android/data/com.dinson.framework/files<br>getExternalFilesDirs():—-/storage/ext_sd/Android/data/com.dinson.framework/files<strong><em>*</em></strong><br>getExternalCacheDir():/storage/emulated/0/Android/data/com.dinson.framework/cache<br>getExternalCacheDirs():—-/storage/emulated/0/Android/data/com.dinson.framework/cache<br>getExternalCacheDirs():—-/storage/ext_sd/Android/data/com.dinson.framework/cache<strong><em>*</em></strong><br>getObbDir():/storage/emulated/0/Android/obb/com.dinson.framework<br>getObbDirs():—-/storage/emulated/0/Android/obb/com.dinson.framework<br>getObbDirs():—-/storage/ext_sd/Android/obb/com.dinson.framework<strong><em>*</em></strong><br>Environment.getExternalStorageState():mounted<br>Environment.getExternalStorageDirectory():/storage/emulated/0<br>Environment.getDownloadCacheDirectory():/cache<br>Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC):/storage/emulated/0/Music<br>Environment.getRootDirectory():/system<br>```</p><!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> -->]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>查看Android应用包名、Activity的几个方法</title>
      <link href="/2016/07/25/16-07-25/"/>
      <url>/2016/07/25/16-07-25/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>使用自动化测试工具monkeyrunner启动应用时，需要填写被测程序的包名和启动的Activity，以下有两种查看应用包名package和入口activity名称的方法：</p></blockquote><span id="more"></span><h2 id="有源码情况"><a href="#有源码情况" class="headerlink" title="有源码情况"></a>有源码情况</h2><p>直接打开AndroidManifest.xml文件，找到包含Android.intent.action.MAIN和android.intent.category.LAUNCHER对应的activity。</p><p>如下图中第三行package为com.cola.ui，第七行主Activity为com.cola.ui.ColaBox(.ColaBox为Activity简写方式)。<br><img src="http://dinson-blog.hdinson.cn/FpEkhLttJwPCD-K6u1xt9RUT8AoR.png" alt=""></p><h2 id="只有Apk的情况"><a href="#只有Apk的情况" class="headerlink" title="只有Apk的情况"></a>只有Apk的情况</h2><h3 id="aapt"><a href="#aapt" class="headerlink" title="aapt"></a>aapt</h3><p>使用命令行aapt dump xmltree xxxxxx.apk AndroidManifest.xml<br><img src="http://dinson-blog.hdinson.cn/Fs_TbbRr30EjXC_HMpazfn8z8H4U.png" alt=""></p><h3 id="aapt-1"><a href="#aapt-1" class="headerlink" title="aapt"></a>aapt</h3><p>使用命令行aapt dump badging xxxxxx.apk<br><img src="http://dinson-blog.hdinson.cn/FgJTlyBvGOmlVU-sxGqD51g7QnWC.png" alt=""></p><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>使用反编译工具apktool，反编译后打开AndroidManifest.xml文件，查找方式同“有源码情况”<br><a href="http://dinson.win/2016/06/08/16-06-08/">反编译传送门</a></p><h2 id="没有apk，应用已经安装到手机或虚拟机中"><a href="#没有apk，应用已经安装到手机或虚拟机中" class="headerlink" title="没有apk，应用已经安装到手机或虚拟机中"></a>没有apk，应用已经安装到手机或虚拟机中</h2><h3 id="logcat"><a href="#logcat" class="headerlink" title="logcat"></a>logcat</h3><ul><li>清除logcat内容，使用命令adb logcat -c</li><li>启动logcat，使用命令adb logcat ActivityManager:I *:s</li><li>启动要查看的程序<br><img src="http://dinson-blog.hdinson.cn/FhW1gQkpq9O0XkiP5VKdd8cnc5Aq.png" alt=""></li></ul><h3 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h3><ul><li>启动要查看的程序；</li><li>命令行输入：adb shell dumpsys window w |findstr \/ |findstr name=<br><img src="http://dinson-blog.hdinson.cn/Fs2Zp6enCCqGJw84lkrcIQLcybIa.png" alt=""></li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=209326&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android庶系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用包名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android keycode</title>
      <link href="/2016/07/21/16-07-21/"/>
      <url>/2016/07/21/16-07-21/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Android 常用按键大全</p></blockquote><span id="more"></span><h2 id="电话键"><a href="#电话键" class="headerlink" title="电话键"></a>电话键</h2><div class="table-container"><table><thead><tr><th>键名</th><th>描述</th><th>键值</th></tr></thead><tbody><tr><td>KEYCODE_CALL</td><td>拨号键</td><td>5</td></tr><tr><td>KEYCODE_ENDCALL</td><td>挂机键</td><td>6</td></tr><tr><td>KEYCODE_HOME</td><td>按键Home</td><td>3</td></tr><tr><td>KEYCODE_MENU</td><td>菜单键</td><td>82</td></tr><tr><td>KEYCODE_BACK</td><td>返回键</td><td>4</td></tr><tr><td>KEYCODE_SEARCH</td><td>搜索键</td><td>84</td></tr><tr><td>KEYCODE_CAMERA</td><td>拍照键</td><td>27</td></tr><tr><td>KEYCODE_FOCUS</td><td>拍照对焦键</td><td>80</td></tr><tr><td>KEYCODE_POWER</td><td>电源键</td><td>26</td></tr><tr><td>KEYCODE_NOTIFICATION</td><td>通知键</td><td>83</td></tr><tr><td>KEYCODE_MUTE</td><td>话筒静音键</td><td>91</td></tr><tr><td>KEYCODE_VOLUME_MUTE</td><td>扬声器静音键</td><td>164</td></tr><tr><td>KEYCODE_VOLUME_UP</td><td>音量增加键</td><td>24</td></tr><tr><td>KEYCODE_VOLUME_DOWN</td><td>音量减小键</td><td>25</td></tr></tbody></table></div><h2 id="控制键"><a href="#控制键" class="headerlink" title="控制键"></a>控制键</h2><div class="table-container"><table><thead><tr><th>键名</th><th>描述</th><th>键值</th></tr></thead><tbody><tr><td>KEYCODE_ENTER</td><td>回车键</td><td>66</td></tr><tr><td>KEYCODE_ESCAPE</td><td>ESC键</td><td>111</td></tr><tr><td>KEYCODE_DPAD_CENTER</td><td>导航键 确定键</td><td>23</td></tr><tr><td>KEYCODE_DPAD_UP</td><td>导航键 向上</td><td>19</td></tr><tr><td>KEYCODE_DPAD_DOWN</td><td>导航键 向下</td><td>20</td></tr><tr><td>KEYCODE_DPAD_LEFT</td><td>导航键 向左</td><td>21</td></tr><tr><td>KEYCODE_DPAD_RIGHT</td><td>导航键 向右</td><td>22</td></tr><tr><td>KEYCODE_MOVE_HOME</td><td>光标移动到开始键</td><td>122</td></tr><tr><td>KEYCODE_MOVE_END</td><td>光标移动到末尾键</td><td>123</td></tr><tr><td>KEYCODE_PAGE_UP</td><td>向上翻页键</td><td>92</td></tr><tr><td>KEYCODE_PAGE_DOWN</td><td>向下翻页键</td><td>93</td></tr><tr><td>KEYCODE_DEL</td><td>退格键</td><td>67</td></tr><tr><td>KEYCODE_FORWARD_DEL</td><td>删除键</td><td>112</td></tr><tr><td>KEYCODE_INSERT</td><td>插入键</td><td>124</td></tr><tr><td>KEYCODE_TAB</td><td>Tab键</td><td>61</td></tr><tr><td>KEYCODE_NUM_LOCK</td><td>小键盘锁</td><td>143</td></tr><tr><td>KEYCODE_CAPS_LOCK</td><td>大写锁定键</td><td>115</td></tr><tr><td>KEYCODE_BREAK</td><td>Break/Pause键</td><td>121</td></tr><tr><td>KEYCODE_SCROLL_LOCK</td><td>滚动锁定键</td><td>116</td></tr><tr><td>KEYCODE_ZOOM_IN</td><td>放大键</td><td>168</td></tr><tr><td>KEYCODE_ZOOM_OUT</td><td>缩小键</td><td>169</td></tr></tbody></table></div><h2 id="组合键"><a href="#组合键" class="headerlink" title="组合键"></a>组合键</h2><div class="table-container"><table><thead><tr><th>键名</th><th>描述</th></tr></thead><tbody><tr><td>KEYCODE_ALT_LEFT</td><td>Alt+Left</td></tr><tr><td>KEYCODE_ALT_RIGHT</td><td>Alt+Right</td></tr><tr><td>KEYCODE_CTRL_LEFT</td><td>Control+Left</td></tr><tr><td>KEYCODE_CTRL_RIGHT</td><td>Control+Right</td></tr><tr><td>KEYCODE_SHIFT_LEFT</td><td>Shift+Left</td></tr><tr><td>KEYCODE_SHIFT_RIGHT</td><td>Shift+Right</td></tr></tbody></table></div><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><div class="table-container"><table><thead><tr><th>键名</th><th>描述</th><th>键值</th></tr></thead><tbody><tr><td>KEYCODE_0</td><td>按键’0’</td><td>7</td></tr><tr><td>KEYCODE_1</td><td>按键’1’</td><td>8</td></tr><tr><td>KEYCODE_2</td><td>按键’2’</td><td>9</td></tr><tr><td>KEYCODE_3</td><td>按键’3’</td><td>10</td></tr><tr><td>KEYCODE_4</td><td>按键’4’</td><td>11</td></tr><tr><td>KEYCODE_5</td><td>按键’5’</td><td>12</td></tr><tr><td>KEYCODE_6</td><td>按键’6’</td><td>13</td></tr><tr><td>KEYCODE_7</td><td>按键’7’</td><td>14</td></tr><tr><td>KEYCODE_8</td><td>按键’8’</td><td>15</td></tr><tr><td>KEYCODE_9</td><td>按键’9’</td><td>16</td></tr><tr><td>KEYCODE_A</td><td>按键’A’</td><td>29</td></tr><tr><td>KEYCODE_B</td><td>按键’B’</td><td>30</td></tr><tr><td>KEYCODE_C</td><td>按键’C’</td><td>31</td></tr><tr><td>KEYCODE_D</td><td>按键’D’</td><td>32</td></tr><tr><td>KEYCODE_E</td><td>按键’E’</td><td>33</td></tr><tr><td>KEYCODE_F</td><td>按键’F’</td><td>34</td></tr><tr><td>KEYCODE_G</td><td>按键’G’</td><td>35</td></tr><tr><td>KEYCODE_H</td><td>按键’H’</td><td>36</td></tr><tr><td>KEYCODE_I</td><td>按键’I’</td><td>37</td></tr><tr><td>KEYCODE_J</td><td>按键’J’</td><td>38</td></tr><tr><td>KEYCODE_K</td><td>按键’K’</td><td>39</td></tr><tr><td>KEYCODE_L</td><td>按键’L’</td><td>40</td></tr><tr><td>KEYCODE_M</td><td>按键’M’</td><td>41</td></tr><tr><td>KEYCODE_N</td><td>按键’N’</td><td>42</td></tr><tr><td>KEYCODE_O</td><td>按键’O’</td><td>43</td></tr><tr><td>KEYCODE_P</td><td>按键’P’</td><td>44</td></tr><tr><td>KEYCODE_Q</td><td>按键’Q’</td><td>45</td></tr><tr><td>KEYCODE_R</td><td>按键’R’</td><td>46</td></tr><tr><td>KEYCODE_S</td><td>按键’S’</td><td>47</td></tr><tr><td>KEYCODE_T</td><td>按键’T’</td><td>48</td></tr><tr><td>KEYCODE_U</td><td>按键’U’</td><td>49</td></tr><tr><td>KEYCODE_V</td><td>按键’V’</td><td>50</td></tr><tr><td>KEYCODE_W</td><td>按键’W’</td><td>51</td></tr><tr><td>KEYCODE_X</td><td>按键’X’</td><td>52</td></tr><tr><td>KEYCODE_Y</td><td>按键’Y’</td><td>53</td></tr><tr><td>KEYCODE_Z</td><td>按键’Z’</td><td>54</td></tr></tbody></table></div><p>符号</p><div class="table-container"><table><thead><tr><th>键名</th><th>描述</th></tr></thead><tbody><tr><td>KEYCODE_PLUS</td><td>按键’+’</td></tr><tr><td>KEYCODE_MINUS</td><td>按键’-‘</td></tr><tr><td>KEYCODE_STAR</td><td>按键’*’</td></tr><tr><td>KEYCODE_SLASH</td><td>按键’/‘</td></tr><tr><td>KEYCODE_EQUALS</td><td>按键’=’</td></tr><tr><td>KEYCODE_AT</td><td>按键’@’</td></tr><tr><td>KEYCODE_POUND</td><td>按键’#’</td></tr><tr><td>KEYCODE_APOSTROPHE</td><td>按键’’’ (单引号)</td></tr><tr><td>KEYCODE_BACKSLASH</td><td>按键’\’</td></tr><tr><td>KEYCODE_COMMA</td><td>按键’,’</td></tr><tr><td>KEYCODE_PERIOD</td><td>按键’.’</td></tr><tr><td>KEYCODE_LEFT_BRACKET</td><td>按键’[‘</td></tr><tr><td>KEYCODE_RIGHT_BRACKET</td><td>按键’]’</td></tr><tr><td>KEYCODE_SEMICOLON</td><td>按键’;’</td></tr><tr><td>KEYCODE_GRAVE</td><td>按键’`’</td></tr><tr><td>KEYCODE_SPACE</td><td>空格键</td></tr></tbody></table></div><h2 id="小键盘"><a href="#小键盘" class="headerlink" title="小键盘"></a>小键盘</h2><div class="table-container"><table><thead><tr><th>键名</th><th>描述</th></tr></thead><tbody><tr><td>KEYCODE_NUMPAD_0</td><td>小键盘按键’0’</td></tr><tr><td>KEYCODE_NUMPAD_1</td><td>小键盘按键’1’</td></tr><tr><td>KEYCODE_NUMPAD_2</td><td>小键盘按键’2’</td></tr><tr><td>KEYCODE_NUMPAD_3</td><td>小键盘按键’3’</td></tr><tr><td>KEYCODE_NUMPAD_4</td><td>小键盘按键’4’</td></tr><tr><td>KEYCODE_NUMPAD_5</td><td>小键盘按键’5’</td></tr><tr><td>KEYCODE_NUMPAD_6</td><td>小键盘按键’6’</td></tr><tr><td>KEYCODE_NUMPAD_7</td><td>小键盘按键’7’</td></tr><tr><td>KEYCODE_NUMPAD_8</td><td>小键盘按键’8’</td></tr><tr><td>KEYCODE_NUMPAD_9</td><td>小键盘按键’9’</td></tr><tr><td>KEYCODE_NUMPAD_ADD</td><td>小键盘按键’+’</td></tr><tr><td>KEYCODE_NUMPAD_SUBTRACT</td><td>小键盘按键’-‘</td></tr><tr><td>KEYCODE_NUMPAD_MULTIPLY</td><td>小键盘按键’*’</td></tr><tr><td>KEYCODE_NUMPAD_DIVIDE</td><td>小键盘按键’/‘</td></tr><tr><td>KEYCODE_NUMPAD_EQUALS</td><td>小键盘按键’=’</td></tr><tr><td>KEYCODE_NUMPAD_COMMA</td><td>小键盘按键’,’</td></tr><tr><td>KEYCODE_NUMPAD_DOT</td><td>小键盘按键’.’</td></tr><tr><td>KEYCODE_NUMPAD_LEFT_PAREN</td><td>小键盘按键’(‘</td></tr><tr><td>KEYCODE_NUMPAD_RIGHT_PAREN</td><td>小键盘按键’)’</td></tr><tr><td>KEYCODE_NUMPAD_ENTER</td><td>小键盘按键回车</td></tr></tbody></table></div><h2 id="功能键"><a href="#功能键" class="headerlink" title="功能键"></a>功能键</h2><div class="table-container"><table><thead><tr><th>键名</th><th>描述</th></tr></thead><tbody><tr><td>KEYCODE_F1</td><td>按键F1</td></tr><tr><td>KEYCODE_F2</td><td>按键F2</td></tr><tr><td>KEYCODE_F3</td><td>按键F3</td></tr><tr><td>KEYCODE_F4</td><td>按键F4</td></tr><tr><td>KEYCODE_F5</td><td>按键F5</td></tr><tr><td>KEYCODE_F6</td><td>按键F6</td></tr><tr><td>KEYCODE_F7</td><td>按键F7</td></tr><tr><td>KEYCODE_F8</td><td>按键F8</td></tr><tr><td>KEYCODE_F9</td><td>按键F9</td></tr><tr><td>KEYCODE_F10</td><td>按键F10</td></tr><tr><td>KEYCODE_F11</td><td>按键F11</td></tr><tr><td>KEYCODE_F12</td><td>按键F12</td></tr></tbody></table></div><h2 id="多媒体键"><a href="#多媒体键" class="headerlink" title="多媒体键"></a>多媒体键</h2><div class="table-container"><table><thead><tr><th>键名</th><th>描述</th></tr></thead><tbody><tr><td>KEYCODE_MEDIA_PLAY</td><td>多媒体键 播放</td></tr><tr><td>KEYCODE_MEDIA_STOP</td><td>多媒体键 停止</td></tr><tr><td>KEYCODE_MEDIA_PAUSE</td><td>多媒体键 暂停</td></tr><tr><td>KEYCODE_MEDIA_PLAY_PAUSE</td><td>多媒体键 播放/暂停</td></tr><tr><td>KEYCODE_MEDIA_FAST_FORWARD</td><td>多媒体键 快进</td></tr><tr><td>KEYCODE_MEDIA_REWIND</td><td>多媒体键 快退</td></tr><tr><td>KEYCODE_MEDIA_NEXT</td><td>多媒体键 下一首</td></tr><tr><td>KEYCODE_MEDIA_PREVIOUS</td><td>多媒体键 上一首</td></tr><tr><td>KEYCODE_MEDIA_CLOSE</td><td>多媒体键 关闭</td></tr><tr><td>KEYCODE_MEDIA_EJECT</td><td>多媒体键 弹出</td></tr><tr><td>KEYCODE_MEDIA_RECORD</td><td>多媒体键 录音</td></tr></tbody></table></div><h2 id="手柄按键"><a href="#手柄按键" class="headerlink" title="手柄按键"></a>手柄按键</h2><div class="table-container"><table><thead><tr><th>键名</th><th>描述</th></tr></thead><tbody><tr><td>KEYCODE_BUTTON_1</td><td>通用游戏手柄按钮 #1</td></tr><tr><td>KEYCODE_BUTTON_2</td><td>通用游戏手柄按钮 #2</td></tr><tr><td>KEYCODE_BUTTON_3</td><td>通用游戏手柄按钮 #3</td></tr><tr><td>KEYCODE_BUTTON_4</td><td>通用游戏手柄按钮 #4</td></tr><tr><td>KEYCODE_BUTTON_5</td><td>通用游戏手柄按钮 #5</td></tr><tr><td>KEYCODE_BUTTON_6</td><td>通用游戏手柄按钮 #6</td></tr><tr><td>KEYCODE_BUTTON_7</td><td>通用游戏手柄按钮 #7</td></tr><tr><td>KEYCODE_BUTTON_8</td><td>通用游戏手柄按钮 #8</td></tr><tr><td>KEYCODE_BUTTON_9</td><td>通用游戏手柄按钮 #9</td></tr><tr><td>KEYCODE_BUTTON_10</td><td>通用游戏手柄按钮 #10</td></tr><tr><td>KEYCODE_BUTTON_11</td><td>通用游戏手柄按钮 #11</td></tr><tr><td>KEYCODE_BUTTON_12</td><td>通用游戏手柄按钮 #12</td></tr><tr><td>KEYCODE_BUTTON_13</td><td>通用游戏手柄按钮 #13</td></tr><tr><td>KEYCODE_BUTTON_14</td><td>通用游戏手柄按钮 #14</td></tr><tr><td>KEYCODE_BUTTON_15</td><td>通用游戏手柄按钮 #15</td></tr><tr><td>KEYCODE_BUTTON_16</td><td>通用游戏手柄按钮 #16</td></tr><tr><td>KEYCODE_BUTTON_A</td><td>游戏手柄按钮 A</td></tr><tr><td>KEYCODE_BUTTON_B</td><td>游戏手柄按钮 B</td></tr><tr><td>KEYCODE_BUTTON_C</td><td>游戏手柄按钮 C</td></tr><tr><td>KEYCODE_BUTTON_X</td><td>游戏手柄按钮 X</td></tr><tr><td>KEYCODE_BUTTON_Y</td><td>游戏手柄按钮 Y</td></tr><tr><td>KEYCODE_BUTTON_Z</td><td>游戏手柄按钮 Z</td></tr><tr><td>KEYCODE_BUTTON_L1</td><td>游戏手柄按钮 L1</td></tr><tr><td>KEYCODE_BUTTON_L2</td><td>游戏手柄按钮 L2</td></tr><tr><td>KEYCODE_BUTTON_R1</td><td>游戏手柄按钮 R1</td></tr><tr><td>KEYCODE_BUTTON_R2</td><td>游戏手柄按钮 R2</td></tr><tr><td>KEYCODE_BUTTON_MODE</td><td>游戏手柄按钮 Mode</td></tr><tr><td>KEYCODE_BUTTON_SELECT</td><td>游戏手柄按钮 Select</td></tr><tr><td>KEYCODE_BUTTON_START</td><td>游戏手柄按钮 Start</td></tr><tr><td>KEYCODE_BUTTON_THUMBL</td><td>Left Thumb Button</td></tr><tr><td>KEYCODE_BUTTON_THUMBR</td><td>Right Thumb Button</td></tr></tbody></table></div><p>待查</p><div class="table-container"><table><thead><tr><th>键名</th><th>描述</th></tr></thead><tbody><tr><td>KEYCODE_NUM</td><td>按键Number modifier</td></tr><tr><td>KEYCODE_INFO</td><td>按键Info</td></tr><tr><td>KEYCODE_APP_SWITCH</td><td>按键App switch</td></tr><tr><td>KEYCODE_BOOKMARK</td><td>按键Bookmark</td></tr><tr><td>KEYCODE_AVR_INPUT</td><td>按键A/V Receiver input</td></tr><tr><td>KEYCODE_AVR_POWER</td><td>按键A/V Receiver power</td></tr><tr><td>KEYCODE_CAPTIONS</td><td>按键Toggle captions</td></tr><tr><td>KEYCODE_CHANNEL_DOWN</td><td>按键Channel down</td></tr><tr><td>KEYCODE_CHANNEL_UP</td><td>按键Channel up</td></tr><tr><td>KEYCODE_CLEAR</td><td>按键Clear</td></tr><tr><td>KEYCODE_DVR</td><td>按键DVR</td></tr><tr><td>KEYCODE_ENVELOPE</td><td>按键Envelope special function</td></tr><tr><td>KEYCODE_EXPLORER</td><td>按键Explorer special function</td></tr><tr><td>KEYCODE_FORWARD</td><td>按键Forward</td></tr><tr><td>KEYCODE_FORWARD_DEL</td><td>按键Forward Delete</td></tr><tr><td>KEYCODE_FUNCTION</td><td>按键Function modifier</td></tr><tr><td>KEYCODE_GUIDE</td><td>按键Guide</td></tr><tr><td>KEYCODE_HEADSETHOOK</td><td>按键Headset Hook</td></tr><tr><td>KEYCODE_META_LEFT</td><td>按键Left Meta modifier</td></tr><tr><td>KEYCODE_META_RIGHT</td><td>按键Right Meta modifier</td></tr><tr><td>KEYCODE_PICTSYMBOLS</td><td>按键Picture Symbols modifier</td></tr><tr><td>KEYCODE_PROG_BLUE</td><td>按键Blue “programmable”</td></tr><tr><td>KEYCODE_PROG_GREEN</td><td>按键Green “programmable”</td></tr><tr><td>KEYCODE_PROG_RED</td><td>按键Red “programmable”</td></tr><tr><td>KEYCODE_PROG_YELLOW</td><td>按键Yellow “programmable”</td></tr><tr><td>KEYCODE_SETTINGS</td><td>按键Settings</td></tr><tr><td>KEYCODE_SOFT_LEFT</td><td>按键Soft Left</td></tr><tr><td>KEYCODE_SOFT_RIGHT</td><td>按键Soft Right</td></tr><tr><td>KEYCODE_STB_INPUT</td><td>按键Set-top-box input</td></tr><tr><td>KEYCODE_STB_POWER</td><td>按键Set-top-box power</td></tr><tr><td>KEYCODE_SWITCH_CHARSET</td><td>按键Switch Charset modifier</td></tr><tr><td>KEYCODE_SYM</td><td>按键Symbol modifier</td></tr><tr><td>KEYCODE_SYSRQ</td><td>按键System Request / Print Screen</td></tr><tr><td>KEYCODE_TV</td><td>按键TV</td></tr><tr><td>KEYCODE_TV_INPUT</td><td>按键TV input</td></tr><tr><td>KEYCODE_TV_POWER</td><td>按键TV power</td></tr><tr><td>KEYCODE_WINDOW</td><td>按键Window</td></tr><tr><td>KEYCODE_UNKNOWN</td><td>未知按键</td></tr></tbody></table></div><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=139551&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android庶系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓按键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android自动测试之Monkey工具</title>
      <link href="/2016/07/20/16-07-20/"/>
      <url>/2016/07/20/16-07-20/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Monkey是一个命令行工具，可以运行在模拟器里或实际设备中，使用安卓调试桥(adb)来运行它，向系统发送伪随机的用户事件流，实现对正在开发的应用程序进行压力测试，可以根据获取的log信息进行修复。</p></blockquote><span id="more"></span><h2 id="Monkey的基本使用"><a href="#Monkey的基本使用" class="headerlink" title="Monkey的基本使用"></a>Monkey的基本使用</h2><blockquote><ol><li>连接设备：adb devices 查看设备是否连接成功</li><li>adb shell 进入shell界面</li><li>设备安装要运行的程序包或apk（或者通过查看data/data下的程序包)：adb安装apk：在所安装的apk路径下，使用adb install **.apk</li><li>执行monkey测试命令：monkey -p your.package.name -v 500</li></ol></blockquote><p>在不知道所安装的apk的包名的时候，采用adb命令查看包名：</p><blockquote><ol><li>清除logcat内容，使用命令adb logcat -c</li><li>启动logcat，使用命令adb logcat ActivityManager:I *:s</li><li>启动要查看的程序，</li><li>打开已安装的apk，查看出现的ActivityManager信息，cmp=name，此name就是打开的apk的包名。</li></ol></blockquote><h2 id="Monkey命令使用"><a href="#Monkey命令使用" class="headerlink" title="Monkey命令使用"></a>Monkey命令使用</h2><ul><li><p><strong>-help</strong><br>列出简单用法</p></li><li><p><strong>-v</strong><br>作用：命令行上的每一个-v都将增加反馈信息的详细级别。<br>Lv0：默认，除了启动、测试完成和最终结果外只提供较少的信息。<br>Lv1：提供了较为详细的测试信息，如逐个发送到Activity的事件信息。<br>Lv2：提供了更多的设置信息，如测试中选中或未选中的Activity信息。<br>例：adb shell monkey -v 10<br>  adb shell monkey -v -v 10<br>  adb shell monkey -v -v -v 10</p></li><li><p><strong>-s <seed></strong><br>伪随机数生成器的seed值。如果用相同的seed值再次运行monkey，将生成相同的事件序列。<br>例： adb shell monkey -s 12345 -v 10</p></li><li><p><strong>-p <allowed-package-name></strong><br>如果你指定一个或多个包，Monkey将只允许访问这些包中的Activity。如果你的应用程序需要访问这些包(如选择联系人)以外的Activity，你需要指定这些包。如果你不指定任何包，Monkey将允许系统启动所有包的Activity。指定多个包，使用多个-p，一个-p后面接一个包名。<br>例： adb shell monkey -p com.android.browser -v 10 </p></li><li><p><strong>-c <main-category></strong><br>如果你指定一个或多个类别，Monkey将只允许系统启动这些指定类别中列出的Activity。如果你不指定任何类别，Monkey将选择谢列类别中列出的Activity，Intent.CATEGORY_LAUNCHER和Intent.CATEGORY_MONKEY。指定多个类别使用多个-c，每个-c指定一个类别。<br>例： adb shell monkey -p com.paipai.ershou -v 10 -c </p></li><li><p><strong>—ignore-crashes</strong><br>通常，应用发生崩溃或异常时Monkey会停止运行。如果设置此项，Monkey将继续发送事件给系统，直到事件计数完成。</p></li><li><p><strong>—ignore-timeouts</strong><br>事件请求超时会影响monkey的测试。如果设置此项，Monkey将继续发送事件给系统，直到事件计数完成。</p></li><li><p><strong>adb shell monkey -p com.ihongqiqu -v -v -v 500 &gt; monkeytest.txt</strong><br>保存测试日志</p></li></ul><h2 id="九个事件及百分比控制"><a href="#九个事件及百分比控制" class="headerlink" title="九个事件及百分比控制"></a>九个事件及百分比控制</h2><p><code>0</code> <strong>—pct-touch <percent></strong><br>    调整触摸事件的百分比(触摸事件是一个down-up事件，它发生在屏幕上的某单一位置)（——点击事件，涉及down、up）</p><p><code>1</code> <strong>—pct-motion <percent></strong><br>    调整动作事件的百分比(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个up事件组成) （——注：move事件，涉及down、up、move三个事件）</p><p><code>2</code> <strong>—pct-pinchzoom <percent></strong><br>    二指缩放百分比，即智能机上的放大缩小手势操作</p><p><code>3</code> <strong>—pct-trackball <percent> </strong><br>    调整轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随有点击)—（轨迹球）</p><p><code>4</code> <strong>—pct-rotation <percent></strong><br>    屏幕旋转百分比，横屏竖屏</p><p><code>5</code> <strong>—pct-permission <percent></strong><br>    权限变换测试</p><p><code>6</code><strong>—pct-nav <percent></strong><br>    调整“基本”导航事件的百分比(导航事件由来自方向输入设备的up/down/left/right组成)</p><p><code>7</code><strong>—pct-majornav <percent> </strong><br>    调整“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如：5-way键盘的中间按键、回退按键、菜单按键)</p><p><code>8</code><strong>—pct-syskeys <percent></strong><br>    调整“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、Start Call、End Call及音量控制键)</p><p><code>9</code><strong>—pct-appswitch <percent></strong><br>    调整启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法。（从一个Activity跳转到另一个Activity）</p><p><code>10</code><strong>—pct-flip <percent></strong><br>    调整“键盘翻转”事件的百分比。    </p><p><code>11</code><strong>—pct-anyevent <percent></strong><br>    调整其它类型事件的百分比。它包罗了所有其它类型的事件，如：按键、其它不常用的设备按钮、等等。<br>红色的数字对应下面百分比对应的数字。比如下图中0：15.0%，表示分配—pct-touch事件15%。测试100次分配15次测试down-up。</p><p>如果在monkey参数中不指定上述参数，这些动作都是随机分配的，9个动作其每个动作分配的百分比之和为100%，我们可以通过添加命令选项来控制每个事件的百分比，进而可以将操作限制在一定的范围内。<br>我们先来看一下不加动作百分比控制，系统默认分配事件百分比的情况<br><img src="http://dinson-blog.hdinson.cn/FvLtGNYniHZe0Z4UzzjG9Bvsjzk6.png" alt=""></p><p>再看一下指定事件，控制事件百分比之后的情况<br><img src="http://dinson-blog.hdinson.cn/FunYqkTAgsV-8KpRPmDN_qDkpX3g.png" alt=""></p><h2 id="Monkey测试信息"><a href="#Monkey测试信息" class="headerlink" title="Monkey测试信息"></a>Monkey测试信息</h2><blockquote><p>在Monkey测试过程中可能会出现程序崩溃(CRASH)和程序无响应的情况(ANR),要将测试的log信息获取到，从而解决bug。</p></blockquote><ul><li><p>CRASH:即崩溃信息，程序在运行中非正常退出。 不设置忽略crashes，在测试过程中出现CRASH，会中断测试，并显示CRASH信息和seed信息<br><img src="http://dinson-blog.hdinson.cn/Fi_n0qusMRBTZCF8LzfVbOQj05Gy.png" alt=""><br>根据seed值来完成bug的复现：adb shell monkey -p com.feicuiedu.monkeytestdemo -s 1476474162566 -v 1000</p></li><li><p>ANR:同样在monkey测试过程中，如果出现ANR现象，会输出相应的信息，以ANR开头，获取到信息进行问题的解决，同样可以通过seed来进行复现。<br><img src="http://dinson-blog.hdinson.cn/FiBg8JdFLfnqL9U3c32bplyUzrz6.png" alt=""></p></li></ul><blockquote><p>附：如果在手动测试过程中出现ANR，日志信息出现在手机中：</p><ul><li>adb shell</li><li>cd /data/anr 切换到设备路径下</li><li>ls 可以看到traces.txt 里面即为log信息</li></ul></blockquote><h2 id="MonkeyScript"><a href="#MonkeyScript" class="headerlink" title="MonkeyScript"></a>MonkeyScript</h2><blockquote><p>MonkeyScript是monkey的脚本语言，是一组可以被Monkey识别的命令集合，可以帮我们完成一系列的被固定的重复性操作，Monkey通过脚本来进行测试，简单快捷、不需要任何工具，只是一个记事本文件，缺点是在坐标、按键等方面没有逻辑性。</p></blockquote><h3 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#头文件、控制monkey发送消息的参数</span><br><span class="line">type=raw events</span><br><span class="line">count=10</span><br><span class="line">speed=1.0</span><br><span class="line"></span><br><span class="line">#以下为monkey命令</span><br><span class="line">start data &gt;&gt;</span><br><span class="line">DispatchPress (KEYCODE_HOME)</span><br><span class="line">DispatchPress (KEYCODE_MENU)</span><br></pre></td></tr></table></figure><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><blockquote><p>常用API的介绍，其中keycode参考keycode列表</p></blockquote><ul><li><p>LaunchActivity(pkg_name, cl_name)<br>  启动应用的Activity。参数：包名和启动的Activity。</p></li><li><p>Tap(x, y, tapDuration)<br>  模拟一次手指单击事件。参数：x,y为控件坐标，tapDuration为点击的持续时间，此参数可省略。</p></li><li><p>DispatchPress(keyName)<br>  按键。参数： keycode</p></li><li><p>RotateScreen(rotationDegree, persist)<br>  旋转屏幕。 参数：rotationDegree为旋转角度， e.g. 1代表90度；persist表示旋转之后是否固定，0表示旋转后恢复，非0则表示固定不变。</p></li><li><p>DispatchFlip(true/false)<br>  打开或者关闭软键盘。</p></li><li><p>LongPress()<br>  长按2秒。</p></li><li><p>PressAndHold(x, y, pressDuration)<br>  模拟长按事件。</p></li><li><p>DispatchString(input)<br>  输入字符串。</p></li><li><p>Drag(xStart, yStart, xEnd, yEnd, stepCount)<br>  用于模拟一个拖拽操作。</p></li><li><p>PinchZoom(x1Start, y1Start, x1End, y1End, x2Start, y2Start, x2End, y2End, stepCount)<br>  模拟缩放手势。</p></li><li><p>UserWait(sleepTime)<br>  休眠一段时间</p></li><li><p>DeviceWakeUp()<br>  唤醒屏幕。</p></li><li><p>PowerLog(power_log_type, test_case_status)<br>  模拟电池电量信息。</p></li><li><p>WriteLog()<br>  将电池信息写入sd卡。</p></li><li><p>RunCmd(cmd)<br>  运行shell命令。</p></li><li><p>DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFlags)<br>  向指定位置，发送单个手势。</p></li><li><p>DispatchPointer(downtime,eventTime,action,x,yxpressure,size,metastate,xPrecision,yPrecision,device,edgeFilags)<br>  发送按键消息。</p></li><li><p>LaunchInstrumentation(test_name,runner_name)<br>  运行一个instrumentation测试用例。</p></li><li><p>DispatchTrackball<br>  模拟发送轨迹球事件。</p></li><li><p>ProfileWait<br>  等待5秒。</p></li><li><p>StartCaptureFramerate()<br>  获取帧率。</p></li><li><p>EndCaptureFramerate(input)<br>  结束获取帧率。</p></li></ul><blockquote><p>API方法中控件位置(X,Y轴的坐标)的获取：使用Android提供的工具uiautomatorviewer.bat</p><p>在Android SDK路径下—&gt; tools —&gt; uiautomatorviewer.bat，打开就可以展示设备/模拟器上展示的视图，展示视图结构和坐标。</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/FhYFzvVV6xPr3fV33wdz8hSNcYZm.png" alt=""></p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#头文件、控制monkey发送消息的参数</span><br><span class="line">type=raw events</span><br><span class="line">count=10</span><br><span class="line">speed=1.0</span><br><span class="line">#以下为脚本正文</span><br><span class="line">start data &gt;&gt;</span><br><span class="line">#1.打开浏览器</span><br><span class="line">LaunchActivity(com.android.browser,com.android.browser.BrowserActivity)</span><br><span class="line">ProfileWait()</span><br><span class="line">#2.清空网址</span><br><span class="line">Tap(223,146)</span><br><span class="line">ProfileWait()</span><br><span class="line">DispatchPress(112)</span><br><span class="line">ProfileWait()</span><br><span class="line">#3.输入网址</span><br><span class="line">DispatchString(www.baidu.com)</span><br><span class="line">ProfileWait()</span><br><span class="line">#4.确认，载入网址</span><br><span class="line">DispatchPress(KEYCODE_ENTER)</span><br><span class="line">ProfileWait()</span><br><span class="line">#5.完成退出浏览器</span><br><span class="line">DispatchPress(KEYCODE_HOME)</span><br><span class="line">ProfileWait()</span><br></pre></td></tr></table></figure><blockquote><p>1.脚本完成后将.txt 文件push到手机中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push name.txt path</span><br></pre></td></tr></table></figure><p>其中name是指monkey脚本文件的名称，path是要push到手机上的路径</p><blockquote><p>2.运行Monkey脚本</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monkey -f path/name.txt -v 500</span><br></pre></td></tr></table></figure><p>path是push的路径，name是脚本文件的名称。</p><h2 id="案例实践"><a href="#案例实践" class="headerlink" title="案例实践"></a>案例实践</h2><p>随机事件流对MonketTestDemo进行测试：</p><blockquote><ol><li>adb devices 查看设备是否连接</li><li>adb shell 进入shell界面</li><li>monkey -p com.feicuiedu.monkeytestdemo -v 500 执行monkey命令</li><li>(可选)monkey -p com.feicuiedu.monkeytestdemo -v 500 &gt; monkeytest.txt 执行monkey命令，并将monkey日志存储</li></ol></blockquote><p>一次随机的自动化Monkey测试完成。<br>MonkeyScript对MonkeyTestDemo进行测试：</p><blockquote><ol><li>完成monkey.txt脚本的编写，保存到某一路径下</li><li>切换到monkey.txt路径下</li><li>adb push monkey.txt /data/local/temp/(设备的任一路径，无确切规定)</li><li>adb shell 切换到设备下</li><li>cd /data/local/temp 切换到monkey.txt路径下</li><li>monkey -f monkey.txt -v 10 执行monkey脚本及执行次数</li></ol></blockquote><p>一次MonkeyScript的自动化Monkey测试完成。</p><h2 id="关于Monkey测试的停止条件"><a href="#关于Monkey测试的停止条件" class="headerlink" title="关于Monkey测试的停止条件"></a>关于Monkey测试的停止条件</h2><p>Monkey Test执行过程中在下列三种情况下会自动停止：</p><ol><li>如果限定了Monkey运行在一个或几个特定的包上，那么它会监测试图转到其它包的操作，并对其进行阻止。</li><li>如果应用程序崩溃或接收到任何失控异常，Monkey将停止并报错。</li><li>如果应用程序产生了应用程序不响应(application not responding)的错误，Monkey将会停止并报错。</li></ol><p>通过多次并且不同设定下的Monkey测试才算它是一个稳定性足够的程序。 </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=33162226&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android庶系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Monkey工具 </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo设置指南</title>
      <link href="/2016/07/17/16-07-17/"/>
      <url>/2016/07/17/16-07-17/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>设置指南</p></blockquote><h2 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h2><blockquote><p><strong>建议使用第一种方式，除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。</strong></p></blockquote><ol><li><p>在文章中使用&lt;!—more—> 手动进行截断。这种方法可以根据文章的内容，自己在合适的位置添加&lt;!—more—>标签，使用灵活，也是Hexo推荐的方法。<br><img src="http://dinson-blog.hdinson.cn/FiClBw76yH9X6udPyDIxtrIy55PK.png" alt=""></p></li><li><p>在文章中的front-matter中添加description，并提供文章摘录。这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。<br><img src="http://dinson-blog.hdinson.cn/FvIhULsqboNVPBcqLod5KYSBXp99.PNG" alt=""></p></li><li><p>自动形成摘要，在主题配置_config.yml文件中添加。默认截取的长度为 150 字符，可以根据需要自行设定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line"> enable: <span class="literal">true</span></span><br><span class="line"><span class="attr">length</span>: <span class="number">150</span></span><br></pre></td></tr></table></figure></li></ol><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=5237118&auto=1&height=66"></iframe> ]]></content>
      
      
      <categories>
          
          <category> 个人博客辛酸系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+Hexo搭建个人博客辛酸史--分支控制(贰)</title>
      <link href="/2016/07/15/16-07-15/"/>
      <url>/2016/07/15/16-07-15/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>利用github的不同分支来分别保存网站静态文件与hexo源码（md原始文件及主题等），实现在不同电脑上都可以自由写博客</p><p>当然，这种方式也有缺点，那就是所有的静态页面由于都需要保存在github里的自己名下的网站同名项目仓库内，所以如果项目仓库是public的，那么<strong>所有人都会看到你的网站代码</strong>， 这个其实应该也没有关系吧！！！hexo都是开源的，而且静态博客是编译后的，框架和主题都是用的别人开源出来的，但博客写了不就是让别人看的？所以应该真的无所谓。。。</p></blockquote><p>如果你实在不想让别人看到你的md原件，那么就不要使用本文所说的同一个项目的分支啦，就去新建一个项目来单独保存源码文件吧，并且把这个项目设为priviate的，要花钱的哦，这样别人就看不到啦。。。</p><h2 id="新建hexo分支"><a href="#新建hexo分支" class="headerlink" title="新建hexo分支"></a>新建hexo分支</h2><p><img src="http://dinson-blog.hdinson.cn/Fj58UGgezpzxA74yfWhnXoZTXI1j.png!web" alt=""></p><p>如上图在红色输入框内写入新建的branch名 hexo 后，回车即可建立新的branch-hexo；</p><h2 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h2><p>因为我们写博客更多的是更新这个分支，网站文件所在的 master 分支则由 <code>hexo d</code> 命令发布文章的时候进行推送，所以我们将 hexo分支设置为默认分支，这样我们在新的电脑环境下 git clone 该仓库时，自动切到 hexo分支。按下图进行操作。<br><img src="http://dinson-blog.hdinson.cn/FrjlF2U3nigZwuOi9sfTDlPCu3Hp.png" alt=""></p><h2 id="配置hexo-deploy参数"><a href="#配置hexo-deploy参数" class="headerlink" title="配置hexo deploy参数"></a>配置hexo deploy参数</h2><p>为了保证 hexo d 命令可以正确部署到 master 分支，在hexo 的配置文件 _config.yml 文件中配置参数如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/username/username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>hexo 3.0之后 deploy type，将github改为了git，这样适用性更广了，如果你发现无法 hexo d ，使用下面的命令安装git deployer插件后重试即可。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><h2 id="修改推送到hexo分支"><a href="#修改推送到hexo分支" class="headerlink" title="修改推送到hexo分支"></a>修改推送到hexo分支</h2><p>上一步的deploy参数正确配置后，文章写完使用 hexo g -d 命令就可以直接部署了，生成的博客静态文件会自动部署到 username.github.io 仓库的 master 分支上。</p><p>网站页面是保存了，但这时候我们还没有保存我们的hexo原始文件，包括我们的文章md文件，我们千辛万苦修改的主题配置等。。。接下来使用下面的步骤将他们都统统推送到 hexo 分支上去。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m “change description”</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></p><p>这样就OK了，我们的原始文件就都上去了，换电脑也不怕了。</p><h2 id="日常写博客"><a href="#日常写博客" class="headerlink" title="日常写博客"></a>日常写博客</h2><p>有时候我们可能会在不同的电脑上写博客，那在不同的电脑上配置 hexo、git、node.js，以及配置git ssh key等都要折腾一下的，这是免不了的，也是比wordpress等其他博客框架麻烦的一点。</p><h2 id="已有环境"><a href="#已有环境" class="headerlink" title="已有环境"></a>已有环境</h2><p>如果在电脑上已经写过博客，那么可以在已有的工作目录下同步之前写的博客。在你的仓库目录下右键’git bash shell’，起来bash命令行，然后<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p><p>这样你的状态就更新了，之后就是 hexo 命令写文章啦。。。</p><p>写完 <code>hexo g -d</code> 部署好后，使用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m “change description”</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></p><p>推送上去。</p><h2 id="新的环境"><a href="#新的环境" class="headerlink" title="新的环境"></a>新的环境</h2><p>到了新的电脑上时，我们需要将项目先下载到本地，然后再进行hexo初始化。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/username/username.github.io.git</span><br><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>之后开始写博客，写好部署好之后，别忘记 git add , … , git push origin hexo…推上去…</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=27867499&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 个人博客辛酸系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android主题换肤 无缝切换</title>
      <link href="/2016/07/11/16-07-11/"/>
      <url>/2016/07/11/16-07-11/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>关于Android的主题换肤都是个老生常谈的问题了。网上给出的方案也是层出不穷，最近我也是很想去了解这方面的知识，所以我去搜一下就会有一大堆介绍这方面的文章，但是最后的结果都是不尽人意的，有的确实是给出了一些比较好的解决方案，但是没有一个实质性的Demo可以参考，所以也只能是纸上谈兵罢了，有的呢，确实是给出了一个参考的Demo但是最后的结果不是我想要的。<a href="http://dinson.win/2016/07/08/16-07-08/">关于Android的换肤方案技术的总结</a>，这篇文章还是挺有参考价值的Android换肤技术总结。感兴趣的同学可以去了解下，就当做是一个知识的普及。</p></blockquote><p>今天我要实现的一个换肤方案是基于github上的这个开源框架<a href="https://github.com/fengjundev/Android-Skin-Loader">Android-Skin-Loader</a>。</p><p><strong>这个框架的换肤机制是使用动态加载的机制去加载皮肤包里面的内容，无需Acitvity重启即可实现皮肤的实时更换，皮肤包是可以与原安装包相分离的，需要自己定做（这个皮肤包其实也就是一个普通的Android项目，只是只有资源文件没有类文件而已），这样做的好处就是可以在线提供皮肤包供用户去下载，也可以大大的减少安装包的体积，同时也很好的实现了插件化。</strong></p><p>其实这个框架是可以拿来直接来用的，直接几行代码基本上就可以解决Android的主题换肤，但是作为一个程序员怎么可以只是简单的知道怎么用就行了吗？如果真是这样就真的太low了。遇到一个好的开源项目我们至少需要把他的源码大致看一下，走一下基本的流程，了解一下他的基本原理，这样我们在技术上才会有所提升。</p><span id="more"></span><p>好了说了这么多，通过本文你可以学到什么，这个可能是大家比较关心的一点</p><ul><li>设计出一个基于MaterialDesign风格的App</li><li>自己实现一个主题换肤的框架</li><li>高仿网易云音乐的主题换肤（ps：其实本来我想以这个作为标题的，这样做也可以增加流量，可我不想单纯的做个标题党，给大家带来干货才是最重要的）</li><li>让你的技术更上一层楼（这个说了也是白说）</li></ul><p>说了这么久可能就会有人按捺不住了：我是来看干货的，不是来这听你瞎BB的。不要急干货马上来。如果实在感觉枯燥可以直接跳到文末去看源码。下面先来几张效果图来爽一下</p><p><strong>网易云音乐换肤界面</strong></p><p>这个是网易云音乐的换肤界面，他提供了几个默认的，也提供了可以在线下载的主题，他的切换效果还是非常赞的，用过这个软件的同学肯定是知道的。学习完本文后就可以做出类似于这个换肤效果。<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070729_945.png" alt=""><br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070729_669.png" alt=""><br>这个动态图是最终我们这个Demo实现的效果，这个Demo总体来说还是比较简单的，只提供了三种皮肤。实现了一个基本的换肤效果，主要还是用于拿来学习使用。当然更复杂的换肤基于这个Demo也是可以办到的，这里主要还是去讲解原理。</p><p>在介绍之前还需要先给大家普及一下<strong>LayoutInflaterFactory</strong>相关的知识。如果已经知道了这方面的知识点，下面这一段可以直接略过。</p><p>对于LayoutInflater大家可能都不太陌生，当你需要把xml文件转化成对应View的时候就必须用到它，我想对于他怎么使用的就不用我介绍了。LayoutInflater 提供了setFactory(LayoutInflater.Factory factory)和setFactory2(LayoutInflater.Factory2 factory)两个方法可以让你去自定义布局的填充（有点类似于过滤器，我们在填充这个View之前可以做一些额外的事，但不完全是），Factory2 是在API 11才添加的。<br>他们提供了下面的方法让你去重写。在这里面你完全可以自己去定义去创建你所想要的View，如果在你在重写的方法中返回null的话，就会以系统默认的方式去创建View。<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">View onCreateView(String name, Context context, AttributeSet attrs)//LayoutInflater.Factory</span><br><span class="line"></span><br><span class="line">View onCreateView(View parent, String name, Context context, AttributeSet attrs)//LayoutInflater.Factory2</span><br></pre></td></tr></table></figure></p><p>LayoutInflater都被设置了一个默认的Factory，Activity 是实现了LayoutInflater.Factory接口的,因此在你的Activity中直接重写onCreateView就可以自定义View的填充了。</p><p>下面这句是对LayoutInflater.Factory一个比较好的理解</p><blockquote><p>Inflating your own custom views, instead of letting the system do it<br>这个也是这个Demo其中的一个比较重要技术点。如果有想更详细了解的文末会有参考链接。</p></blockquote><p><strong>下面就正式开始介绍怎么去做这个主题换肤吧。</strong></p><p>先来看看这个Demo的项目结构：<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070732_568.png" alt=""></p><p>至于xRecyclerView可以不用管，这里我们用不到（这是之前用到的，与本次无关），他只是一个RecyclerView的一个扩展框架，支持下拉刷新和上拉加载，是一个在github上的一个开源项目。</p><p>这里我们直接来看看lib_skinloader这个库吧（这里面的内容大部分是来源于<a href="https://github.com/fengjundev/Android-Skin-Loader">Android-Skin-Loader</a>这个框架，我只做了部分修改，主要是适配AppCompatActivity，原框架是基于最初的Activty开发的），这个库就是今天所讲的核心内容<br>lib_skinloader包结构图<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070733_807.png" alt=""></p><p><strong>我们都知道在Android中如果想去获取资源文件都必须通过Resources去获取。这个库的核心思想就是动态的去加载第三方包里面的包，获取到其Resources然后以获取到的这个Resources去获取第三方包里面的资源内容，最后设置到我们有需响应皮肤更改的View上。</strong></p><p>这里我就只介绍load和base两个包，其他包的内容在讲解的时候会涉及到</p><h2 id="Load包"><a href="#Load包" class="headerlink" title="Load包"></a>Load包</h2><p>我们先来看看这个load包里面的内容（其实这里就是今天核心内容的核心）。<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070733_329.png" alt=""></p><p>里面有两个类文件：SkinInflaterFactory、SkinManager<br>我们先来看看SkinManager的实现，直接跳到load方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public void load(String skinPackagePath, final ILoaderListener callback) &#123;</span><br><span class="line">new AsyncTask&lt;String, Void, Resources&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">protected void onPreExecute() &#123;</span><br><span class="line">    if (callback != null) &#123;</span><br><span class="line">        callback.onStart();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected Resources doInBackground(String... params) &#123;</span><br><span class="line">try &#123;if (params.length == 1) &#123;</span><br><span class="line">                    String skinPkgPath = params[0];</span><br><span class="line">                    Log.i(&quot;loadSkin&quot;, skinPkgPath);</span><br><span class="line">                    File file = new File(skinPkgPath);</span><br><span class="line">                    if (file == null || !file.exists()) &#123;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    PackageManager mPm = context.getPackageManager();</span><br><span class="line">                    PackageInfo mInfo = mPm.getPackageArchiveInfo(skinPkgPath, PackageManager.GET_ACTIVITIES);</span><br><span class="line">                    skinPackageName = mInfo.packageName;</span><br><span class="line">                    AssetManager assetManager = AssetManager.class.newInstance();</span><br><span class="line">                    Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);</span><br><span class="line">                    addAssetPath.invoke(assetManager, skinPkgPath);</span><br><span class="line">                    Resources superRes = context.getResources();</span><br><span class="line">                    Resources skinResource = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());</span><br><span class="line">                    SkinConfig.saveSkinPath(context, skinPkgPath);</span><br><span class="line">                    skinPath = skinPkgPath;</span><br><span class="line">                    isDefaultSkin = false;</span><br><span class="line">                    return skinResource;</span><br><span class="line">                &#125;</span><br><span class="line">                return null;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">protected void onPostExecute(Resources result) &#123;</span><br><span class="line">            mResources = result;</span><br><span class="line">            if (mResources != null) &#123;</span><br><span class="line">                if (callback != null) callback.onSuccess();</span><br><span class="line">                notifySkinUpdate();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                isDefaultSkin = true;</span><br><span class="line">                if (callback != null) callback.onFailed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.execute(skinPackagePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方法有两个参数，第一个是皮肤包的路径，第二个就是一个简单的回调</p><p>其中doInBackground方法里面就实现了动态的去获取皮肤包的Resources，当获取成功之后，在onPostExecute方法中就将这个Resources赋值到我们定义好的变量中去，以方便我们之后的使用，注意到当获取到的这个Resources不为空时，也就是我们已经获取到了皮肤包里面的资源，我们就调用notifySkinUpdate()这个方法来通知界面去更改皮肤，如果为空就还是使用默认的皮肤。</p><p>我们来看看notifySkinUpdate()的实现</p><p><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070733_838.png" alt=""></p><p>这里很简单，就是去遍历mSkinObservers这个集合，然后去通知更新。对于ISkinUpdate是一个接口，每个需要皮肤更新的Activity都需要去实现这个接口。</p><p>SkinManager这个类里面还有诸如getColor(int resId)、getDrawable(int resId)这样的方法，就是去获取第三方包对应的资源文件，值得注意的是如果你的第三方包里没有对应的资源文件，那么就会使用默认的资源文件，如果你有需求，你完全可以去添加一些类似getMipmap(int resID)这样的方法。</p><p>对了，还有一个比较重要的方法忘了讲，restoreDefaultTheme<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070733_714.png" alt=""></p><p>这个方法就是恢复到系统的默认主题，原理和load都差不多，实现还简单了很多。</p><p>我们再来看看SkinInflaterFactory，在这里面主要就是做一些填充View相关的一些工作。我实现的是LayoutInflaterFactory这个接口而不是文章之前提到的LayoutInflater.Factory这个接口是因为这里需要与AppCompatActivity兼容，如果你还是用之前的那个就会出现一些错误，反正我刚弄的时候是折腾了很久的。不管怎么样原理始终是一样的。SkinInflaterFactory的作用就是去搜集那些有需要响应皮肤更改的View。</p><p>我们来看看onCreateView的实现<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070734_603.png" alt=""></p><p>首先我们先去判断这个当前将要View是否有更改皮肤的需求，如果没有我们就返回默认的实现。如果有，我们就自己去处理<br>来看看createView方法的实现<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070734_179.png" alt=""></p><p>看起来很多，其实这个方法就是去动态的去创建View。</p><p>下面来看看parseSkinAttr的实现：<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070734_111.png" alt=""></p><p>这个方法其实就是去搜集View中换肤的时候可以更改的属性，当我们换肤的时候就是去更改的这些属性的值，这里你必须要注意一点，这个属性的值一定要是引用类型的（例如:@color/red），千万不能写死，第二个if的判断就是这个作用。<strong>到这里可能你就会有个疑问，我怎么知道哪些属性在换肤的时候需要更改。</strong>如果你细心一点肯定注意到了这行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkinAttr mSkinAttr = AttrFactory.get(attrName, id, entryName, typeName);</span><br></pre></td></tr></table></figure><p>这里有个AttrFacory他的作用就是根据属性名，动态的去创建SkinAttr。在AttrFacory中定义了一些类似于这样的常量：<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070734_683.png" alt=""></p><p>这就是我们换肤的时候可以更改的那些属性。SkinAttr是一个抽象类，比如background就会去创建一个BackgroundAttr,本项目所用到的属性全都在attr包中。SkinAttr是比较灵活的一个地方,如果你有哪个属性在换肤的时候需要更改，你就去实现一个对应的SkinAttr。</p><p>在parseSkinAttr这个方法的最后我们将View和SkinAttr封装成了一个SkinItem然后添加到一个集合中去，最后还需注意的是，如果当前皮肤不是默认皮肤，一定要去apply一下，这样做主要是防止换了皮肤启动一些新的页面有可能导致换肤不及时的问题。SkinInflaterFactory这个类里面还提供了动态的添加SkinItem的方法，原理都和这里差不多，我就不过多的去说了。</p><p>load包里面的这两个类讲的差不多了，这里看懂了后面的内容也就是小菜一碟了，我相信你看了这里再去看源码一定会轻松地多。</p><h2 id="Base包"><a href="#Base包" class="headerlink" title="Base包"></a>Base包</h2><p>base包结构<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070734_434.png" alt=""></p><p>可以看见这个包里面肯定就是Activity、Fragment、Application的实现，作用肯定就是封装一些公用的方法和属性在里面。</p><p>下面我们一个一个来分析</p><ul><li><p>SkinBaseApplication：</p><p>  <img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070734_920.png" alt=""></p></li><li><p>SkinBaseApplication</p><p>  <img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070734_138.png" alt=""></p></li></ul><ul><li><p>SkinBaseActivity</p><p>  我们来看看其onCreate方法</p><p>  <img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070734_138.png" alt=""></p><p>  在这里使用了我们之前自定义的View的InflaterFactory，来替换默认的Factory。记住一定要在super.onCreate(savedInstanceState);这个方法之前调用。SkinBaseActivity里面还提供了动态添加可以响应皮肤更改需求的View的相关方法。当然需要响应换肤更改的Activity都需要继承SkinBaseActivity。详细实现请看源码。</p></li><li><p>SkinBaseFragment</p><p>  这个和SkinBaseActivity的思想差不多。具体实现看源码，这里我只是给大家提供这个换肤框架的思想，让大家在看源码的时候更轻松。</p></li></ul><p><strong>这个框架就介绍到这，下面我们来看看怎么去使用。</strong></p><p>在使用的时候一定要记得要Activity要去继承于SkinBaseActivity，Fragment要继承于SkinBaseFragment，Application要继承于SkinBaseApplication。当然把这个框架做为你的项目依赖项肯定是必不可少的。为了Demo的简单，这里我只使用了下面三个颜色作为可以换肤的资源，当然如果你想要使用drawable文件也是可以办到的，前提是你一定要把这个Demo看懂。</p><p><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070735_293.png" alt=""></p><p>来看一个布局文件<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070735_129.png" alt=""></p><p>其中</p><blockquote><p>xmlns:skin=”<a href="http://schemas.android.com/android/skin&quot;`">http://schemas.android.com/android/skin&quot;`</a></p></blockquote><p>是我们自定义的，在SkinConfig有。<br>我们只需在有皮肤更改需求的View中加入skin:enable=”true” 就OK了。</p><p>再来看看MainActicvity的部分代码<br><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070735_461.png" alt=""></p><p>这里就是动态的添加有皮肤更改需求的View。</p><p>上面就介绍完了在布局文件中使用方法和在代码中使用方法。</p><p>我们应该怎么去换肤呢？很简单，只需调用SkinManager的load方法就可以了，把皮肤路径传进去就可以了，我的这个Demo为了简单起见，没有做在线换肤的功能，只是在本地提供了可以更换的皮肤，看到这里我相信你对怎样在线换肤已经有想法了。</p><p><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418070735_386.png" alt=""></p><h2 id="怎样去换肤"><a href="#怎样去换肤" class="headerlink" title="怎样去换肤"></a>怎样去换肤</h2><p>最最后我们来看看怎么去开发皮肤包。其实这个是最简单的，皮肤包实际上就是一个基本的Android项目，里面不包含类文件，只有资源文件。<strong>这里只需注意 这里的资源文件名字一定要和原项目中的相同，并且只用包含那些在皮肤更改时需要改变的那些就行了！</strong>例如我的这个Demo就只是简单对上面的三种颜色做了简单的切换。开发了棕色和黑色两款皮肤，所以资源文件中只有三个color的值，开发完成之后我们需要将其打包成apk文件，为防止用户点击安装，我们将其后缀改成了skin，这样做也具有标识性。如果还是不太清楚可以直接去源码中查看。</p><p>这下再来看一看文章开头效果图是不是突然变得有思路了,快动起你的小手指去敲一个主题换肤的框架吧~~~</p><p><img src="http://static.open-open.com/lib/uploadImg/20160418/20160418072257_730.gif" alt=""></p><p>参考链接:</p><blockquote><p>   <a href="http://blog.bradcampbell.nz/layoutinflater-factories/">LayoutInflater Factories（需梯子）</a><br>   <a href="https://willowtreeapps.com/ideas/app-development-how-to-get-the-right-layoutinflater/">How to Get the Right LayoutInflater</a><br>   <a href="http://blog.csdn.net/singwhatiwanna/article/details/22597587">Android apk动态加载机制的研究</a><br>   Android换肤技术总结</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=65769&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题换肤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android换肤技术总结</title>
      <link href="/2016/07/08/16-07-08/"/>
      <url>/2016/07/08/16-07-08/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>纵观现在各种Android app，其换肤需求可以归为<br></p><ul><li>白天/黑夜主题切换（或者别的名字，通常2套），如同花顺/自选股/天天动听等，UI表现为一个switcher。</li><li>多种主题切换，通常为会员特权，如QQ/QQ空间。</li></ul><p>对于第一种来说，目测应该是直接通过本地theme来做的，即所有图片/颜色的资源都在apk里面打包了。</p><p>而对于第二种，则相对复杂一些，由于作为一种线上服务，可能上架新皮肤，且那么多皮肤包放在apk里面实在太占体积了，所以皮肤资源会在选择后再进行下载，也就不能直接使用android的那套theme。</p></blockquote><span id="more"></span><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p>内部资源加载方案和动态下载资源下载两种。</p><p>动态下载可以称为一种黑科技了，因为往往需要hack系统的一些方法，所以在部分机型和新的API上有时候可能有坑，但相对好处则很多</p><ul><li>图片/色值等资源由于是后台下发的，可以随时更新</li><li>APK体积减小</li><li>对应用开发者来说，换肤几乎是透明的，不需要关心有几套皮肤</li><li><strong>可以作为增值服务卖钱！！</strong></li></ul><h2 id="内部资源加载方案"><a href="#内部资源加载方案" class="headerlink" title="内部资源加载方案"></a>内部资源加载方案</h2><p>内部资源加载都是通过android本身那套theme来做的，相对业务开发来说工作量更大（需要定义attr和theme），不同方案类似地都是在BaseActivity里面做setTheme，差别主要在解决以下2个问题的策略：</p><ul><li>setTheme后如何实时刷新，而不用重新创建页面（尤其是listview里面的item）。</li><li>哪些view需要刷新，刷新什么（背景？字体颜色？ImageView的src？）。</li></ul><h2 id="自定义view"><a href="#自定义view" class="headerlink" title="自定义view"></a>自定义view</h2><p><a href="https://github.com/dersoncheng/MultipleTheme">MultipleTheme</a><br>做自定义view是为了在setTheme后会去立即刷新，更新页面UI对应资源（如TextView替换背景图和文字颜色），在上述项目中，则是通过对rootView进行遍历，对所有实现了ColorUiInterface的view/viewgroup进行setTheme操作来实现即使刷新的。</p><p>显然这样太重了，需要把应用内的各种view/viewgroup进行替换。</p><h2 id="手动绑定view和要改变的资源类型"><a href="#手动绑定view和要改变的资源类型" class="headerlink" title="手动绑定view和要改变的资源类型"></a>手动绑定view和要改变的资源类型</h2><p><a href="https://github.com/hehonghui/Colorful">Colorful</a></p><p>这个…我们看看用法吧….<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ViewGroupSetter listViewSetter = new ViewGroupSetter(mNewsListView);</span><br><span class="line">// 绑定ListView的Item View中的news_title视图，在换肤时修改它的text_color属性</span><br><span class="line">listViewSetter.childViewTextColor(R.id.news_title, R.attr.text_color);</span><br><span class="line"></span><br><span class="line">// 构建Colorful对象来绑定View与属性的对象关系</span><br><span class="line">mColorful = new Colorful.Builder(this)</span><br><span class="line">        .backgroundDrawable(R.id.root_view, R.attr.root_view_bg)</span><br><span class="line">        // 设置view的背景图片</span><br><span class="line">        .backgroundColor(R.id.change_btn, R.attr.btn_bg)</span><br><span class="line">        // 设置背景色</span><br><span class="line">        .textColor(R.id.textview, R.attr.text_color)</span><br><span class="line">        .setter(listViewSetter) // 手动设置setter</span><br><span class="line">        .create(); // 设置文本颜色</span><br></pre></td></tr></table></figure><br>我就是想换个皮肤，还得在activity里自己去设置要改变哪个view的什么属性，对应哪个attribute？是不是成本太高了？而且activity的逻辑也很容易被弄得乱七八糟。</p><h2 id="动态资源加载方案"><a href="#动态资源加载方案" class="headerlink" title="动态资源加载方案"></a>动态资源加载方案</h2><ul><li><p>resource替换</p><p>  覆盖application的getResource方法，实现自己的resource，优先加载本地皮肤包文件夹下的资源包，对于性能问题，可以通过attribute或者资源名称规范(如需要换肤则用skin_开头)来优化，从而不对不换肤的资源进行额外检查开销。</p><p>  不过由于Android5.1源码里，drawable初始化的时候调用的是loadDrawable，而不是resource.getDrawable，而loadDrawable是私有的方法，无法覆盖，所以虽然很方便，却无法继续使用（不用关心任何皮肤相关的事情，android:color指定颜色就行了，神奇滴会自动换肤）。</p></li><li><p>自定义LayoutInflator.Factory</p><p>  开源项目可参照<a href="https://github.com/fengjundev/Android-Skin-Loader">Android-Skin-Loader</a>。</p><p>  即setFactory使用自定义的LayoutInflator.Factory，可以重点关注该项目中的SkinInflaterFactory和SkinManager（实现了自己的getColor、getDrawable、getBitmap、getColorStateList等等方法）。</p><p>  需要自定义一个tag比如app:customStyle，重写所有的style，转成set方法，这样带来的牺牲就是增加了换肤的成本，要写很多style，自己去set，并不完全透明了。</p></li><li><p>Hack Resources internally</p></li></ul><p>黑科技方法，直接对Resources进行hack，Resources.java:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Information about preloaded resources.  Note that they are not</span><br><span class="line">// protected by a lock, because while preloading in zygote we are all</span><br><span class="line">// single-threaded, and after that these are immutable.</span><br><span class="line">private static final LongSparseArray&lt;Drawable.ConstantState&gt;[] sPreloadedDrawables;</span><br><span class="line">private static final LongSparseArray&lt;Drawable.ConstantState&gt; sPreloadedColorDrawables</span><br><span class="line">        = new LongSparseArray&lt;Drawable.ConstantState&gt;();</span><br><span class="line">private static final LongSparseArray&lt;ColorStateList&gt; sPreloadedColorStateLists</span><br><span class="line">        = new LongSparseArray&lt;ColorStateList&gt;();</span><br></pre></td></tr></table></figure><br>直接对Resources里面的这三个LongSparseArray进行替换，由于apk运行时的资源都是从这三个数组里面加载的，所以只要采用interceptor模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class DrawablePreloadInterceptor extends LongSparseArray&lt;Drawable.ConstantState&gt;</span><br></pre></td></tr></table></figure><p>自己实现一个LongSparseArray，并通过反射set回去，就能实现换肤，具体getDrawable等方法里是怎么取preload数组的，可以自己看Resources的源码。</p><p><strong>等等，就这么简单？</strong>，NONO，少年你太天真了，怎么去加载xml，9patch的padding怎么更新，怎么打包/加载自定义的皮肤包，drawable的状态怎么刷新，等等。这些都是你需要考虑的，在存在插件的app中，还需要考虑是否会互相覆盖resource id的问题，进而需要修改apt，把resource id按位放在2个range。</p><p>手机Q和独立版QQ空间使用的是这种方案，效果挺好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尽管动态加载方案比较黑科技，可能因为系统API的更改而出问题</p><h4 id="好处有"><a href="#好处有" class="headerlink" title="好处有"></a>好处有</h4><ul><li>灵活性高，后台可以随时更新皮肤包</li><li>相对透明，开发者几乎不用关心有几套皮肤，不用去定义各种theme和attr，甚至连皮肤包的打包都可以交给设计或者专门的同学</li><li>apk体积节省</li></ul><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>没有完善的开源项目，如果我们采用动态加载的第二种方案，需要的项目功能包括：</li><li>自定义皮肤包结构</li><li>换肤引擎，加载皮肤包资源并load，实时刷新。</li><li>皮肤包打包工具</li><li>对各种rom的兼容</li></ul><p>内部加载方案大同小异，主要解决的都是即时刷新的问题，然而从目前的一些开源项目来看，仍然没有特别简便的方案。让我选的话，我宁愿让界面重新创建，比如重启activity，或者remove所有view再添加回来（或者你可能想遍历rootview，然后一个个检查是否需要换肤然后set…）。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=65525&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题换肤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fragment实现懒加载，让应用更优化</title>
      <link href="/2016/06/15/16-06-15/"/>
      <url>/2016/06/15/16-06-15/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>玩过微信的都知道，微信用的是懒加载的模式，之所以使用懒加载是因为：当使用viewpager+adapter作为应用大的布局时，viewpager会通过setOffscreenPageLimit来设置预加载的项目，不设置setOffscreenPageLimit，则默认为1（设置0无效，可以查看该方法源码知道），也就是当我们打开应用看到的时候fragmentOne时，实际上其他fragment（例如fragmentSecond）也进行了加载，只不过没有显示出来罢了，但是这样就造成了不必要的资源浪费（例如，fragmentSecond没有显示，但是却进行了大量的网络加载操作）。</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/Fs5tcZ4YtAWiiQSTd3C-Sd2GtEei.png" alt=""> </p><p>基于上述情况，就有了懒加载方式的诞生（即只加载当前显示页面且只加载一次，滑动到其他页面时才加载其他页面数据，当再滑动到已加载过数据的页面时不再进行数据加载操作，若想要刷新数据，再调用相应的加载数据方法就好了）</p><span id="more"></span><h2 id="Fragment生命周期基本探索"><a href="#Fragment生命周期基本探索" class="headerlink" title="Fragment生命周期基本探索"></a>Fragment生命周期基本探索</h2><p>为了更好的知道懒加载的实现原理,下面通过几个测试来学习下。<br>测试的几个文件如下<br>（可以看到有3个fragment，由FragmentPagerAdapter+viewpager构成）<br><img src="http://dinson-blog.hdinson.cn/FgJr3yZRcvEbbGwyxGvLJNME8uZD.png" alt=""></p><ul><li><p>情况一 </p><blockquote><p>setOffscreenPageLimit（1） （即默认情况）</p></blockquote><p>  <img src="http://dinson-blog.hdinson.cn/FuyhIBXcimzU3g8AhbNVa5S34YlX.png" alt=""><br>  <img src="http://dinson-blog.hdinson.cn/Fj4ocWlvziFueLqsEtgNXAZ8lWre.png" alt=""><br>  <img src="http://dinson-blog.hdinson.cn/FlP4JrTIJhH5ITE83b2A1XEGlZm9.png" alt=""><br>  <img src="http://dinson-blog.hdinson.cn/Fk72ilJSN0EhKv33qrgyceV-EiXs.png" alt=""><br>  <img src="http://dinson-blog.hdinson.cn/Fp4__RXuDMjjPfBmLX8C0QeKfD7h.png" alt=""></p></li><li><p>情况二 </p><blockquote><p>setOffscreenPageLimit（3） （即设置预加载数目为实际fragment数目）</p></blockquote><p>  <img src="http://dinson-blog.hdinson.cn/Ftgn54rJbFytzTaYslj2okYjumLs.png" alt=""><br>  <img src="http://dinson-blog.hdinson.cn/FkohUN9ocz0L0nWz2nnVWAvwhD8P.png" alt=""><br>  <img src="http://dinson-blog.hdinson.cn/FmNl7tySMdIIs2RCpo3ljZ2L4zya.png" alt=""></p></li></ul><h2 id="Fragment懒加载实现"><a href="#Fragment懒加载实现" class="headerlink" title="Fragment懒加载实现"></a>Fragment懒加载实现</h2><p>可以看到无论是情况一还是情况二,fragment都会调用fragment的setUserVisibleHint进行判断，所以我们就需要在这里做文章。<br><img src="http://dinson-blog.hdinson.cn/FpDSDFxwfMOdJ4CkKSGMrPK5SiEu.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当isVisibleToUser 为true则进行数据加载，当isVisibleToUser为false则不进行数据加载</span><br><span class="line"></span><br><span class="line">对于已经加载过数据的fragment，再次被滑动到也不在进行加载数据，也就是每个fragment仅做一次数据加载工作</span><br></pre></td></tr></table></figure></p><p><strong>下面就来看代码实现</strong><br>主要代码都在BaseFragment中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseFragment extends Fragment &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isVisible = false;//当前Fragment是否可见</span><br><span class="line">    private boolean isInitView = false;//是否与View建立起映射关系</span><br><span class="line">    private boolean isFirstLoad = true;//是否是第一次加载数据</span><br><span class="line"></span><br><span class="line">    private View convertView;</span><br><span class="line">    private SparseArray&lt;View&gt; mViews;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class="line">        LogUtil.m(&quot;   &quot; + this.getClass().getSimpleName());</span><br><span class="line">        convertView = inflater.inflate(getLayoutId(), container, false);</span><br><span class="line">        mViews = new SparseArray&lt;&gt;();</span><br><span class="line">        initView();</span><br><span class="line">        isInitView = true;</span><br><span class="line">        lazyLoadData();</span><br><span class="line">        return convertView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onViewCreated(View view, Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onViewCreated(view, savedInstanceState);</span><br><span class="line">        LogUtil.m(&quot;   &quot; + this.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAttach(Context context) &#123;</span><br><span class="line">        super.onAttach(context);</span><br><span class="line">        LogUtil.m(&quot;context&quot; + &quot;   &quot; + this.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setUserVisibleHint(boolean isVisibleToUser) &#123;</span><br><span class="line">        LogUtil.m(&quot;isVisibleToUser &quot; + isVisibleToUser + &quot;   &quot; + this.getClass().getSimpleName());</span><br><span class="line">        if (isVisibleToUser) &#123;</span><br><span class="line">            isVisible = true;</span><br><span class="line">            lazyLoadData();</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            isVisible = false;</span><br><span class="line">        &#125;</span><br><span class="line">        super.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void lazyLoadData() &#123;</span><br><span class="line">        if (isFirstLoad) &#123;</span><br><span class="line">            LogUtil.m(&quot;第一次加载 &quot; + &quot; isInitView  &quot; + isInitView + &quot;  isVisible  &quot; + isVisible </span><br><span class="line">+ &quot;   &quot; + this.getClass().getSimpleName());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LogUtil.m(&quot;不是第一次加载&quot; + &quot; isInitView  &quot; + isInitView + &quot;  isVisible  &quot; + isVisible </span><br><span class="line">+ &quot;   &quot; + this.getClass().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isFirstLoad || !isVisible || !isInitView) &#123;</span><br><span class="line">            LogUtil.m(&quot;不加载&quot; + &quot;   &quot; + this.getClass().getSimpleName());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LogUtil.m(&quot;完成数据第一次加载&quot;);</span><br><span class="line">        initData();</span><br><span class="line">        isFirstLoad = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载页面布局文件</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected abstract int getLayoutId();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 让布局中的view与fragment中的变量建立起映射</span><br><span class="line">     */</span><br><span class="line">    protected abstract void initView();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载要显示的数据</span><br><span class="line">     */</span><br><span class="line">    protected abstract void initData();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * fragment中可以通过这个方法直接找到需要的view，而不需要进行类型强转</span><br><span class="line">     * @param viewId</span><br><span class="line">     * @param &lt;E&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected &lt;E extends View&gt; E findView(int viewId) &#123;</span><br><span class="line">        if (convertView != null) &#123;</span><br><span class="line">            E view = (E) mViews.get(viewId);</span><br><span class="line">            if (view == null) &#123;</span><br><span class="line">                view = (E) convertView.findViewById(viewId);</span><br><span class="line">                mViews.put(viewId, view);</span><br><span class="line">            &#125;</span><br><span class="line">            return view;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到initView方法是在onCreateView中调用，而initData只有执行过onCreateView才会调用，这样的顺序安排就不会导致在initData中执行数据加载过程，找不到需要的view而报错。</p><p>项目结构<br><img src="http://dinson-blog.hdinson.cn/FnrodVT6UJeUovMSnBMembOrPE6B.png" alt=""></p><p>演示效果<br><img src="http://dinson-blog.hdinson.cn/FuhGVLipT6KP_dkLfAoNqzsXaLNW.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/FuF_gL2BC2_mCYZnG4MZFj24og5F.png" alt=""></p><p>可以看到fragment只会进行执行一次initData，懒加载到此完整</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=67411&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android嫡系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fragment </tag>
            
            <tag> 懒加载 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkdownPad2在Win10下HTML渲染错误解决办法及注册码</title>
      <link href="/2016/06/14/16-06-14/"/>
      <url>/2016/06/14/16-06-14/</url>
      
        <content type="html"><![CDATA[<h3 id="HTML渲染错误解决办法"><a href="#HTML渲染错误解决办法" class="headerlink" title="HTML渲染错误解决办法"></a>HTML渲染错误解决办法</h3><p>在win10上安装MarkdownPad2 时，出现如下的错误信息：HTML渲染组出错，这个问题可以通过安装某个缺失组件来解决，是否想要了解详细信息？</p><p><img src="http://dinson-blog.hdinson.cn/9703407c1a94f6b0c1c73b162e25782d-thumb.png" alt=""></p><span id="more"></span><p>MarkdownPad 的FAQ文档中给出了解决办法：<a href="http://markdownpad.com/faq.html#livepreview-directx" title="http://markdownpad.com/faq.html#livepreview-directx">http://markdownpad.com/faq.html#livepreview-directx</a></p><blockquote><p>LivePreview is not working - it displays an error message stating This view has crashed!</p></blockquote><p>官方给出的解释是：这个问题一般多见于win8（*当然现在win10也有，官方文档该更新啦）。错误的表现形式即：不能实时预览Markdown生成的HTML页面。</p><blockquote><p>This issue has been specifically observed in Windows 8. You may see an error message <a href="http://markdownpad.com/img/faq/markdownpad-livepreview-crash-directx.png" title="http://markdownpad.com/img/faq/markdownpad-livepreview-crash-directx.png">as shown here</a>, and no HTML will be rendered when you type in the Markdown Editor pane.</p></blockquote><p>为了修复这个问题，你需要安装这么一个SDK工具包，点击链接获取。</p><blockquote><p>To fix this issue, please try installing the <a href="http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe" title="http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe">Awesomium 1.6.6  SDK</a>.</p></blockquote><p>如果还没有解决，那就买个新电脑吧！<br>哦！不是，让你再装个微软的渲染插件<br>If you continue to experience issues, please install <a href="https://www.microsoft.com/en-us/download/details.aspx?id=8109" title="https://www.microsoft.com/en-us/download/details.aspx?id=8109">Microsoft’s DirectX End-User Runtimes (June 2010)</a></p><h3 id="MarkdownPad2-5注册码"><a href="#MarkdownPad2-5注册码" class="headerlink" title="MarkdownPad2.5注册码"></a>MarkdownPad2.5注册码</h3><p>邮箱：</p><blockquote><p>Soar360@live.com</p></blockquote><p>授权密钥：</p><blockquote><p>GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=65761&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 软件破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio插件整理</title>
      <link href="/2016/06/10/16-06-10/"/>
      <url>/2016/06/10/16-06-10/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>在现如今这个极度推崇敏捷开发的年代，开发时间的节省将会直接压缩开发成本，在这其中，一些开发工具的合理利用讲会极大简化开发工作并增强开发效率。本文将介绍笔者自己在平时开发中经常用到的一些插件，我只能说它们都很实用，当然都是适用于Android Studio的啦。<br><span id="more"></span></p><h2 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h2><p>快速将json字符串转换成一个Java Bean，免去我们根据json字符串手写对应Java Bean的过程。<br>使用方法：快捷键Alt+S也可以使用Alt+Insert选择GsonFormat </p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/610-1.gif" alt=""></p><h2 id="Android-ButterKnife-Zelezny"><a href="#Android-ButterKnife-Zelezny" class="headerlink" title="Android ButterKnife Zelezny"></a>Android ButterKnife Zelezny</h2><blockquote><p>配合ButterKnife实现注解，从此不用写findViewById，想着就爽啊。在Activity，Fragment，Adapter中选中布局xml的资源id自动生成butterknife注解。<br>使用方法：Ctrl+Shift+B选择图上所示选项</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/610-2.gif" alt=""></p><h2 id="Android-Code-Generator"><a href="#Android-Code-Generator" class="headerlink" title="Android Code Generator"></a>Android Code Generator</h2><blockquote><p>根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/610-3.1.gif" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/610-3.2.gif" alt=""></p><h2 id="Android-Methods-Count"><a href="#Android-Methods-Count" class="headerlink" title="Android Methods Count"></a>Android Methods Count</h2><blockquote><p>显示依赖库中得方法数</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/610-5.gif" alt=""></p><h2 id="Lifecycle-Sorter"><a href="#Lifecycle-Sorter" class="headerlink" title="Lifecycle Sorter"></a>Lifecycle Sorter</h2><blockquote><p>可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序<br>使用方法：快捷键Ctrl + alt + K</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/610-6.1.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/610-6.2.jpg" alt=""></p><h2 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h2><blockquote><p>在右边可以预览代码，实现快速定位</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/610-7.1.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/610-6.2.jpg" alt=""></p><h2 id="FindBugs-IDEA"><a href="#FindBugs-IDEA" class="headerlink" title="FindBugs-IDEA"></a>FindBugs-IDEA</h2><blockquote><p>查找bug的插件，Android Studio也提供了代码审查的功能（Analyze-Inspect Code…）</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/610-8.jpg" alt=""></p><h2 id="ADB-WIFI"><a href="#ADB-WIFI" class="headerlink" title="ADB WIFI"></a>ADB WIFI</h2><blockquote><p>使用wifi无线调试你的app，无需root权限</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/610-9.jpg" alt=""></p><h2 id="Android-Styler"><a href="#Android-Styler" class="headerlink" title="Android Styler"></a>Android Styler</h2><blockquote><p>根据xml自动生成style代码的插件<br>使用方法：快捷键Ctrl+Shift+D (or context menu)</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/12.1.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/12.2.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/12.3.jpg" alt=""></p><h2 id="Android-Drawable-Importer"><a href="#Android-Drawable-Importer" class="headerlink" title="Android Drawable Importer"></a>Android Drawable Importer</h2><blockquote><p>这是一个非常强大的图片导入插件。它导入Android图标与Material图标的Drawable ，批量导入Drawable ，多源导入Drawable（即导入某张图片各种dpi对应的图片）</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/13.1.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/13.2.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/13.3.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/13.4.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/13.5.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/13.6.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/13.7.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/13.8.jpg" alt=""></p><h2 id="SelectorChapek-for-Android"><a href="#SelectorChapek-for-Android" class="headerlink" title="SelectorChapek for Android"></a>SelectorChapek for Android</h2><blockquote><p>通过资源文件命名自动生成Selector文件。</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/14.1.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/14.2.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/14.3.png" alt=""></p><h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><blockquote><p>帮助你在开发阶段方便的检测出内存泄露的问题，使用起来更简单方便。</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/17.jpg" alt=""></p><h2 id="Android-Postfix-Completion"><a href="#Android-Postfix-Completion" class="headerlink" title="Android Postfix Completion"></a>Android Postfix Completion</h2><blockquote><p>可根据后缀快速完成代码，这个属于拓展吧，系统已经有这些功能，如sout、notnull等，这个插件在原有的基础上增添了一些新的功能</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/18.gif" alt=""></p><h2 id="Android-Holo-Colors-Generator"><a href="#Android-Holo-Colors-Generator" class="headerlink" title="Android Holo Colors Generator"></a>Android Holo Colors Generator</h2><blockquote><p>通过自定义Holo主题颜色生成对应的Drawable和布局文件</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/19.jpg" alt=""></p><h2 id="GradleDependenciesHelperPlugin"><a href="#GradleDependenciesHelperPlugin" class="headerlink" title="GradleDependenciesHelperPlugin"></a>GradleDependenciesHelperPlugin</h2><blockquote><p>maven gradle 依赖支持自动补全</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/21.jpg" alt=""></p><h2 id="Idea-markdown"><a href="#Idea-markdown" class="headerlink" title="Idea-markdown"></a>Idea-markdown</h2><blockquote><p>markdown插件</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/26.jpg" alt=""></p><h2 id="Sexy-Editor"><a href="#Sexy-Editor" class="headerlink" title="Sexy Editor"></a>Sexy Editor</h2><blockquote><p>设置AS代码编辑区的背景图</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/27.1.png" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/27.2.png" alt=""></p><h2 id="Android-DPI-Calculator"><a href="#Android-DPI-Calculator" class="headerlink" title="Android-DPI-Calculator"></a>Android-DPI-Calculator</h2><blockquote><p>DPI计算插件</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/29.1.png" alt=""></p><p>使用：</p><p><img src="http://dinson-blog.hdinson.cn/160610/29.2.png" alt=""></p><p>或者：</p><p><img src="http://dinson-blog.hdinson.cn/160610/29.3.png" alt=""></p><h2 id="Gradle-retrolambda"><a href="#Gradle-retrolambda" class="headerlink" title="Gradle-retrolambda"></a>Gradle-retrolambda</h2><blockquote><p>在java 6 7中使用 lambda表达式插件</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/30.jpg" alt=""></p><h2 id="Material-Theme-UI"><a href="#Material-Theme-UI" class="headerlink" title="Material Theme UI"></a>Material Theme UI</h2><blockquote><p>添加Material主题到你的AS</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/32.1.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/32.2.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/32.3.jpg" alt=""></p><h2 id="ECTranslation"><a href="#ECTranslation" class="headerlink" title="ECTranslation"></a>ECTranslation</h2><blockquote><p>Android Studio Plugin,Translate English to Chinese. Android Studio 翻译插件,可以将英文翻译为中文</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/36.jpg" alt=""></p><h2 id="PermissionsDispatcher-plugin"><a href="#PermissionsDispatcher-plugin" class="headerlink" title="PermissionsDispatcher plugin"></a>PermissionsDispatcher plugin</h2><blockquote><p>自动生成6.0权限的代码</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/37.gif" alt=""></p><h2 id="WakaTime"><a href="#WakaTime" class="headerlink" title="WakaTime"></a>WakaTime</h2><blockquote><p>记录你在IDE上的工作时间</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/38.png" alt=""></p><h2 id="AndroidLocalizationer"><a href="#AndroidLocalizationer" class="headerlink" title="AndroidLocalizationer"></a>AndroidLocalizationer</h2><blockquote><p>可用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件</p></blockquote><p><img src="http://dinson-blog.hdinson.cn/160610/40.1.jpg" alt=""><br><img src="http://dinson-blog.hdinson.cn/160610/40.2.jpg" alt=""></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=25638273&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android庶系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> AS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓反编译</title>
      <link href="/2016/06/08/16-06-08/"/>
      <url>/2016/06/08/16-06-08/</url>
      
        <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>apktool:资源文件获取，可以提取出图片文件和布局文件进行使用查看 </li><li>dex2jar:将apk反编译成Java源码（classes.dex转化成jar文件）</li><li>jd-gui:查看APK中classes.dex转化成出的jar文件，即源码文件</li></ul><blockquote><p>网盘： <a href="http://pan.baidu.com/s/1eSkSctc">http://pan.baidu.com/s/1eSkSctc</a> &emsp; 密码：low6<br><span id="more"></span></p><h3 id="反编译得到源代码、图片、XML配置、语言资源等"><a href="#反编译得到源代码、图片、XML配置、语言资源等" class="headerlink" title="反编译得到源代码、图片、XML配置、语言资源等"></a>反编译得到源代码、图片、XML配置、语言资源等</h3><p>打开命令行界面（运行-CMD），定位到apktool文件夹，输入以下命令：<br>apktool.bat&emsp;d&emsp;-f&emsp;[apk文件 ]&emsp;[输出文件夹]</p><p>例：apktool.bat&emsp;d&emsp;-f&emsp;test.apk&emsp;test </p></blockquote><p>之后发现在文件夹下多了个test文件，点击便可以查看该应用的所有资源文件了。</p><p>如果你想将反编译完的文件重新打包成apk，那你可以：输入apktool.bat&emsp;b&emsp;test（你编译出来文件夹）便可。<br>之后在之前的test文件下便可以发现多了2个文件夹:<br>&emsp;&emsp; -  build<br>&emsp;&emsp; -  dist(里面存放着打包出来的APK文件)</p><h3 id="反编译得到Java源代码"><a href="#反编译得到Java源代码" class="headerlink" title="反编译得到Java源代码"></a>反编译得到Java源代码</h3><p>将APK后缀名改为.rar或.zip，并解压，得到其中的额classes.dex文件（它就是java文件编译再通过dx工具打包而成的），将获取到的classes.dex放到之前解压出来的工具dex2jar-0.0.9.15 文件夹内，在命令行下定位到dex2jar.bat所在目录，输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dex2jar.bat   classes.dex</span><br></pre></td></tr></table></figure><br>将生成<br>classes.dex.dex2jar.jar，如下图<br><img src="http://dinson-blog.hdinson.cn/01163842.png" alt=""><br>运行JD-GUI（jd-gui.exe），打开上面生成的jar包，即可看到源代码了<br><img src="http://dinson-blog.hdinson.cn/1164203.png" alt=""><br>HelloAndroid源码（编译前的apk源码对照）如下：<br><img src="http://dinson-blog.hdinson.cn/1164360.png" alt=""></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=25638887&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> Android庶系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用配置</title>
      <link href="/2016/06/07/16-06-07/"/>
      <url>/2016/06/07/16-06-07/</url>
      
        <content type="html"><![CDATA[<h2 id="Java环境变量"><a href="#Java环境变量" class="headerlink" title="Java环境变量"></a>Java环境变量</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">新建：值为JDK安装目录</span><br><span class="line">JAVA_Home</span><br><span class="line"></span><br><span class="line">Path中添加</span><br><span class="line">%JAVA_HOME%\bin</span><br><span class="line">%JAVA_HOME%\jre\bin</span><br></pre></td></tr></table></figure><h2 id="Android环境变量"><a href="#Android环境变量" class="headerlink" title="Android环境变量"></a>Android环境变量</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">新建：值为SDK安装目录</span><br><span class="line">Android_Home</span><br><span class="line"></span><br><span class="line">Path中添加</span><br><span class="line">%Android_Home%\tools</span><br><span class="line">%Android_Home%\platform-tools</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="win10修改文件类型图标"><a href="#win10修改文件类型图标" class="headerlink" title="win10修改文件类型图标"></a>win10修改文件类型图标</h2><p>比如.<em>.rmvb、</em>.doc，我们并不想使用其原先的默认图标；或者是某个软件因为下载的是硬盘版，所以没有进行文件关联，从而进行关联的时候，致使这类文件图标并不美观，等等。在一般情况下，我们可以通过安装其它软件从而达到修改文件图标的目的。但是在这里，我将向大家介绍修改注册表的方法更改文件图标。下面我以*.apk 这类文件作为例子，向大家介绍如何通过修改注册表更改文件图标。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=66265&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 系统配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+Hexo搭建个人博客辛酸史--基础搭建(壹)</title>
      <link href="/2016/06/06/16-06-06/"/>
      <url>/2016/06/06/16-06-06/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>hexo是一款基于Node.js的静态博客框架, <a href="https://github.com/hexojs/hexo">Hexo github 链接</a> 链接 ,这篇教程是针对与Mac的，参考链接，由于原文讲到的hexo是以前的老版本，所以现在的版本配置的时候会有些改动。</p></blockquote><span id="more"></span><p>PS : <strong>以下教程是针对hexo的版本为3.x</strong></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><p>  到<a href="https://nodejs.org/en/"> Node.js </a>官网下载相应平台的最新版本，一路安装即可。</p></li><li><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>  下载 <a href="http://msysgit.github.io/">msysgit</a> 并执行即可完成安装。</p></li><li><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>  使用以下命令安装hexo到全局（在任意位置点击鼠标右键，选择Git bash）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><blockquote><p>ps : npm ERR! registry error parsing json 错误(可能需要设置npm代理,执行命令)</p></blockquote>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://registry.cnpmjs.org</span><br></pre></td></tr></table></figure></li><li><h3 id="创建hexo文件夹"><a href="#创建hexo文件夹" class="headerlink" title="创建hexo文件夹"></a>创建hexo文件夹</h3>  安装完成后，在你喜爱的文件夹下（如H:\hexo），执行以下指令(在H:\hexo内点击鼠标右键，选择Git bash)，Hexo 即会自动在目标文件夹建立网站所需要的所有文件。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></li><li><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><h3 id="本地查看"><a href="#本地查看" class="headerlink" title="本地查看"></a>本地查看</h3><p>  至此，我们的博客就已经搭建完毕了，执行下面命令部署到本地服务器，然后到浏览器输入localhost:4000看看。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><blockquote><p>执行hexo server提示找不到该指令<br>在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：</p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure><p>  这里我碰到了一个问题，就是提示</p><blockquote><p>npm WARN deprecated swig@1.4.2: This package is no longer maintained</p></blockquote><p>  如下图：<br>  <img src="http://dinson-blog.hdinson.cn/Fmry--1ovF2aOdbGaI06J9T6Mfmt.png" alt=""></p><p>  起初以为是报了个错误，于是网上一顿搜，各种更新各种折腾。后来发现，其实一直是在安装中，只是速度慢而已，导致我认为出了错误。通过google，通过npm config set registry “<a href="https://registry.npm.taobao.org&quot;设置淘宝镜像源后，很快就安装完毕了，弹出了如下界面">https://registry.npm.taobao.org&quot;设置淘宝镜像源后，很快就安装完毕了，弹出了如下界面</a><br>  <img src="http://dinson-blog.hdinson.cn/FhfyVbeH2s7_jrQjFdfZ3LEcDWbS.png" alt=""></p></li><li><h3 id="Hexo插件"><a href="#Hexo插件" class="headerlink" title="Hexo插件"></a>Hexo插件</h3>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-index --save #索引生成器</span><br><span class="line">$ npm install hexo-generator-archive --save #归档生成器</span><br><span class="line">$ npm install hexo-generator-category --save #分类生成器</span><br><span class="line">$ npm install hexo-generator-tag --save #标签生成器</span><br><span class="line">$ npm install hexo-server --save #本地服务</span><br><span class="line">$ npm install hexo-deployer-git --save #hexo通过git发布（必装）</span><br><span class="line">$ npm install hexo-renderer-marked@<span class="number">0.2</span><span class="number">.7</span> --save #渲染器</span><br><span class="line">$ npm install hexo-renderer-stylus@<span class="number">0.3</span><span class="number">.0</span> --save #渲染器</span><br><span class="line"></span><br><span class="line">$ npm install hexo-generator-sitemap --save#站点地图</span><br><span class="line">$ npm install hexo-generator-baidu-sitemap --save#百度站点地图</span><br></pre></td></tr></table></figure><h2 id="Github-创建博客空间"><a href="#Github-创建博客空间" class="headerlink" title="Github 创建博客空间"></a>Github 创建博客空间</h2></li><li><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3>  地址：<a href="https://github.com/">https://github.com/</a></li><li><h3 id="创建页面仓库"><a href="#创建页面仓库" class="headerlink" title="创建页面仓库"></a>创建页面仓库</h3><p>  <img src="http://dinson-blog.hdinson.cn/832.png" alt=""><br>  <img src="http://dinson-blog.hdinson.cn/235.png" alt=""></p><blockquote><p>命名规则：你的github账号.github.io（必须，否则部署完毕之后会404）<br>笔者因为已创建所以报错</p></blockquote></li><li><h3 id="生成SSH密钥"><a href="#生成SSH密钥" class="headerlink" title="生成SSH密钥"></a>生成SSH密钥</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “你的邮箱地址”</span><br></pre></td></tr></table></figure>  按3个回车，密码为空。<br>  在C:\Users\Administrator.ssh下，得到两个文件id_rsa和id_rsa.pub。</li><li><h3 id="在GitHub上添加SSH密钥"><a href="#在GitHub上添加SSH密钥" class="headerlink" title="在GitHub上添加SSH密钥"></a>在GitHub上添加SSH密钥</h3>  打开id_rsa.pub，复制全文。<a href="https://github.com/settings/ssh">https://github.com/settings/ssh</a> ，Add SSH key，粘贴进去。</li></ul><h2 id="Hexo简单介绍"><a href="#Hexo简单介绍" class="headerlink" title="Hexo简单介绍"></a>Hexo简单介绍</h2><ul><li><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── .deploy #需要部署的文件</span><br><span class="line">├── node_modules #Hexo插件</span><br><span class="line">├── public #生成的静态网页文件</span><br><span class="line">├── scaffolds #模板</span><br><span class="line">├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里</span><br><span class="line">      ├── _drafts #草稿</span><br><span class="line">      └── _posts #文章</span><br><span class="line">├── themes #主题</span><br><span class="line">├── _config.yml #全局配置文件</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure></li><li><h3 id="全局配置-config-yml"><a href="#全局配置-config-yml" class="headerlink" title="全局配置 _config.yml"></a>全局配置 _config.yml</h3>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line"># Docs: http:<span class="comment">//hexo.io/docs/configuration.html</span></span><br><span class="line"># Source: https:<span class="comment">//github.com/hexojs/hexo/</span></span><br><span class="line"># Site #站点信息</span><br><span class="line"><span class="attr">title</span>:  #标题</span><br><span class="line"><span class="attr">subtitle</span>:  #副标题</span><br><span class="line"><span class="attr">description</span>:  #站点描述，给搜索引擎看的</span><br><span class="line"><span class="attr">author</span>:  #作者</span><br><span class="line"><span class="attr">email</span>:  #电子邮箱</span><br><span class="line"><span class="attr">language</span>: zh-CN #语言</span><br><span class="line"># URL #链接格式</span><br><span class="line"><span class="attr">url</span>:  #网址</span><br><span class="line"><span class="attr">root</span>: / #根目录</span><br><span class="line"><span class="attr">permalink</span>: :year/:month/:day/:title/ #文章的链接格式</span><br><span class="line"><span class="attr">tag_dir</span>: tags #标签目录</span><br><span class="line"><span class="attr">archive_dir</span>: archives #存档目录</span><br><span class="line"><span class="attr">category_dir</span>: categories #分类目录</span><br><span class="line"><span class="attr">code_dir</span>: downloads/code</span><br><span class="line"><span class="attr">permalink_defaults</span>:</span><br><span class="line"># Directory #目录</span><br><span class="line"><span class="attr">source_dir</span>: source #源文件目录</span><br><span class="line"><span class="attr">public_dir</span>: public #生成的网页文件目录</span><br><span class="line"># Writing #写作</span><br><span class="line"><span class="attr">new_post_name</span>: :title.md #新文章标题</span><br><span class="line"><span class="attr">default_layout</span>: post #模板，包括 post、page、photo、draft（文章、页面、照片、草稿）</span><br><span class="line"><span class="attr">titlecase</span>: <span class="literal">false</span> #标题转换成大写</span><br><span class="line"><span class="attr">external_link</span>: <span class="literal">true</span> #在新选项卡中打开连接</span><br><span class="line"><span class="attr">filename_case</span>: <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts</span>: <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder</span>: <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link</span>: <span class="literal">false</span></span><br><span class="line"><span class="attr">highlight</span>: #语法高亮</span><br><span class="line">  <span class="attr">enable</span>: <span class="literal">true</span> #是否启用</span><br><span class="line">  <span class="attr">line_number</span>: <span class="literal">true</span> #显示行号</span><br><span class="line">  <span class="attr">tab_replace</span>:</span><br><span class="line"># Category &amp; Tag #分类和标签</span><br><span class="line"><span class="attr">default_category</span>: uncategorized #默认分类</span><br><span class="line"><span class="attr">category_map</span>:</span><br><span class="line">tag_map:</span><br><span class="line"># Archives</span><br><span class="line"><span class="number">2</span>: 开启分页</span><br><span class="line"><span class="number">1</span>: 禁用分页</span><br><span class="line"><span class="number">0</span>: 全部禁用</span><br><span class="line"><span class="attr">archive</span>: <span class="number">2</span></span><br><span class="line"><span class="attr">category</span>: <span class="number">2</span></span><br><span class="line"><span class="attr">tag</span>: <span class="number">2</span></span><br><span class="line"># Server #本地服务器</span><br><span class="line"><span class="attr">port</span>: <span class="number">4000</span> #端口号</span><br><span class="line"><span class="attr">server_ip</span>: localhost #IP 地址</span><br><span class="line"><span class="attr">logger</span>: <span class="literal">false</span></span><br><span class="line"><span class="attr">logger_format</span>: dev</span><br><span class="line"># <span class="built_in">Date</span> / Time format #日期时间格式</span><br><span class="line"><span class="attr">date_format</span>: YYYY-MM-DD #参考http:<span class="comment">//momentjs.com/docs/#/displaying/format/</span></span><br><span class="line">time_format: H:mm:ss</span><br><span class="line"># Pagination #分页</span><br><span class="line"><span class="attr">per_page</span>: <span class="number">10</span> #每页文章数，设置成 <span class="number">0</span> 禁用分页</span><br><span class="line"><span class="attr">pagination_dir</span>: page</span><br><span class="line"># Disqus #Disqus评论，替换为多说</span><br><span class="line"><span class="attr">disqus_shortname</span>:</span><br><span class="line"># Extensions #拓展插件</span><br><span class="line"><span class="attr">theme</span>: landscape-plus #主题</span><br><span class="line"><span class="attr">exclude_generator</span>:</span><br><span class="line">plugins: #插件，例如生成 RSS 和站点地图的</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"># Deployment #部署，将 lmintlcx 改成用户名</span><br><span class="line"><span class="attr">deploy</span>:</span><br><span class="line">  type: git</span><br><span class="line">  <span class="attr">repo</span>: 刚刚github创库地址.git</span><br><span class="line">  <span class="attr">branch</span>: master</span><br></pre></td></tr></table></figure></li><li><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo help #查看帮助</span><br><span class="line">hexo init #初始化一个目录</span><br><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;postName&quot;</span> #新建文章，简写 hexo n</span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">&quot;pageName&quot;</span> #新建页面</span><br><span class="line">hexo generate #生成网页，可以在 public 目录查看整个网站的文件，简写 hexo g</span><br><span class="line">hexo server #本地预览，<span class="string">&#x27;Ctrl+C&#x27;</span>关闭，简写 hexo s</span><br><span class="line">hexo deploy #部署.deploy目录，简写 hexo d，部署的地址为全局配置设置</span><br><span class="line">hexo clean #清除缓存</span><br></pre></td></tr></table></figure></li><li><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><blockquote><p>hexo deploy问题：Deployer not found: git</p></blockquote>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save </span><br></pre></td></tr></table></figure></li><li><h3 id="Hexo文章格式"><a href="#Hexo文章格式" class="headerlink" title="Hexo文章格式"></a>Hexo文章格式</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: #文章的标题</span><br><span class="line">date: 2015-07-30 07:56:29 #发表日期，一般不改动（可以改动）</span><br><span class="line">categories: categories1 #文章文类</span><br><span class="line">tags: [tags1,tags2] #文章标签，多于一项时用这种格式</span><br><span class="line">---</span><br><span class="line">正文，使用Markdown语法书写</span><br></pre></td></tr></table></figure><h2 id="域名的绑定"><a href="#域名的绑定" class="headerlink" title="域名的绑定"></a>域名的绑定</h2></li><li><h3 id="创建CNAME文件"><a href="#创建CNAME文件" class="headerlink" title="创建CNAME文件"></a>创建CNAME文件</h3>  在站点source目录或者在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如dinson.win</li><li><h3 id="DNS域名指向"><a href="#DNS域名指向" class="headerlink" title="DNS域名指向"></a>DNS域名指向</h3>  在你购买域名的网站的控制台修改，例如我在阿里云买的，则<a href="https://account.aliyun.com/login/login.html">去阿里云登录</a>，再把你的域名指向你项目的IP地址，如何知道你项目的ip地址呢，在命令提示符中输入下面代码  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &quot;你的用户名&quot;.github.io</span><br></pre></td></tr></table></figure></li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=66282&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 个人博客辛酸系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
